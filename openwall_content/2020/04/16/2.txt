  oss-security - Re: Linux kernel to 5.1: powerpc: guest can  cause DoS on POWER9 KVM hosts            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [<thread-prev] [day] [month] [year] [list]  Date: Thu, 16 Apr From: Paul Mackerras <paulus@...abs.org> To: Michal Suchรกnek <msuchanek@...e.de> Cc: Andrew Donnellan <ajd@...ux.ibm.com>, oss-security@...ts.openwall.com, 	linuxppc-dev <linuxppc-dev@...ts.ozlabs.org> Subject: Re: Linux kernel to 5.1: powerpc: guest can  cause DoS on POWER9 KVM hosts  On Wed, Apr 15, at Michal Suchรกnek wrote: > On Wed, Apr 15, at Andrew Donnellan wrote: > > The Linux kernel for powerpc from to v5.1 has a bug where the > > Authority Mask Register (AMR), Authority Mask Override Register (AMOR) and > > User Authority Mask Override Register (UAMOR) are not correctly saved and > > restored when the CPU is going into/coming out of idle state. > >  > > On POWER9 CPUs, this means that a CPU may return from idle with the AMR > > value of another thread on the same core. > >  > > This allows a trivial Denial of Service attack against KVM hosts, by booting > > a guest kernel which makes use of the AMR, such as a v5.2 or later kernel > > with Kernel Userspace Access Prevention (KUAP) enabled. > >  > > The guest kernel will set the AMR to prevent userspace access, then the > > thread will go idle. At a later point, the hardware thread that the guest > > was using may come out of idle and start executing in the host, without > > restoring the host AMR value. The host kernel can get caught in a page fault > > loop, as the AMR is unexpectedly causing memory accesses to fail in the > > host, and the host is eventually rendered unusable. >  > Hello, >  > shouldn't the kernel restore the host registers when leaving the guest?  It does.  That's not the bug.  > I recall some code exists for handling the *AM*R when leaving guest. Can > the KVM guest enter idle without exiting to host?  No, we currently never execute the "stop" instruction in guest context.  The bug occurs when a thread that is in the host goes idle and executes the stop instruction to go to a power-saving state, while another thread is executing inside a guest.  Hardware loses the first thread's AMR while it is stopped, and as it happens, it is possible for the first thread to wake up with the contents of its AMR equal to the other thread's AMR.  This can happen even if the first thread has never executed in the guest.  The kernel needs to save and restore AMR (among other registers) across the stop instruction because of this hardware behaviour. We missed the AMR initially, which is what led to this vulnerability.  Paul.  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      