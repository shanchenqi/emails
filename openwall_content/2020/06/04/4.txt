  oss-security - Linux kernel: mremap hugepage mmaped DAX nvdimm may  cause corrupted page table            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Thu, 4 Jun From: Fan Yang <fan_yang@...U.EDU.CN> To: oss-security@...ts.openwall.com Subject: Linux kernel: mremap hugepage mmaped DAX nvdimm may  cause corrupted page table  Hi all,  NOTE: this bug have been assigned CVE id  Its impact dates back to the commit ("mm, dax: dax-pmd vs thp-pmd vs hugetlbfs-pmdâ), at kernel version v4.5.  And it can be fixed by the patch here  Description ===========  I observed this bug when mremap a mmaped DAX nvdimm to a mmaped anonymous memory region.  The mremap system call returns successfully but when access the region afterwards, the program get killed due to corrupted page table:  try_mremap: Corrupted page table at address PGD P4D PUD PMD PTE Bad pagetable: [#3] SMP PTI CPU: 6 PID: Comm: try_mremap Tainted: G    B D W         #1 Hardware name: System manufacturer System Product Name/PRIME BIOS RIP: Code: 00 00 e8 87 fd ff ff 48 89 45 e8 48 8b 45 e8 48 3b 45 f8 74 11 bf 3a 20 40 00 e8 8f fd ff ff b8 ff ff ff ff eb 0c 48 8b 45 f8 <c6> 00 aa b8 00 00 00 00 c9 c3 66 2e 0f 1f 84 00 00 00 00 00 f3 0f RSP: EFLAGS: RAX: RBX: RCX: RDX: RSI: RDI: RBP: R08: R09: R10: R11: R12: R13: R14: R15: ... BUG: Bad page map in process try_mremap  index:0 file:try_mremap fault:ext4_dax_fault mmap:ext4_file_mmap readpage:0x0 CPU: 6 PID: Comm: try_mremap Tainted: G    B D W         #1 Hardware name: System manufacturer System Product Name/PRIME BIOS Call Trace:  Note that the weird in the pte value is the ascii of "i" which I had written to the memory.  This bug is due to in move_page_tables:mm/mremap.c, the condition to handle a huge pmd is as follows:  		if (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd)) {  However, the DAX file is mapped as huge page but it is not transparent huge page.  So the huge pmd is not split, the physical page the pmd points to is treated as a page table (but actually it is a 2M data page).  Then move_ptes uses the value of the "pte" to update the pte where the page remap to, and the mremap system call returns successfully.  Afterwards, the access to the new address incurs corrupted page table.  Re-produce Instructions =======================  1. one need to have a machine with Intel Optane DC Persistent Memory (https://www.intel.com/content/www/us/en/architecture-and-technology/optane-dc-persistent-memory.html), or run a VM with a virtualized NVDIMM (https://software.intel.com/content/www/us/en/develop/articles/how-to-emulate-persistent-memory-on-an-intel-architecture-server.html).  2. mount a DAX file system (e.g., I use ext4).  3. Write a userspace program to mremap a DAX mmaped file to a mmaped   anonymous memory region.  Here is the code I use:  #define _GNU_SOURCE #include <sys/mman.h> #include <stdio.h> #include <unistd.h> #include <string.h> #include <fcntl.h> #include <stdlib.h> #include <errno.h>  #define PROT			PROT_READ|PROT_WRITE  #define REGION_PM_TMP_PATH	"/mnt/pmem0/try_mremap"  #define REGION_MEM_SIZE #define #define REMAP_MEM_OFF   0 #define REMAP_PM_OFF    0 #define REMAP_SIZE       char * map_tmp_pm_region(void) { 	int fd;  	fd = open(REGION_PM_TMP_PATH, O_RDWR|O_CREAT, 	if (fd < 0) { 		perror(REGION_PM_TMP_PATH); 		exit(-1); 	}  	if (ftruncate(fd, REGION_PM_SIZE)) { 		perror("ftruncate"); 		exit(-1); 	}  	return mmap(NULL, REGION_PM_SIZE, PROT, MAP_SHARED_VALIDATE|MAP_SYNC, 		    fd, 0); }  int main(int argc, char **argv) { 	char *regm, *regp, *remap; 	int ret;  	regm = mmap(NULL, REGION_MEM_SIZE, PROT, MAP_PRIVATE|MAP_ANONYMOUS, 		    -1, 0); 	if (regm == MAP_FAILED) { 		perror("regm"); 		return -1; 	}  	regp = map_tmp_pm_region(); 	if (regp == MAP_FAILED) { 		perror("regp"); 		return -1; 	}  	memset(regm, 'a', REGION_MEM_SIZE); 	memset(regp, 'i', REGION_PM_SIZE);  	remap = mremap(regp + REMAP_PM_OFF, REMAP_SIZE, REMAP_SIZE, 		       MREMAP_MAYMOVE|MREMAP_FIXED, regm + REMAP_MEM_OFF); 	if (remap != regm + REMAP_MEM_OFF) { 		perror("mremap"); 		return -1; 	}  	*regm = 0xAA;		/* write anything to the address */ 	return 0; }  The Patch =========  arch/x86/include/asm/pgtable.h | 1 + mm/mremap.c                    | 2 +- 2 files changed, 2 insertions(+), 1 deletion(-)  diff --git a/arch/x86/include/asm/pgtable.h b/arch/x86/include/asm/pgtable.h index --- a/arch/x86/include/asm/pgtable.h +++ b/arch/x86/include/asm/pgtable.h @@ @@ static inline int pmd_large(pmd_t pte) }  #ifdef CONFIG_TRANSPARENT_HUGEPAGE +/* NOTE: when predicate huge page, consider also pmd_devmap, or use pmd_large */ static inline int pmd_trans_huge(pmd_t pmd) { 	return (pmd_val(pmd) & (_PAGE_PSE|_PAGE_DEVMAP)) == _PAGE_PSE; diff --git a/mm/mremap.c b/mm/mremap.c index --- a/mm/mremap.c +++ b/mm/mremap.c @@ @@ unsigned long move_page_tables(struct vm_area_struct *vma, 		new_pmd = alloc_new_pmd(vma->vm_mm, vma, new_addr); 		if (!new_pmd) 			break; -		if (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd)) { +		if (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd) || pmd_devmap(*old_pmd)) { 			if (extent == HPAGE_PMD_SIZE) { 				bool moved; 				/* See comment in move_ptes() */ --     Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      