  oss-security -  kernel: many bugs in nfc socket            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Sun, 1 Nov From: kiyin(ĺ°šäşŽ) <kiyin@...cent.com> To: "oss-security@...ts.openwall.com" <oss-security@...ts.openwall.com> CC: Greg KH <greg@...ah.com>, Anthony Liguori <aliguori@...zon.com> Subject:  kernel: many bugs in nfc socket  CVE Assigned: > : new bug 1 > : new bug 2 > : new bug 3 > : new bug 4  Patches: not yet available  Details:  Hi,  we found many bugs in nfc socket. Here is the detail.  At first, let's see a fixed bug from this patch fixed a memory leak bug in llcp_sock_bind()  --- a/net/nfc/llcp_sock.c +++ b/net/nfc/llcp_sock.c @@ @@  static int llcp_sock_bind(struct socket      llcp_sock->service_name = kmemdup(llcp_addr.service_name,                        llcp_sock->service_name_len,                        GFP_KERNEL); - +    if (!llcp_sock->service_name) { +        ret = -ENOMEM; +        goto put_dev; +    }      llcp_sock->ssap = nfc_llcp_get_sdp_ssap(local, llcp_sock);      if (llcp_sock->ssap == LLCP_SAP_MAX) { +        kfree(llcp_sock->service_name); +        llcp_sock->service_name = NULL;          ret = -EADDRINUSE;          goto put_dev;      }  if nfc_llcp_get_sdp_ssap failed, llcp_sock->service_name will be freed. That's really fixed.   new bug 1, refcount leak in llcp_sock_bind(): In the same function llcp_sock_bind(), nfc_llcp_local_get() is called before kmemdup.     llcp_sock->dev = dev;    llcp_sock->local = nfc_llcp_local_get(local);                     <---- nfc_llcp_local_get increases the refcount of local, adds plus 1    llcp_sock->nfc_protocol = llcp_addr.nfc_protocol;    llcp_sock->service_name_len = min_t(unsigned int,                        llcp_addr.service_name_len,                        NFC_LLCP_MAX_SERVICE_NAME);    llcp_sock->service_name = kmemdup(llcp_addr.service_name,                      llcp_sock->service_name_len,                      GFP_KERNEL);    if (!llcp_sock->service_name) {        ret = -ENOMEM;        goto put_dev;    }    llcp_sock->ssap = nfc_llcp_get_sdp_ssap(local, llcp_sock);    if (llcp_sock->ssap == LLCP_SAP_MAX) {        kfree(llcp_sock->service_name);                               <---- if nfc_llcp_get_sdp_ssap returns LLCP_SAP_MAX, only llcp_sock->service_name gets be freed.        llcp_sock->service_name = NULL;                               <---- nothing is done to local.        ret = -EADDRINUSE;        goto put_dev;    } .............................. put_dev:                                                             <---- nothing is done to local in put_dev label either.     nfc_put_device(dev);  error:     release_sock(sk);     return ret;                                                      <---- the refcount of local remains added.   from the analysis above, we can see that: if nfc_llcp_get_sdp_ssap returns LLCP_SAP_MAX, when llcp_sock_bind() is returned, sk->sk_state is still LLCP_CLOSED. So we can call llcp_sock_bind() many times, keep the refcount of local increasing.  Threre is a REFCOUNT_CHECK_LT_ZERO in refcount_inc. When the refcount of local gets to if the system handles the refcount exception, it leads to a system panic. If not, it will get to 0xFFFFFFFF and then to 0, then to 1... if nfc_llcp_local_put is called, the local will be freed. that is a worse UAF bug which might lead to privilege escalations.  Here is the test code:  #include <unistd.h> #include <string.h> #include <sys/socket.h> #include <linux/nfc.h>  #define NFC_SOCKPROTO_LLCP  1 #define NFC_PROTO_NFC_DEP   5  int main() {     unsigned int i;     int fd;     struct sockaddr_nfc_llcp addr;      fd = socket( AF_NFC, SOCK_STREAM, NFC_SOCKPROTO_LLCP );     if ( fd < 0 )         return 0;      memset( &addr, 0, sizeof(struct sockaddr_nfc_llcp) );     addr.sa_family = AF_NFC;     addr.dev_idx = 0;     addr.nfc_protocol = NFC_PROTO_NFC_DEP;     addr.service_name_len = 0;      for ( i = 0; i < i++ )     {         bind( fd, (struct sockaddr*) &addr, sizeof(struct sockaddr_nfc_llcp) );     }      close( fd );     return 0; }  new bug 2, refcount leak in llcp_sock_connect(): it is the same bug as the one described above.    llcp_sock->dev = dev;    llcp_sock->local = nfc_llcp_local_get(local);                     <---- nfc_llcp_local_get increases the refcount of local, adds plus 1    llcp_sock->ssap = nfc_llcp_get_local_ssap(local);    if (llcp_sock->ssap == LLCP_SAP_MAX) {                            <---- if nfc_llcp_get_local_ssap returns LLCP_SAP_MAX        ret = -ENOMEM;        goto put_dev;    } .............................. put_dev:                                                             <---- nothing is done to local in put_dev label.     nfc_put_device(dev);  error:     release_sock(sk);     return ret;                                                      <---- the refcount of local remains added.   new bug 3, memory leak in llcp_sock_connect():  it is the same bug as the fixed one in llcp_sock_bind()         llcp_sock->service_name = kmemdup(addr->service_name,                          llcp_sock->service_name_len,                          GFP_KERNEL);                                <---- kmemdup allocates memory for llcp_sock->service_name        if (!llcp_sock->service_name) {            ret = -ENOMEM;            goto sock_llcp_release;        }            nfc_llcp_sock_link(&local->connecting_sockets, sk);            ret = nfc_llcp_send_connect(llcp_sock);        if (ret)            goto sock_unlink;                                         <---- if nfc_llcp_send_connect is failed, llcp_sock->service_name is not freed. ............................................    sock_unlink:                                                      <---- llcp_sock->service_name is not freed in the next.        nfc_llcp_sock_unlink(&local->connecting_sockets, sk);        sock_llcp_release:        nfc_llcp_put_ssap(local, llcp_sock->ssap);        put_dev:        nfc_put_device(dev);        error:        release_sock(sk);        return ret;                                                   <---- sk->sk_state is not LLCP_CONNECTED. we can call llcp_sock_connect() many times.   new bug 4, non-blocking socket in llcp_sock_connect():      nfc_llcp_sock_link(&local->connecting_sockets, sk);               <---- sk is linked to local->connecting_sockets    ret = nfc_llcp_send_connect(llcp_sock);    if (ret)        goto sock_unlink;    sk->sk_state = LLCP_CONNECTING;    ret = sock_wait_state(sk, LLCP_CONNECTED,                  sock_sndtimeo(sk, flags & O_NONBLOCK));             <---- calling ioctl(fd, FIONBIO, &imode) before connect will make the socket flag get O_NONBLOCK mask.    if (ret && ret != -EINPROGRESS)                                   <---- sock_wait_state returns -EINPROGRESS right away        goto sock_unlink;    release_sock(sk);    return ret;                                                       <---- llcp_sock_connect() returns right away  if we set llcp_sock->service_name to meaningless string, the connect will be failed. and sk->sk_state will not be LLCP_CONNECTED. then we can call llcp_sock_connect() many times. that leaks everything: llcp_sock->dev, llcp_sock->local, llcp_sock->ssap, llcp_sock->service_name... leak is one problem. another problem is that we can call llcp_sock_connect() twice before nfc target response. nfc_llcp_sock_link() will add sk to local->connecting_sockets twice. sk->sk_node->next will point to itself, that will make an endless loop and hang-up the system.  Regards, kiyin.  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      