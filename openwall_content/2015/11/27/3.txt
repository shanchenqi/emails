  oss-security - Re: CVE request: Linux kernel, information disclosure after file truncate on BTRFS            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [<thread-prev] [day] [month] [year] [list]  Date: Fri, 27 Nov (EST) From: cve-assign@...re.org To: jsegitz@...e.com Cc: cve-assign@...re.org, oss-security@...ts.openwall.com Subject: Re: CVE request: Linux kernel, information disclosure after file truncate on BTRFS  -----BEGIN PGP SIGNED MESSAGE----- Hash:  >  Use for the vulnerability with the impact of "User B now gets to see the bytes that user A truncated from its file before it made its file world readable" (aka "being able to read old and stale data from foo that should not be possible to read anymore through normal filesystem operations" -- these are the 0x2a byte values).  We also have the following four types of comments. As far as we know, only the first comment can affect the number of CVE IDs.  (first comment)  "We were also not correctly decrementing the number of bytes used by the inode, we were setting it to zero, giving a wrong report for callers of the stat(2) syscall" seems to be an entirely different type of problem, and the attacker role is different (i.e., the attacker is the user who does the truncating, not the user who does the cloning). Also, this problem could have been fixed independently. It seems that the ability of an unprivileged user to trigger incorrect data from the stat syscall can be considered a vulnerability, at least if the data can be arbitrarily incorrect. For example, in some applications, the size of a single file is critically important (e.g., a user is not allowed to have a file larger than 5 Gb because the application later directly operates on the file as a Swift object), and it's realistic to expect that privileged code sometimes uses the stat syscall to enforce this. Are there any special factors related to compressed inline extents that would cause this stat issue never to be realistically exploitable? Otherwise, we would like to assign a second CVE ID for the ability of a user to falsify stat data by truncating a file.  (other comments)  We don't think that "User B also lost the bytes in the range bytes from its own file" is necessarily a critical impact. User B intentionally chose "length argument of 0, clone the whole range" and could have instead chosen a specific length that was known to be safe. (At least in some scenarios, "clone the whole range" is dangerous if there's an application with a race condition in which User A could have made the file larger after User B observed how large the whole range was.)  We didn't understand "our file bar got the whole inline extent copied from foo." It seems that bar got a total of bytes from foo, not the whole bytes. As far as we could tell, bytes through of foo remained private after the attack.  In general, giving one example in which everything is a multiple of followed by a mostly analogous example in which everything is a multiple of might not be useful for clarifying a vulnerability.  - --  CVE assignment team, MITRE CVE Numbering Authority M/S Burlington Road, Bedford, MA USA [ PGP key available through http://cve.mitre.org/cve/request_id.html ] -----BEGIN PGP SIGNATURE----- Version: GnuPG v1  =3ftC -----END PGP SIGNATURE-----  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      