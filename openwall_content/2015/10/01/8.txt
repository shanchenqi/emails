  oss-security - CVE Request: Unauthorized access to IPC objects with SysV shm            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [thread-next>] [day] [month] [year] [list]  Date: Thu, 1 Oct From: Julien Tinnes <julien@....org> To: oss-security@...ts.openwall.com Cc: keescook@...omium.org Subject: CVE Request: Unauthorized access to IPC objects with SysV shm  While working on KernelThreadSanitizer (KTSAN), a data race detector for kernels, Dmitry Vyukov found a data race that can trick the kernel into using unitialized memory.  - This can at least give access to arbitrary SysV shared memory and Dmitry developed a proof of concept exploit for this. (On many systems, this can be used to escalate privileges).  - While we didn't investigate this deeply, it is almost certain that this vulnerability can be used to gain arbitrary code execution in the kernel. Exercise left to the reader.  This vulnerability has been fixed upstream by Linus with this commit:  >From Dmitry Vyukov:  -----------  While working on KernelThreadSanitizer (KTSAN), a data race detector for kernel, I've got a report that says that ipc_addid() installs a not-completely initialized object into the shared object table. In particular, uid/gid are not initialized. ipc_obtain_object_check() in turn obtains the object and verifies uid/gid for permission purposes. Since the fields are not initialized, the check can falsely succeed.  Below are details including a proof-of-concept exploit.  Here is the race report on 4.2 kernel:  ThreadSanitizer: data-race in ipc_obtain_object_check  Read at of size 8 by thread on CPU 5:   [<     inline     >] msq_obtain_object_check ipc/msg.c:90   [<     inline     >] SYSC_msgctl    Previous write at of size 8 by thread on CPU 4:    [<     inline     >] ipcget_public   [<     inline     >] SYSC_msgget    Mutexes locked by thread Mutex is locked here:  kernel/locking/rwsem.c:62  [<     inline     >] ipcget_public   [<     inline     >] SYSC_msgget    Mutex is locked here:  [<     inline     >] __raw_spin_lock   [<     inline     >] spin_lock    [<     inline     >] ipcget_public   [<     inline     >] SYSC_msgget     What happens is as follows. ipc_addid installs new ipc object with idr_alloc, from this point on it is accessible to other threads. At this point the object contains unitialized garbage. Then it fills in uid, etc:  new->cuid = new->uid = euid; new->gid = new->cgid = egid; new->seq = ids->seq++;  While this happens another thread can get access to the object and do uid check on the unitialized garbage, which can give falsely give accesses to the shared object to a process that should not have access to the object.   -----------  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      