  oss-security - Qualys Security Advisory - LibreSSL and            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [thread-next>] [day] [month] [year] [list]  Date: Thu, 15 Oct From: Qualys Security Advisory <qsa@...lys.com> To: oss-security@...ts.openwall.com Subject: Qualys Security Advisory - LibreSSL and   Qualys Security Advisory  LibreSSL and   ======================================================================== Contents ========================================================================  Summary Memory Leak Buffer Overflow Acknowledgments   ======================================================================== Summary ========================================================================  In order to achieve remote code execution against the vulnerabilities that we recently discovered in OpenSMTPD a memory leak is needed. Because we could not find one in OpenSMTPD itself, we started to review the malloc()s and free()s of its libraries, and eventually found a memory leak in LibreSSL's OBJ_obj2txt() function; we then realized that this function also contains a buffer overflow (an off-by-one, usually stack-based).  The vulnerable function OBJ_obj2txt() is reachable through and which is called automatically to decode the certificates exchanged during an SSL handshake (both client-side, unless an anonymous mode is used, and server-side, if client authentication is requested).  These vulnerabilities affect all LibreSSL versions, including LibreSSL (the first public release) and LibreSSL (the latest release at the time of writing). OpenSSL is not affected.   ======================================================================== Memory Leak ========================================================================  OBJ_obj2txt() converts an ASN.1 object identifier (the ASN1_OBJECT a) into a null-terminated string of numerical subidentifiers separated by dots (at most buf_len bytes are written to buf).  Large subidentifiers are temporarily stored in a BIGNUM (bl) and converted by BN_bn2dec() into a printable string of decimal characters (bndec). Many such bndec strings can be malloc()ated and memory-leaked in a loop, because only the last one will be free()d, after the end of the loop:  int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name) { ...         char *bndec = NULL; ...         len = a->length; ...         while (len > 0) { ...                         bndec = BN_bn2dec(bl);                         if (!bndec)                                 goto err;                         i = snprintf(buf, buf_len, ".%s", bndec); ...         } ...         free(bndec); ... }  This memory leak allows remote attackers to cause a denial of service (memory exhaustion) or trigger the buffer overflow described below.   ======================================================================== Buffer Overflow ========================================================================  As a result of OBJ_obj2txt() was modified to "Ensure that, at every state, |buf| is NUL-terminated." However, in LibreSSL, the error-handling code at the end of the function may write this null-terminator out-of-bounds:  int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name) { ...         len = a->length;         p = a->data;         while (len > 0) { ...                 for (;;) {                         unsigned char c = *p++;                         len--;                         if ((len == 0) && (c &                                 goto err; ...                                 if (!BN_add_word(bl, c & 0x7f))                                         goto err; ...                                 if (!bl && !(bl = BN_new()))                                         goto err;                                 if (!BN_set_word(bl, l))                                         goto err; ...                                 if (!BN_lshift(bl, bl, 7))                                         goto err; ...                 } ...                                         if (!BN_sub_word(bl, 80))                                                 goto err; ...                         if (buf_len > 1) {                                 *buf++ = i + '0';                                 *buf = '\0';                                 buf_len--;                         } ...                 if (use_bn) {                         bndec = BN_bn2dec(bl);                         if (!bndec)                                 goto err;                         i = snprintf(buf, buf_len, ".%s", bndec);                         if (i == -1)                                 goto err;                         if (i >= buf_len) {                                 buf += buf_len;                                 buf_len = 0;                         } else {                                 buf += i;                                 buf_len -= i;                         } ...                 } else {                         i = snprintf(buf, buf_len, ".%lu", l);                         if (i == -1)                                 goto err;                         if (i >= buf_len) {                                 buf += buf_len;                                 buf_len = 0;                         } else {                                 buf += i;                                 buf_len -= i;                         } ...                 }         } out: ...         return ret; err:         ret = 0;         buf[0] = '\0';         goto out; }  First, in order to trigger this off-by-one buffer overflow, buf must be increased until it points to the first out-of-bounds character (i.e., until buf_len becomes zero):  - on the one hand, this is impossible with the code blocks at lines   and  - on the other hand, this is very easy with the code blocks at lines   and (the destination buffer is usually quite small;   for example, it is only 80 bytes long in  Second, the code must branch to the err label:  - the "goto err"s at lines and are unreachable, because   snprintf() cannot possibly return -1 here;  - the "goto err" at lines is:    . very easy to reach in LibreSSL <=    . impossible to reach in LibreSSL >= because of the "MSB must     be clear in the last octet" sanity check that was added to     c2i_ASN1_OBJECT():          /*          * Sanity check OID encoding:          * - need at least one content octet          * - MSB must be clear in the last octet          * - can't have leading in subidentifiers, see:          */         if (len <= 0 || len > INT_MAX || pp == NULL || (p = *pp) == NULL ||             p[len - 1] & {                 ASN1_R_INVALID_OBJECT_ENCODING);                 return (NULL);         }  - the remaining "goto err"s are triggered by error conditions in various   BIGNUM functions:    . either because of a very large BIGNUM (approximately 64 megabytes,     which is impossible in the context of an SSL handshake, where     certificates are limited to kilobytes);    . or because of an out-of-memory condition (which can be reached     through the memory leak described above).  This off-by-one buffer overflow allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code. However, when triggered through (and therefore this buffer overflow is stack-based and probably not exploitable on OpenBSD x86, where it appears to always smash the stack canary.   ======================================================================== Acknowledgments ========================================================================  We would like to thank the LibreSSL team for their great work and their incredibly quick response, and Red Hat Product Security for promptly assigning CVE-IDs to these issues.   Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      