  oss-security - Re: Heap overflow and DoS in unzip 6.0            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [<thread-prev] [thread-next>] [day] [month] [year] [list]  Date: Mon, 21 Sep From: Stefan Cornelius <scorneli@...hat.com> To: oss-security@...ts.openwall.com Subject: Re: Heap overflow and DoS in unzip 6.0  On Tue, 15 Sep Gustavo Grieco <gustavo.grieco@...il.com> wrote: > AFAIK, upstream is still working on the heap overflow issue (the DoS > is fixed in the last unzip beta). In concrete, they said: >  > "My initial (quick) analysis suggested that the basic problem is > corrupt (unrealistic) Extra-Field sizes, which UnZip does not check > well enough. I need to verify that that is the cause, and then figure > out what to do about it. Currently, if the program sees an Extra-Field > length of, say, it tends to believe it, even if that's bigger > than the actual archive member's length (or perhaps even bigger than > the whole archive). If it actually tries to read data which haven't > been read, then valgrind gets upset (with good reason). At least > that's what I believe so far." >  I've tried to contact upstream via the contact form to share my analysis. So far, I've had no response, so I'll share it here:  I believe the root cause for this issue is in extract.c around line """         if (G.lrec.compression_method == STORED) {             zusz_t csiz_decrypted = G.lrec.csize;              if (G.pInfo->encrypted)                 csiz_decrypted -= 12; ##### BOOOOM              if (G.lrec.ucsize != csiz_decrypted) {                 Info(slide, ((char *)slide,                   LoadFarStringSmall2(WrnStorUCSizCSizDiff),                   FnFilter1(G.filename),                   FmZofft(G.lrec.ucsize, NULL, "u"),  So there can be an integer overflow if csiz_decrypted is smaller than 12: if (G.pInfo->encrypted)                 csiz_decrypted -= 12; """  Did anyone come to a similar conclusion? Also, the subsequent unzip processing after this underflow exposed a lot of other places where additional hardening may be a very good idea. Is somebody working on that?  Thanks, --  Stefan Cornelius / Red Hat Product Security  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      