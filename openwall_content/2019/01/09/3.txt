  oss-security - System Down: A systemd-journald exploit            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [thread-next>] [day] [month] [year] [list]  Date: Wed, 9 Jan From: Qualys Security Advisory <qsa@...lys.com> To: oss-security@...ts.openwall.com Subject: System Down: A systemd-journald exploit   Qualys Security Advisory  System Down: A systemd-journald exploit   ======================================================================== Contents ========================================================================  Summary - Analysis - Exploitation - Analysis - Exploitation - Analysis - Exploitation Combined Exploitation of and - amd64 Exploitation - Exploitation Acknowledgments Timeline      Conversion, software version 7.0         -- System of a Down, "Toxicity"   ======================================================================== Summary ========================================================================  We discovered three vulnerabilities in systemd-journald (https://en.wikipedia.org/wiki/Systemd):  - and two memory corruptions   (attacker-controlled alloca()s);  - an information leak (an out-of-bounds read).  was introduced in April (systemd and became exploitable in February (systemd We developed a proof of concept for that gains eip control on  was introduced in December (systemd v38) and became exploitable in April (systemd was introduced in June (systemd and was inadvertently fixed in August  We developed an exploit for and that obtains a local root shell in 10 minutes on and 70 minutes on amd64, on average. We will publish our exploit in the near future.  To the best of our knowledge, all systemd-based Linux distributions are vulnerable, but SUSE Linux Enterprise 15, openSUSE Leap and Fedora 28 and 29 are not exploitable because their user space is compiled with GCC's -fstack-clash-protection.  This confirms https://grsecurity.net/an_ancient_kernel_hole_is_not_closed.php: "It should be clear that kernel-only attempts to solve [the Stack Clash] will necessarily always be incomplete, as the real issue lies in the lack of stack probing."   ======================================================================== ========================================================================  ------------------------------------------------------------------------ Analysis ------------------------------------------------------------------------      The waves all keep on crashing by         -- System of a Down, "Suggestions"  We accidentally discovered while working on the exploit for Mutagen Astronomy if we pass several megabytes of command-line arguments to a program that calls syslog(), then journald crashes:  segfault at ip sp error 6 in  (gdb) disassemble - Dump of assembler code for function    ...      callq  <get_process_cmdline.constprop.96>      test   %eax,%eax      js     0xb8ea     mov        test   %rbx,%rbx     je         mov    %rbx,%rdi     callq  <strlen@plt>     add    $0xa,%eax     cltq     add    $0x1e,%rax     and    $0xfffffffffffffff0,%rax     sub    %rax,%rsp     movabs     lea        and        test   %rbx,%rbx     mov    %rax,(%r15)     mov    $0x3d,%eax     mov        lea        je         mov    %rbx,%rsi     mov    %rax,%rdi     callq  <stpcpy@plt>  static void dispatch_message_real( ...                 r = get_process_cmdline(ucred->pid, 0, false, &t);                 if (r >= 0) {                         x = strjoina("_CMDLINE=", t);  #define strjoina(a, ...)                                                \         ({                                                              \                 const char *_appendees_[] = { a, __VA_ARGS__ };         \                 char *_d_, *_p_;                                        \                 int _len_ = 0;                                          \                 unsigned _i_;                                           \                 for (_i_ = 0; _i_ < ELEMENTSOF(_appendees_) && _appendees_[_i_]; _i_++) \                         _len_ += strlen(_appendees_[_i_]);              \                 _p_ = _d_ = alloca(_len_ + 1);                          \                 for (_i_ = 0; _i_ < ELEMENTSOF(_appendees_) && _appendees_[_i_]; _i_++) \                         _p_ = stpcpy(_p_, _appendees_[_i_]);            \                 *_p_ = 0;                                               \                 _d_;                                                    \         })  This vulnerability, an attacker-controlled alloca() (https://wiki.sei.cmu.edu/confluence/display/c/MEM05-C.+Avoid+large+stack+allocations) at instruction and line was introduced in systemd  commit Date:   Mon Apr 22 ...                  r = get_process_cmdline(ucred->pid, 0, false, &t);                  if (r >= 0) { -                        cmdline = strappend("_CMDLINE=", t); +                        cmdline = strappenda("_CMDLINE=", t);  (strappenda() was renamed strjoina() in systemd and became exploitable in systemd  commit Date:   Fri Feb 12 ...     This adds a wait flag to journal_file_set_offline(), when false the offline is     performed asynchronously in a separate thread.  ------------------------------------------------------------------------ Exploitation ------------------------------------------------------------------------      ... it's the race     Can you break out?         -- System of a Down, "36"  is similar to a Stack Clash vulnerability but:  - Steps 1 (Clash the stack with another memory region) and 2 (Run the   stack pointer to the start of the stack) are not needed, because the   attacker-controlled alloca() can be very large (several megabytes of   command-line arguments); only Steps 3 (Jump over the stack guard page,   into another memory region) and 4 (Smash the stack, or another memory   region) are needed.  - In Step 4 (Smash), the alloca() is fully written to (the vulnerability   is essentially a stpcpy(alloca(strlen(cmdline) + 1), cmdline)), and   the stpcpy() (a "wild copy") will therefore always crash into a   read-only or unmapped memory region:       We tried to asynchronously interrupt this stpcpy() before it crashes, with a signal or a timer, but we failed because journald uses signalfd() and timerfd_create() to handle these events synchronously.  We eventually gained control of eip instruction pointer) by jumping into and smashing the stack of a concurrent thread (a "Parallel Thread Corruption"):  - First, we send a large, high-priority message (LOG_CRIT or higher) to   journald, from a process whose cmdline is small; this message forces a   large write() (between 1MB and 2MB) to /var/log/journal/ and forces   the creation of a short-lived thread that fsync()s the journal (the   stack of this thread is allocated in the mmap region).  - Next, we create several processes (between 32 and 64) that write() and   fsync() large files (between 1MB and 8MB) to /var/tmp/ (for example);   these processes stall journald's fsync() thread and will allow us to   win a tight race: exploit the "wild copy" before it crashes.  - Last, we send a small, low-priority message to journald, from a   process whose cmdline is very large (roughly the distance   between the main stack and the mmap region); this message forces a   very large alloca() that jumps from journald's main stack into the   stack of the fsync() thread, and smashes a saved eip before fsync()   returns from kernel space.  On a Debian stable (9.5), our proof of concept wins this race and gains eip control after a dozen tries (systemd automatically restarts journald after each crash):  segfault at ip sp error 14  Despite this initial success, we abandoned the exploitation of while working on our proof of concept, we discovered two different vulnerabilities another attacker-controlled alloca(), and an information leak) that are reliably exploitable on both and amd64.   ======================================================================== ========================================================================  ------------------------------------------------------------------------ Analysis ------------------------------------------------------------------------      Can you feel their haunting presence?         -- System of a Down, "Holy Mountains"  Surprised by the heavy usage of alloca() in journald, we searched for another attacker-controlled alloca() and found  int journal_file_append_entry(JournalFile *f, const dual_timestamp *ts, const struct iovec iovec[], unsigned n_iovec, uint64_t *seqnum, Object **ret, uint64_t *offset) { ....         items = alloca(sizeof(EntryItem) * MAX(1u, n_iovec));         for (i = 0; i < n_iovec; i++) {                 uint64_t p;                 Object *o;                 r = journal_file_append_data(f, iovec[i].iov_base, iovec[i].iov_len, &o, &p);                 if (r < 0)                         return r;                 xor_hash ^= le64toh(o->data.hash);                 items[i].object_offset = htole64(p);                 items[i].hash = o->data.hash;         }  This vulnerability was introduced in systemd v38:  commit Date:   Thu Dec 29 ... -        items = new(EntryItem, n_iovec); -        if (!items) -                return -ENOMEM; +        items = alloca(sizeof(EntryItem) * n_iovec);  and became exploitable in systemd  commit Date:   Mon Apr 8 ... -#define ENTRY_SIZE_MAX -#define DATA_SIZE_MAX ... +#define ENTRY_SIZE_MAX +#define DATA_SIZE_MAX  If we send a large "native" message to /run/systemd/journal/socket: since the maximum size of a "native" entry is and the minimum length of a "native" item is 3 ("A=\n"), and the size of an EntryItem structure is 16 (a 64-bit offset and a 64-bit hash), the maximum size of the attacker-controlled alloca() in journal_file_append_entry() is / 3 * 16 = 4GB, large enough to jump from journald's main stack into the mmap region, even on amd64.  On amd64, as described in the "64-bit exploitation" of our Stack Clash advisory, the randomized distance between the main stack and the mmap region is shorter than 4GB with a probability of (approximately):  SUM(d = 0; d < 4GB; d++) d / (16GB * 1TB) ~= 1 /  ------------------------------------------------------------------------ Exploitation ------------------------------------------------------------------------      Jump (pogo, pogo, pogo, pogo, pogo, pogo, pogo)         -- System of a Down, "Bounce"  is basically a simplified Stack Clash vulnerability:  - Steps 1 (Clash) and 2 (Run) of the Stack Clash are not needed, since   the largest attacker-controlled alloca() is 4GB; only Steps 3 (Jump)   and 4 (Smash) are needed.  - In Step 4 (Smash), the alloca() is not necessarily fully written to:   if the size of an item is larger than (DEFAULT_MAX_SIZE_UPPER),   then journal_file_append_data() returns an error that breaks the "for"   loop in journal_file_append_entry() (at lines and avoids a   crash into a read-only or unmapped memory region.  We eventually transformed this vulnerability into a crude "write-what-where"  - "write-where": We jump into and smash libc's read-write segment, and   thereby overwrite a function pointer. Unfortunately this "write-where"   is not surgical: the stack frames of the functions called from within   the "for" loop (in journal_file_append_entry()) smash a few kilobytes   below our target function pointer, and therefore overwrite vital libc   variables that may crash or deadlock journald. Consequently, we must   sometimes shift our alloca() jump slightly, to avoid overwriting such   vital variables.  - "write-what": We want to overwrite our target function pointer with   the address of another function or ROP chain, but unfortunately the   stack frames of the functions called from within the "for" loop (in   journal_file_append_entry()) do not contain any data that we control.   However, the 64-bit "hash" values that are written to the alloca()ted   "items" are produced by jenkins_hashlittle2(), a noncryptographic hash   function: we can easily find a short string (a preimage) that hashes   to a given value (the address that will overwrite our target function   pointer) and is also a valid_user_field() (or journal_field_valid()).    This "write-what" restricts our "write-where" to function pointers   whose address modulo 16 is equal to 8 (the offset of "hash" in the   EntryItem structure).  To complete our exploit, we need the address of journald's stack pointer before the alloca() jump, and the address of our target function pointer in libc's read-write segment -- we need an information leak.   ======================================================================== ========================================================================  ------------------------------------------------------------------------ Analysis ------------------------------------------------------------------------      When they speak, we can peek from the windows of their mouths         -- System of a Down, "Know"  We discovered an out-of-bounds read in journald and transformed it into an information leak:   31 #define WHITESPACE        " \t\n\r" ... size_t syslog_parse_identifier(const char **buf, char **identifier, char **pid) {         const char *p; ...         size_t l, e; ...         p = *buf;         p += strspn(p, WHITESPACE);         l = strcspn(p, WHITESPACE);         if (l <= 0 ||             p[l-1] != ':')                 return 0;         e = l; ...         if (strchr(WHITESPACE, p[e]))                 e++;         *buf = p + e;         return e; }  If we send a syslog message to journald (in *buf), and if the last character of this message is a ':' (before the '\0' terminator), then:  - at line p[e] is the '\0' terminator of our message;  - at line strchr(WHITESPACE, p[e]) returns a pointer to the '\0'   terminator of the WHITESPACE string (as mentioned in man strchr: "The   terminating null byte is considered part of the string, so that if c   is specified as '\0', these functions return a pointer to the   terminator.");  - at line e is incremented;  - at line *buf points out-of-bounds, to the first character after   the '\0' terminator of our message;  - later, the out-of-bounds string at *buf (supposedly the body of our   syslog message) is written (leaked) to the journal.  Consequently, we can read this out-of-bounds string:  - either directly from the journal (if journald's "Storage" is   "persistent", or "auto" and /var/log/journal/ exists), because   journald supports extended file ACLs (Access Control Lists):    $ id      $ ls -l /var/log/journal/*/user-$UID.journal   -rw-r-----+ 1 root systemd-journal Nov 20    $ getfacl /var/log/journal/*/user-$UID.journal   ...   user:john:r--    $ ./infoleak    $ journalctl --all --user --lines=1 --identifier=infoleak | hexdump -C   ...    2e 20 2d 2d 0a 4e 6f 76  20 32 30 20 31 36 3a 30  |. --.Nov 20    30 3a 33 36 20 6c 6f 63  61 6c 68 6f 73 74 2e 6c  localhost.l|    6f 63 61 6c 64 6f 6d 61  69 6e 20 69 6e 66 6f 6c  |ocaldomain infol|    65 61 6b 5b 33 35 34 38  5d 3a 20 78 fb 1e 78 54  x..xT|    7f 0a                                             |..|  - or (if journald's "Storage" is "volatile", or "auto" and   /var/log/journal/ does not exist) from a tty that we recorded to   /var/run/utmp, because journald writes ("walls") emergency messages   (LOG_EMERG) to the tty of every logged-in user; our exploit records a   tty to /var/run/utmp via an ssh connection to localhost, but other   methods exist (for example, utempter and gnome-pty-helper):    $ ./infoleak   ...    0a 07 0d 0d 0a 42 72 6f  61 64 63 61 73 74 20 6d  |.....Broadcast m|    65 73 73 61 67 65 20 66  72 6f 6d 20 73 79 73 74  |essage from syst|    65 6d 64 2d 6a 6f 75 72  6e 61 6c 64 40 6c 6f 63  |emd-journald@...|    61 6c 68 6f 73 74 2e 6c  6f 63 61 6c 64 6f 6d 61  |alhost.localdoma|    69 6e 20 28 54 75 65 20  32 30 31 38 2d 31 31 2d  |in (Tue    32 30 20 31 36 3a 32 35  3a 34 36 20 43 53 54 29  |20 CST)|    3a 0d 0d 0a 0d 0d 0a 69  6e 66 6f 6c 65 61 6b 5b  |:......infoleak[|    33 38 37 32 5d 3a 20 78  6b a2 e1 2f 7f 0d 0d 0a  xk../....|  This vulnerability was introduced in systemd  commit Date:   Wed Jun 10 ... -        e += strspn(p + e, WHITESPACE); +        if (strchr(WHITESPACE, p[e])) +                e++;  and was inadvertently fixed in August  commit Date:   Wed Aug 8 ... -        if (strchr(WHITESPACE, p[e])) -                e++; +        e += strspn(p + e, WHITESPACE);  commit Date:   Fri Aug 10 ... -        e += strspn(p + e, WHITESPACE); +        /* Single space is used as separator */ +        if (p[e] != '\0' && strchr(WHITESPACE, p[e])) +                e++;  ------------------------------------------------------------------------ Exploitation ------------------------------------------------------------------------      For today we will take the body parts and put them on the wall         -- System of a Down, "Dreaming"  To leak a stack address or an mmap address from journald:  - First, we send a large native message to /run/systemd/journal/socket;   journald mmap()s our message, and malloc()ates a large array of iovec   structures: most of these structures point into our mmap()ed message,   but some of them point to the stack (in dispatch_message_real()). The   contents of this iovec array (especially the mmap and stack pointers)   are preserved in a heap hole after free() (after journald finishes   processing our message).  - Next, we send a large syslog message to /run/systemd/journal/dev-log;   to receive our large message (in server_process_datagram()), journald   realloc()ates its server buffer into the heap hole that previously   contained the iovec array (and still contains remains of mmap and   stack pointers).  - Last, we send a large syslog message that exploits   journald receives our large message in its server buffer (in the heap   chunk that previously contained the iovec array), and if we carefully   choose the size of our message and position its terminating ":" in   front of a remaining mmap or stack pointer, then we can leak this   pointer (it is mistakenly read out-of-bounds as the body of our   message).  >From this leaked stack pointer we easily deduce journald's stack pointer before the alloca() jump, because the distance between the two depends only on journald's executable.  >From the leaked mmap address we can deduce libc's address, but chunks of unknown sizes are mmap()ed between the two, and we must therefore adopt different strategies based on our target architecture or amd64).   ======================================================================== Combined Exploitation of and ========================================================================      Don't leave your seats now     Popcorn everywhere ...         -- System of a Down, "CUBErt"  ------------------------------------------------------------------------ amd64 Exploitation ------------------------------------------------------------------------  - To deduce libc's address from the leaked mmap address of our native   message, we arrange for this message to be mmap()ed into the 2MB hole   between ld.so's read-execute and read-only segments: from this hole's   address we deduce ld.so's address, and hence libc's address (with help   from ldd's output).  - If the resulting stack-to-libc distance is jumpable (if it is shorter   than 4GB), then we proceed with our "write-what-where"; otherwise, we   restart journald (we crash it with an alloca() of RLIMIT_STACK -- 8MB   by default) and try again.    We have a good chance of obtaining a jumpable stack-to-libc distance   (and hence a root shell) after tries * 2 seconds ~= 68 minutes   (by default, if journald crashes less than 5 times within 10 seconds,   it is restarted automatically by systemd).  - For the "write-where" part of our "write-what-where", we overwrite   libc's __free_hook function pointer, whose address modulo 16 is always   equal to 8 (on every amd64 distribution that we exploited).  - For the "write-what" part of our "write-what-where", we overwrite   __free_hook with the address of libc's system() function: whenever   journald free()s data that we control, we achieve arbitrary command   execution.  Last-minute note: on CentOS 7, the usual function pointers in libc's read-write segment (__free_hook, __malloc_hook, etc) are not located at multiples of 16 plus 8. To circumvent this problem:  - First, we overwrite the "_chain" pointer of stderr's FILE structure   with the address of our own fake FILE structure (this "_chain" pointer   is located at a multiple of 16 plus 8, in libc's read-write segment).  - Next, we corrupt one of malloc's internal variables (also in libc's   read-write segment).  - Last, we force a call to malloc() or free(), which detects the   corruption of its internal variable and calls abort(), which calls   _IO_flush_all_lockp(), which follows stderr's overwritten "_chain"   pointer to our fake FILE structure; we eventually achieve arbitrary   command execution by calling libc's system() via one of the function   pointers in our fake FILE structure.  ------------------------------------------------------------------------ Exploitation ------------------------------------------------------------------------  Our exploit is very similar to the amd64 exploit, but:  - The stack-to-libc distance is always jumpable (it is roughly  - There is no hole between ld.so's read-execute and read-only segments.   However, libc's address is randomized in a narrow range of 1MB and is   therefore brute forcible: we have a good chance of correctly guessing   libc's address after 1MB / 4KB = tries * 2 seconds ~= 8 minutes.  - For the "write-where" part of our "write-what-where", we overwrite   libc's __malloc_hook function pointer (__free_hook was never located   at a multiple of 16 plus 8 or 12 on the distributions that we   exploited, but __malloc_hook always is).  - For the "write-what" part of our "write-what-where", we overwrite   __malloc_hook with the address of a "mov esp, ; ret" gadget   (or equivalent stack pivot): since our native message can be as large   as we can mmap() it at take control of the stack,   and return into libc's execve().   ======================================================================== Acknowledgments ========================================================================  We thank systemd's developers, Red Hat Product Security, and the members of linux-distros@...nwall.   ======================================================================== Timeline ========================================================================  Advisory sent to Red Hat Product Security (as recommended by https://github.com/systemd/systemd/blob/master/docs/CONTRIBUTING.md#security-vulnerability-reports).  Advisory and patches sent to linux-distros@...nwall.  Coordinated Release Date PM UTC).   Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      