  oss-security - systemd (PID1) crash with specially crafted D-Bus  message            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [thread-next>] [day] [month] [year] [list]  Date: Mon, 18 Feb From: Chris Coulson <chris.coulson@...onical.com> To: oss-security@...ts.openwall.com Subject: systemd (PID1) crash with specially crafted D-Bus  message  Hi,  I recently discovered a way for an unprivileged user to crash PID1 by sending it a specially crafted D-Bus message on the system bus and causing the stack pointer to jump the stack guard pages, leaving it pointing to an unmapped page.  Details of the issue follow:  ---- bus_process_object() in src/libsystemd/sd-bus/bus-objects.c allocates a buffer on the stack large enough to temporarily store the object path specified in the incoming message:          assert(m->path);         assert(m->member);          pl = strlen(m->path);         do { =>              char prefix[pl+1];                  bus->nodes_modified = false;                  r = object_find_and_run(bus, m, m->path, false, &found_object);  As the length of this is attacker controlled, it is possible for a malicious unprivileged local user to send a message which results in the stack pointer moving outside of the bounds of the currently mapped stack region, jumping over the stack guard pages.  According to the dbus specification, the path "may be of any length" (with the length being represented on the wire by a uint32), but systemd seems to limit the size of incoming messages to (BUS_MESSAGE_SIZE_MAX). From testing on Ubuntu it seems that the real limit is actually much less than this - dbus-daemon drops the connection when I try to send a message with an object path greater than about 32MB. The effect of this is that the stack pointer always lands in an unmapped page and it doesn't seem to be possible to make it land in another mapped page.  Running a simple script that sends a message with a long enough path to org.freedesktop.systemd1 on Ubuntu (systemd and CentOS 7.6 (systemd results in an easily reproducible crash (and subsequent kernel panic) on both x86 and with a stack trace that looks like this:  Program received signal SIGSEGV, Segmentation fault.                                                bus_process_object at ../src/libsystemd/sd-bus/bus-objects.c: No such file or directory.                                (gdb) bt #0  bus_process_object at #1  in process_message at #2  process_running (ret=0x0, priority=0, hint_priority=false, at #3  bus_process_internal hint_priority=hint_priority@...ry=false, priority=priority@...ry=0, ret=ret@...ry=0x0) at #4  in sd_bus_process ret=ret@...ry=0x0) at #5  in io_callback (s=<optimized out>, fd=<optimized out>, revents=<optimized out>, userdata=<optimized out>, s=<optimized out>, fd=<optimized out>, revents=<optimized out>, userdata=<optimized out>) at #6  in source_dispatch at #7  in sd_event_dispatch at #8  in sd_event_run at #9  in manager_loop at #10 invoke_main_loop ret_shutdown_verb=<optimized out>, at #11 in main (argc=<optimized out>, at  (gdb) p $_siginfo $1 = {si_signo = 11, si_errno = 0, si_code = 1, _sifields = {_pad = 0 <repeats 26 times>}, _kill = {si_pid = si_uid = _timer = {si_tid = si_overrun = si_sigval = {sival_int = 0, sival_ptr = 0x0}}, _rt = {si_pid = si_uid = si_sigval = {sival_int = 0, sival_ptr = 0x0}}, _sigchld = {si_pid = si_uid = si_status = 0, si_utime = 0, si_stime = 0}, _sigfault = {si_addr = _addr_lsb = 0, _addr_bnd = {_lower = 0x0, _upper = 0x0}}, _sigpoll = {si_band = si_fd = 0}}}  (gdb) disassemble Dump of assembler code for function bus_process_object: ......    mov    %r13,%rsi         mov    %r12,%rdi                               mov    %rsp,%rbx                             => callq  <object_find_and_run>  You can see that %rsp points to an unmapped page:  (gdb) info registers                                                                                   rax            rbx            rcx            0x0                0 rdx            rsi            rdi            rbp             rsp            r8             r9             0x1                 1 r10            0x1                 1 r11            r12            r13            r14            r15            rip            eflags         [ IF RF ] cs             51 ss             0x2b                43 ds             0x0                 0 es             0x0                 0 fs             0x0                 0 gs             0x0                 0  (gdb) info proc mappings process 1  Mapped address spaces:            Start Addr           End Addr       Size     Offset objfile ......             0x0       0x0 [stack]       0x0 [vvar]  Given the constraint that it doesn't appear to be possible to make the stack pointer land in another mapped page, this bug is classified as denial-of-service. ----  There are 3 patches required to resolve this, provided by Red Hat Product Security and attached to this message. The first patch enforces a sensible size limit on D-Bus object paths, dropping messages when the path is too long. The second patch removes usage of variable-size stack allocations for object paths. The third patch stops the system bus connection from being terminated when an invalid message is received.  I would like to thank Riccardo Schirone, Lennart Poettering and Red Hat Product Security for their help with this issue.  Regards, - Chris   View attachment of type "text/x-patch" bytes)  View attachment of type "text/x-patch" bytes)  View attachment of type "text/x-patch" bytes)  Download attachment "signature.asc" of type "application/pgp-signature" bytes)  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      