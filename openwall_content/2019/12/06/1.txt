  oss-security - openslp heap overflow vulnerability            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [thread-next>] [day] [month] [year] [list]  Date: Fri, 6 Dec From: VMware Security Response Center <security@...are.com> To: "oss-security@...ts.openwall.com" <oss-security@...ts.openwall.com> CC: VMware Security Response Center <security@...are.com> Subject: openslp heap overflow vulnerability  openslp has a heap overflow vulnerability that when exploited may result in memory corruption and a crash of slpd or in remote code execution.  has been assigned to this issue.  Below you may find: - a copy of the affected code with comments indicating the problem. - patches for openslp versions and  VMware would like to thank the team working with the Tianfu Cup Pwn Contest for reporting this issue to us.  VMware Security Response Center   ============================== CODE SNIPPET ============================  slpd_process.c  static int ProcessSrvRqst(SLPMessage * message, SLPBuffer * sendbuf,       int errorcode) {    ...    if (db && errorcode == 0)    {       for (i = 0; i < db->urlcount; i++)       {          /* urlentry is the url from the db result */          urlentry = db->urlarray[i];           size += urlentry->urllen + 6; /*  1 byte for reserved  *///<=======================================(1)here size plus urllen                                        /*  2 bytes for lifetime */                                        /*  2 bytes for urllen   */                                        /*  1 byte for authcount */ #ifdef ENABLE_SLPv2_SECURITY          /* make room to include the authblock that was asked for */          if (G_SlpdProperty.securityEnabled                && message->body.srvrqst.spistrlen)          {             for (j = 0; j < urlentry->authcount; j++)             {                if (SLPCompareString(urlentry->autharray[j].spistrlen,                      urlentry->autharray[j].spistr,                      message->body.srvrqst.spistrlen,                      message->body.srvrqst.spistr) == 0)                {                   authblock = &(urlentry->autharray[j]);                   size += authblock->length;                   break;                }             }          } #endif       }    }     /* reallocate the result buffer */    result = SLPBufferRealloc(result, size);//<======================================(2)here use size to malloc a buffer    if (result == 0)    {       errorcode = SLP_ERROR_INTERNAL_ERROR;       goto FINISHED;    }     /* add the header */     /* version */    *result->curpos++ = 2;     /* function id */    *result->curpos++ = SLP_FUNCT_SRVRPLY;     /* length */    PutUINT24(&result->curpos, size);     /* flags */    PutUINT16(&result->curpos, (size > (size_t)G_SlpdProperty.MTU?          SLP_FLAG_OVERFLOW: 0));     /* ext offset */    PutUINT24(&result->curpos, 0);     /* xid */    PutUINT16(&result->curpos, message->header.xid);     /* lang tag len */    PutUINT16(&result->curpos, message->header.langtaglen);     /* lang tag */    memcpy(result->curpos, message->header.langtag,          message->header.langtaglen);    result->curpos += message->header.langtaglen;     /* add rest of the SrvRply */     /* error code*/    PutUINT16(&result->curpos, errorcode);    if (db && errorcode == 0)    {       /* urlentry count */       PutUINT16(&result->curpos, db->urlcount);       for (i = 0; i < db->urlcount; i++)       {          /* urlentry is the url from the db result */          urlentry = db->urlarray[i];  #ifdef ENABLE_SLPv1          if (urlentry->opaque == 0)          {             /* url-entry reserved */             *result->curpos++ = 0;              /* url-entry lifetime */             PutUINT16(&result->curpos, urlentry->lifetime);              /* url-entry urllen */             PutUINT16(&result->curpos, urlentry->urllen);              /* url-entry url */             memcpy(result->curpos, urlentry->url, urlentry->urllen);             result->curpos += urlentry->urllen;              /* url-entry auths */             *result->curpos++ = 0;          }          else #endif          {             /* Use an opaque copy if available (and authentication is              * not being used).              */              /* TRICKY: Fix up the lifetime. */             TO_UINT16(urlentry->opaque + 1, urlentry->lifetime);             memcpy(result->curpos, urlentry->opaque, urlentry->opaquelen);//<==================================(3)opaquelen could be bigger than urllen,lead to heap overflow             result->curpos += urlentry->opaquelen;          }       }    }    else       PutUINT16(&result->curpos, 0); /* set urlentry count to 0*/  FINISHED:     if (db)       SLPDDatabaseSrvRqstEnd(db);     *sendbuf = result;     return errorcode; }       ============================== /CODE SNIPPET ============================   ============================== PATCH FOR OPENSLP ============================  diff -ur --- +++ @@ @@  /*                                                                         */  /***************************************************************************/   +/* Copyright (c) VMware, Inc. + * SPDX-License-Identifier: BSD-3-Clause + * This file is provided under the BSD-3-Clause license. + * See COPYING file for more details and other copyrights + * that may apply. + */    #include "slp_buffer.h"   #include "slp_xmalloc.h" @@ @@      return result;  }   +/*=========================================================================*/ +size_t RemainingBufferSpace(SLPBuffer buf) +/* Report remaining free buffer size in bytes.                             */ +/*                                                                         */ +/* Check if buffer is allocated and if so return bytes left in a           */ +/* @c SLPBuffer object.                                                    */ +/*                                                                         */ +/* @param[in] buf The SLPBuffer to be freed.                               */ +/*=========================================================================*/ +{ +   if (buf->allocated == 0) { +      return 0; +   } +   return buf->end - buf->curpos; +}    /*=========================================================================*/  SLPBuffer SLPBufferDup(SLPBuffer buf) diff -ur --- +++ @@ @@  /*                                                                         */  /***************************************************************************/   +/* Copyright (c) VMware, Inc. + * SPDX-License-Identifier: BSD-3-Clause + * This file is provided under the BSD-3-Clause license. + * See COPYING file for more details and other copyrights + * that may apply. + */ +  #if(!defined SLP_BUFFER_H_INCLUDED)  #define SLP_BUFFER_H_INCLUDED   @@ @@  /* Returns the added item in the list.                                     */  /*=========================================================================*/   +size_t RemainingBufferSpace(SLPBuffer buf); +/*=========================================================================*/ +/* Return bytes left in buffer from current position                       */ +/*                                                                         */ +/* buf (IN) pointer to the buffer                                          */ +/*                                                                         */ +/* Returns number of bytes left in buffer from current position            */ +/*=========================================================================*/ +    /*=========================================================================*/  void* memdup(const void* src, int srclen); diff -ur --- +++ @@ @@  /*                                                                         */  /***************************************************************************/   +/* Copyright (c) VMware, Inc. + * SPDX-License-Identifier: BSD-3-Clause + * This file is provided under the BSD-3-Clause license. + * See COPYING file for more details and other copyrights + * that may apply. + */ +  /*=========================================================================*/  /* slpd includes                                                           */  /*=========================================================================*/ @@ @@          {              /* urlentry is the url from the db result */              urlentry = db->urlarray[i]; - +            if (urlentry->opaque != NULL) +            { +                const int64_t newsize = size + urlentry->opaquelen; +                if (urlentry->opaquelen <= 0 || newsize > INT_MAX) +                { +                    SLPDLog("Invalid opaquelen %d or sizeo of opaque url is too big, size=%d\n", +                            urlentry->opaquelen, size); +                    errorcode = SLP_ERROR_PARSE_ERROR; +                    goto FINISHED; +                } +            size +=  urlentry->opaquelen; +         } +         else +         { +            /* urlentry is the url from the db result */              size += urlentry->urllen + 6; /*  1 byte for reserved  */                                            /*  2 bytes for lifetime */                                            /*  2 bytes for urllen   */                                            /*  1 byte for authcount */ +          }  #ifdef ENABLE_SLPv2_SECURITY                /* make room to include the authblock that was asked for */ @@ @@              urlentry = db->urlarray[i];     #ifdef ENABLE_SLPv1 -            if (urlentry->opaque == 0) +            if (urlentry->opaque == NULL)              {                  /* url-entry reserved */                  *result->curpos = 0;         @@ @@                  ToUINT16(result->curpos,urlentry->urllen);                  result->curpos = result->curpos + 2;                  /* url-entry url */ -                memcpy(result->curpos,urlentry->url,urlentry->urllen); -                result->curpos = result->curpos + urlentry->urllen; +                if (RemainingBufferSpace(result) >= urlentry->urllen) +                { +                   memcpy(result->curpos, urlentry->url, urlentry->urllen); +                   result->curpos = result->curpos + urlentry->urllen; +                } +                else +                { +                   SLPDLog("Url too big (ask: %d have %lld), failing request\n", +                           urlentry->opaquelen, (long long) RemainingBufferSpace(result)); +                   errorcode = SLP_ERROR_PARSE_ERROR; +                   goto FINISHED; +                }                  /* url-entry auths */                  *result->curpos = 0;                  result->curpos = result->curpos + 1; @@ @@                  /* Use an opaque copy if available (and authentication is not being used)*/                  /* TRICKY: fix up the lifetime */                  ToUINT16(urlentry->opaque + 1,urlentry->lifetime); -                memcpy(result->curpos,urlentry->opaque,urlentry->opaquelen); -                result->curpos = result->curpos + urlentry->opaquelen; +                if (RemainingBufferSpace(result) >= urlentry->opaquelen) +                { +                   memcpy(result->curpos, urlentry->opaque, urlentry->opaquelen); +                   result->curpos = result->curpos + urlentry->opaquelen; +                } +                else +                { +                   SLPDLog("Opaque Url too big (ask: %d have %lld), failing request\n", +                           urlentry->opaquelen, (long long) RemainingBufferSpace(result)); +                   errorcode = SLP_ERROR_PARSE_ERROR; +                   goto FINISHED; +                }              }          }      }  ============================== /PATCH FOR OPENSLP ============================   ============================== PATCH FOR OPENSLP =============================  diff -ur --- +++ @@ @@   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.   *-------------------------------------------------------------------------*/   +/* Copyright (c) VMware, Inc. + * SPDX-License-Identifier: BSD-3-Clause + * This file is provided under the BSD-3-Clause license. + * See COPYING file for more details and other copyrights + * that may apply. + */ +  /** Functions for managing SLP message buffers.   *   * This file provides a higher level abstraction over malloc and free that @@ @@     xfree(buf);  }   +/** Report remaining free buffer size in bytes. + * + * Check if buffer is allocated and if so return bytes left in a + * @c SLPBuffer object. + * + * @param[in] buf The SLPBuffer to be freed. + */ +size_t +RemainingBufferSpace(SLPBuffer buf) +{ +   if (buf->allocated == 0) { +      return 0; +   } +   return buf->end - buf->curpos; +} +  /*=========================================================================*/ diff -ur --- +++ @@ @@   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.   *-------------------------------------------------------------------------*/   +/* Copyright (c) VMware, Inc. + * SPDX-License-Identifier: BSD-3-Clause + * This file is provided under the BSD-3-Clause license. + * See COPYING file for more details and other copyrights + * that may apply. + */ +  /** Header file that defines SLP message buffer management routines.   *   * Includes structures, constants and functions that used to handle memory  @@ @@    SLPBuffer SLPBufferListAdd(SLPBuffer * list, SLPBuffer buf);   +size_t RemainingBufferSpace(SLPBuffer buf); +  /*! @} */    #endif /* SLP_BUFFER_H_INCLUDED */ diff -ur --- +++ @@ @@   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.   *-------------------------------------------------------------------------*/   +/* Copyright (c) VMware, Inc. + * SPDX-License-Identifier: BSD-3-Clause + * This file is provided under the BSD-3-Clause license. + * See COPYING file for more details and other copyrights + * that may apply. + */ +  /** Processes incoming SLP messages.   *   * @file       slpd_process.c @@ @@     {        for (i = 0; i < db->urlcount; i++)        { -         /* urlentry is the url from the db result */           urlentry = db->urlarray[i]; +         if (urlentry->opaque != NULL) { +            const int64_t newsize = size + urlentry->opaquelen; +            if (urlentry->opaquelen <= 0 || newsize > INT_MAX) +            { +               SLPDLog("Invalid opaquelen %d or sizeo of opaque url is too big, size=%d\n", +                       urlentry->opaquelen, size); +               errorcode = SLP_ERROR_PARSE_ERROR; +               goto FINISHED; +            } +            size +=  urlentry->opaquelen; +         } +         else +         { +            /* urlentry is the url from the db result */ +            size += urlentry->urllen + 6; /*  1 byte for reserved  */ +                                          /*  2 bytes for lifetime */ +                                          /*  2 bytes for urllen   */ +                                          /*  1 byte for authcount */ +          }   -         size += urlentry->urllen + 6; /*  1 byte for reserved  */ -                                       /*  2 bytes for lifetime */ -                                       /*  2 bytes for urllen   */ -                                       /*  1 byte for authcount */  #ifdef ENABLE_SLPv2_SECURITY           /* make room to include the authblock that was asked for */           if (G_SlpdProperty.securityEnabled @@ @@           urlentry = db->urlarray[i];    #ifdef ENABLE_SLPv1 -         if (urlentry->opaque == 0) +         if (urlentry->opaque == NULL)           {              /* url-entry reserved */              *result->curpos++ = 0; @@ @@              PutUINT16(&result->curpos, urlentry->urllen);                /* url-entry url */ -            memcpy(result->curpos, urlentry->url, urlentry->urllen); -            result->curpos += urlentry->urllen; +            if (RemainingBufferSpace(result) >= urlentry->urllen) +            { +               memcpy(result->curpos, urlentry->url, urlentry->urllen); +               result->curpos = result->curpos + urlentry->urllen; +            } +            else +            { +                SLPDLog("Url too big (ask: %d have %" PRId64 "), failing request\n", +                        urlentry->opaquelen, (int64_t) RemainingBufferSpace(result)); +                errorcode = SLP_ERROR_PARSE_ERROR; +                goto FINISHED; +            }                /* url-entry auths */              *result->curpos++ = 0; @@ @@                /* TRICKY: Fix up the lifetime. */              TO_UINT16(urlentry->opaque + 1, urlentry->lifetime); -            memcpy(result->curpos, urlentry->opaque, urlentry->opaquelen); -            result->curpos += urlentry->opaquelen; +            if (RemainingBufferSpace(result) >= urlentry->opaquelen) +            { +               memcpy(result->curpos, urlentry->opaque, urlentry->opaquelen); +               result->curpos = result->curpos + urlentry->opaquelen; +             } +             else +             { +               SLPDLog("Opaque Url too big (ask: %d have %" PRId64 "), failing request\n", +                       urlentry->opaquelen, (int64_t) RemainingBufferSpace(result)); +               errorcode = SLP_ERROR_PARSE_ERROR; +               goto FINISHED; +             }           }        }     }  ============================== /PATCH FOR OPENSLP =============================     Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      