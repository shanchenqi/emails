  oss-security - Re: GCC Compiler Induced Vulnerability - affects programs compiled with GCC 7 and 8 containing nested functions            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [<thread-prev] [thread-next>] [day] [month] [year] [list]  Date: Mon, 22 Oct From: Matthew Fernandez <matthew.fernandez@...il.com> To: oss-security@...ts.openwall.com Subject: Re: GCC Compiler Induced Vulnerability - affects programs compiled with GCC 7 and 8 containing nested functions    > On 22 Oct at Andrew Sandoval <ASandoval@...root.com> wrote: >  > Introduction to GCC Compiler Induced Vulnerability > ================================================== >  > Hal Lonas > 11 October >  > INTRODUCTION > Webroot engineers recently discovered a vulnerability with Linux and Windows > executables produced by the Gnu C Compiler, commonly known as GCC. >  > Technical Description of the vulnerability > When nested C functions are compiled by GCC, code is generated which causes the > call stack of the currently executing thread to be made executable prior to the > call to a nested function and for the duration of the thread's lifetime.  This > is essentially the equivalent of disabling Data Execution Prevention (DEP). > A stack overflow, etc., that is able to place instructions on the page(s) of > memory made executable has the potential of gaining execution and running > malware, etc.  This places the process at substantial risk of being exploited. >  > How was the vulnerability found? > Engineers using anti-exploit tools developed at Webroot found this > vulnerability in commonly used tools such as: > * Git for Windows Installer > * Cygwin Installer > * MinTTY > * Git Bash Shell > * ...and other similar tools >  > What versions of GCC have we tested? > We have found the vulnerability to be produced when using the following > versions of GCC: > * 8.1 > * 7.3 > * 7.1 >  > These were the only versions we tested and all produced the vulnerability in > output executables.  No other GCC versions were tested. >  > Why this communication? > We are taking this opportunity to inform the custodians of GCC so that the > vulnerability might be addressed before it becomes public knowledge. >  > Will Webroot communicate this to the public? > Webroot believes in responsible disclosure and will work with third parties to > ensure that the vulnerability is addressed before a public announcement. We > are happy to work with your communications team on announcement timing. >  > ============================================================================== > DETAILED DISCLOSURE FOLLOWS > ============================================================================== >  > Webroot Security Vulnerability Disclosure > ========================================= > Software compiled with various versions of GCC on Windows and Linux may contain a serious security vulnerability.  The > vulnerability will exist when C code with nested functions are compiled.  Examples of vulnerable software include Cygwin > Bash, MinTTY, and similar tools included with Git for Windows, and other Unix-like tools on Windows, etc. >  > On x86 / x64 Linux based systems (and possibly other Unix systems) any tool compiled with GCC which utilizes nested C > functions is vulnerable. >  > Vulnerability > ============= > When nested C functions are compiled by GCC, code is generated which causes the call stack of the currently executing > thread to be made executable prior to the call to a nested function and for the duration of the thread's lifetime. > This is essentially the equivalent of disabling Data Execution Prevention (DEP).  A stack overflow, etc., that is able > to place instructions on the page(s) of memory made executable has the potential of gaining execution and running > malware, etc.  This places the process at substantial risk of being exploited. >  > Windows Example > =============== > The following simple C program, when compiled by GCC, generates code that has an executable stack shortly after main() > is entered: >  > #include <stdio.h> > #include <Windows.h> >  > int main() > { >       BOOL CALLBACK EnumWindowsCB(HWND hWnd, LPARAM lp) >       { >              printf("Window: %p\n", hWnd); >       } >       printf("Enum'd Windows:\n"); >       EnumWindows(EnumWindowsCB, 0); >       return 0; > } >  > When compiled as an binary, main looks like this: >  > ; =============== S U B R O U T I N E ======================================= > > ; Attributes: bp-based frame > > ; int __cdecl main(int argc, const char **argv, const char **envp) >                 public main > main            proc near               ; CODE XREF: >                                         ; DATA XREF: ... > > var_30          = byte ptr -30h > var_10          = qword ptr -10h > arg_0           = byte ptr  10h > >                 push    rbp >                 mov     rbp, rsp >                 sub     rsp, 50h >                 call    __main >                 lea     rax, [rbp+arg_0] >                 mov     [rbp+var_10], rax >                 lea     rax, [rbp+var_30] >                 lea     rdx, [rbp+var_30] >                 mov     word ptr [rax], >                 lea     rcx, >                 mov     [rax+2], rcx >                 mov     word ptr [rax+0Ah], >                 mov     [rax+0Ch], rdx >                 mov     dword ptr [rax+14h], >                 mov     rcx, rax >                 call    __enable_execute_stack >                 lea     rcx, aEnumDWindows ; "Enum'd Windows:" >                 call    puts >                 lea     rax, [rbp+var_30] >                 mov     edx, 0 >                 mov     rcx, rax >                 mov     rax, cs:__imp_EnumWindows >                 call    rax ; __imp_EnumWindows >                 mov     eax, 0 >                 add     rsp, 50h >                 pop     rbp >                 retn > main            endp > > ; --------------------------------------------------------------------------- >  > The nested function "EnumWindowsCB" is referenced in the lea instruction at address  It looks like this (which > is essentially the same as it would look as a non-nested function): >  > ; =============== S U B R O U T I N E ======================================= > > ; Attributes: bp-based frame > > proc near           ; DATA XREF: main+22o >                                         ; > > var_8           = qword ptr -8 > arg_0           = qword ptr  10h > arg_8           = qword ptr  18h > >                 push    rbp >                 mov     rbp, rsp >                 sub     rsp, 30h >                 mov     [rbp+arg_0], rcx >                 mov     [rbp+arg_8], rdx >                 mov     [rbp+var_8], r10 >                 mov     rdx, [rbp+arg_0] >                 lea     rcx, aWindowP   ; "Window: %p\n" >                 call    printf >                 nop >                 add     rsp, 30h >                 pop     rbp >                 retn > endp >  > Despite the fact that EnumWindowsCB does not need to access any local variables in main(), the code in main() between > and sets up stack variables that would make this possible, and then the CALL at address makes the > call stack itself at least partially executable, by passing the address of the context structure [var_30] to > __enable_execute_stack, which looks like this: >  > ; =============== S U B R O U T I N E ======================================= > > >                 public __enable_execute_stack > __enable_execute_stack proc near        ; CODE XREF: main+41p >                                         ; DATA XREF: > > dwLength        = qword ptr -38h > flNewProtect    = dword ptr -20h > >                 push    rbx >                 sub     rsp, 50h >                 mov     r8d, 30h >                 lea     rbx, [rsp+58h+dwLength] >                 mov     rdx, rbx        ; dwLength >                 call    cs:__imp_VirtualQuery >                 test    rax, rax >                 jz      __enable_execute_stack_cold_0 >                 mov     rdx, qword ptr [rsp+58h+flNewProtect] ; flNewProtect >                 lea     r9, [rbx+24h] >                 mov     r8d, 40h >                 mov     rcx, [rsp+58h+dwLength] ; lpflOldProtect >                 call    cs:__imp_VirtualProtect >                 nop >                 add     rsp, 50h >                 pop     rbx >                 retn > __enable_execute_stack endp >  > The code in __enable_execute_stack() calls VirtualQuery() to find out the RegionSize and the BaseAddress of the > structure [var_30].  It then calls VirtualProtect to make this entire region PAGE_EXECUTE_READWRITE.  At a minimum > one whole page bytes) of stack memory is made executable.  Potentially many more pages of stack memory could > be made executable by the function, depending upon the results of the call to VirtualQuery (which will return a > RegionSize for all pages from BaseAddress onward that have matching State, Type, and Protect bits).  Different > functions are likely to return larger RegionSize results further extending the amount of memory placed at risk. >  > It is also important to notice that the stack is made executable sometime before the context variable is even used in > the call to EnumWindows() which utilizes the nested C function.  This is obvious by the code start at address > in main(): >  >                 call    __enable_execute_stack ; <-- Stack is made executable here <-- >                 lea     rcx, aEnumDWindows ; "Enum'd Windows:" >                 call    puts                   ; <-- puts definitely does not need an executable stack <-- >                 lea     rax, [rbp+var_30] >                 mov     edx, 0 >                 mov     rcx, rax >                 mov     rax, cs:__imp_EnumWindows >                 call    rax ; __imp_EnumWindows ; <-- Nested C function called <-- >                 mov     eax, 0 >                 add     rsp, 50h >                 pop     rbp >                 retn > main            endp >  > The call to printf("Enum'd Windows:\n") from our code in main() runs AFTER the stack is made executable, but BEFORE > EnumWindows() is called. >  > This means that not only is the call to EnumWindows() and its (nested) callback function EnumWindowsCB() potentially > capable of intentionally or unintentionally placing exploit instructions or shell code upon the stack, but so also is > every other function called within main(), before or after use of the nested function. >  > Furthermore, this executable stack memory is leaked as executable.  There is no code generated that restores the > original page protections after the nested C function has been utilized for the last time.  For the lifetime of the > program, anything that is able to cause a stack overflow (etc.) and cause execution to occur on the stack in the > executable page(s), will not raise an access violation and therefore the process will remain exploitable for the > duration of the current thread. >  > This flaw in GCC could allow an attacker to gain execution in the same way in which they would if Data Execution > Prevent (DEP) had been disabled on a 32-bit system.  Worse, the Windows Task Manager will not show that DEP is > (essentially) disabled, and 64-bit processes (where DEP cannot normally be disabled) are made vulnerable to data > execution by this flaw in GCC generated code. >  > Note that nested C functions appear to be particular to code compiled with GCC.  Most if not all C++ compilers are > able to produce code from lambdas (similar to nested functions) without compromising the call stack. >  > Linux Example > ============= > Below is a similar C program with a nested C function written to run on Linux / Unix: >  > #include <stdio.h> > #include <string.h> > #include <sys/types.h> > #include <unistd.h> >  > // > // DumpMapsStackEntry is a utility function that finds and prints the call stack > // identified by [stack] in the procfs maps file for the current process > void DumpMapsStackEntry() > { >       char >       sprintf(&szMapsFile[0], "/proc/%u/maps", getpid()); >  >       FILE *pfMaps = fopen(&szMapsFile[0], "rt"); >       char >       while(NULL != fgets(&szLine[0], sizeof(szLine) - 1, pfMaps)) >       { >              if(NULL == strstr(&szLine[0], "[stack]")) >              { >                     continue; >              } >              printf("%s\n", &szLine[0]); >       } >       fclose(pfMaps); > } >  > // > // EnumerateViaCallback is a "API" that invokes the callback function > void EnumerateViaCallback(void (*pfnCB)(int, const char *), >       const char *pszPassThrough) > { >       for(int i = 0; i < 10; ++i) >       { >              pfnCB(i, pszPassThrough); >       } > } >  > #ifndef VULN_TEST_FORCEFULLY_OMIT_CODE > // > // Note: Testing shows that just having this function present causes > // the stack to be executable from main() onward...  Even if VulnTest is > // never invoked or even referenced!  The ifdef above may be defined > // demonstrate this assertion. > // > void VulnTest(int iTest) > { >       if(0 == iTest) >       { >              printf("Nested Function Omitted\n"); >              return; >       } >  >       // >       // Nested C function: >       void EnumCallback(int iN, const char *pszPassThrough) >       { >              printf("N = %i, pass through: %s\n", >                     iN, >                     pszPassThrough); >              if(5 == iN) >              { >                     printf("Check memory protections of stack pages near %p\n", >                           __builtin_frame_address(0)); >                     DumpMapsStackEntry(); >                     printf("Press enter to continue\n"); >                     getchar(); >              } >       } >  >       // >       // Call the thing that invokes the nested function... >       printf("Enumerate 1 - 10\n"); >       EnumerateViaCallback(EnumCallback, "Test"); > } > #endif >  > int main(int iArgc, const char *ppszArgv[]) > { >       printf("Current Process: %u\n", getpid()); >       DumpMapsStackEntry(); >  > #ifdef VULN_TEST_FORCEFULLY_OMIT >       printf("Nested function #ifdef'd out!\n"); > #else >       VulnTest((iArgc > 1) ? 0 : 1); > #endif >  >       printf("Done with callback press Enter to exit\n"); >       DumpMapsStackEntry(); >       getchar(); >       return 0; > } >  > Though substantially longer than the simple Windows example, this example code is essentially the same other than that > EnumerateViaCallback() was written instead of using a system API that required a callback, and DumpMapsStackEntry() is > called frequently to show whether or not the current call stack is executable. >  > This code was saved in the file nested.c, and then compiled with three different sets of options as shown below: >  * gcc nested.c -o nested_test >  * gcc nested.c -o nested_test_ifdefd -DVULN_TEST_FORCEFULLY_OMIT >        o This disables the call to VulnTest causing it to be unreferenced >  * gcc nested.c -o nested_test_ifdefd_code -DVULN_TEST_FORCEFULLY_OMIT -DVULN_TEST_FORCEFULLY_OMIT_CODE >        o This completely removes VulnTest and of course ensures that it is not referenced >  > The results from running each version are shown below, with the resulting stack memory protections highlighted: > asandoval@...ntu:~$ gcc nested.c -o nested_test_ifdefd -DVULN_TEST_FORCEFULLY_OMIT > asandoval@...ntu:~$ gcc nested.c -o nested_test_ifdefd_code -DVULN_TEST_FORCEFULLY_OMIT -DVULN_TEST_FORCEFULLY_OMIT_CODE > asandoval@...ntu:~$ gcc nested.c -o nested_test > asandoval@...ntu:~$ ./nested_test > Current Process: > rwxp 0                          [stack] >  > Enumerate 1 - 10 > N = 0, pass through: Test > N = 1, pass through: Test > N = 2, pass through: Test > N = 3, pass through: Test > N = 4, pass through: Test > N = 5, pass through: Test > Check memory protections of stack pages near > rwxp 0                          [stack] >  > Press enter to continue >  > N = 6, pass through: Test > N = 7, pass through: Test > N = 8, pass through: Test > N = 9, pass through: Test > Done with callback press Enter to exit > rwxp 0                          [stack] >  > asandoval@...ntu:~$ ./nested_test_ifdefd > Current Process: > rwxp 0                          [stack] >  > Nested function #ifdef'd out! > Done with callback press Enter to exit > rwxp 0                          [stack] >  >  > asandoval@...ntu:~$ ./nested_test_ifdefd_code > Current Process: > rw-p 0                          [stack] >  > Nested function #ifdef'd out! > Done with callback press Enter to exit > rw-p 0                          [stack] >  >  > asandoval@...ntu:~$ >  > In the first two cases, where the nested C function was present, whether referenced or not, the stack is executable, > making the process vulnerable and essentially disabling DEP for the stack.  Only the last instance of the program where > the nested C function is completely compiled out has a non-executable stack. >  > Additionally, the presence of the nested C function causes the stack to be executable throughout the life of the > program, from start to finish - which is even more risky than the behavior seen on Windows. > The reason for this is evident from the ELF program header for each version of the program.  Notice the GNU_STACK > section pointed which is boxed off for highlighting purposes: >  > asandoval@...ntu:~$ readelf -l nested_test >  > Elf file type is DYN (Shared object file) > Entry point > There are 9 program headers, starting at offset 64 >  > Program Headers: >  Type           Offset             VirtAddr           PhysAddr >                 FileSiz            MemSiz              Flags  Align >  PHDR           >                  R      0x8 >  INTERP         >                  R      0x1 >      [Requesting program interpreter: >  LOAD           >                  R E    >  LOAD           >                  RW     >  DYNAMIC        >                  RW     0x8 >  NOTE           >                  R      0x4 >  GNU_EH_FRAME   >                  R      0x4 > +----------------------------------------------------------------------------+ > | GNU_STACK         | > |                 RWE             | > +----------------------------------------------------------------------------+ >  GNU_RELRO      >                  R      0x1 >  > Section to Segment mapping: >  Segment Sections... >   00 >   01     .interp >   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame >   03     .init_array .fini_array .dynamic .got .data .bss >   04     .dynamic >   05     .note.ABI-tag .note.gnu.build-id >   06     .eh_frame_hdr >   07 >   08     .init_array .fini_array .dynamic .got >  >  > asandoval@...ntu:~$ readelf -l nested_test_ifdefd >  > Elf file type is DYN (Shared object file) > Entry point > There are 9 program headers, starting at offset 64 >  > Program Headers: >  Type           Offset             VirtAddr           PhysAddr >                 FileSiz            MemSiz              Flags  Align >  PHDR           >                  R      0x8 >  INTERP         >                  R      0x1 >      [Requesting program interpreter: >  LOAD           >                  R E    >  LOAD           >                  RW     >  DYNAMIC        >                  RW     0x8 >  NOTE           >                  R      0x4 >  GNU_EH_FRAME   >                  R      0x4 > +---------------------------------------------------------------------------+ > | GNU_STACK        | > |                 RWE            | > +---------------------------------------------------------------------------+ >  GNU_RELRO      >                  R      0x1 >  > Section to Segment mapping: >  Segment Sections... >   00 >   01     .interp >   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame >   03     .init_array .fini_array .dynamic .got .data .bss >   04     .dynamic >   05     .note.ABI-tag .note.gnu.build-id >   06     .eh_frame_hdr >   07 >   08     .init_array .fini_array .dynamic .got >  >  > asandoval@...ntu:~$ readelf -l nested_test_ifdefd_code >  > Elf file type is DYN (Shared object file) > Entry point > There are 9 program headers, starting at offset 64 >  > Program Headers: >  Type           Offset             VirtAddr           PhysAddr >                 FileSiz            MemSiz              Flags  Align >  PHDR           >                  R      0x8 >  INTERP         >                  R      0x1 >      [Requesting program interpreter: >  LOAD           >                  R E    >  LOAD           >                  RW     >  DYNAMIC        >                  RW     0x8 >  NOTE           >                  R      0x4 >  GNU_EH_FRAME   >                  R      0x4 > +---------------------------------------------------------------------------+ > | GNU_STACK        | > |                 RW             | > +---------------------------------------------------------------------------+ >  GNU_RELRO      >                  R      0x1 >  > Section to Segment mapping: >  Segment Sections... >   00 >   01     .interp >   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame >   03     .init_array .fini_array .dynamic .got .data .bss >   04     .dynamic >   05     .note.ABI-tag .note.gnu.build-id >   06     .eh_frame_hdr >   07 >   08     .init_array .fini_array .dynamic .got >  > As expected, only the last, instance of the program without the nested C function creates a read-write stack.  The > other instances create a vulnerable read-write-execute stack that remains in use for the lifetime of the program. >  > A script run as an ordinary user can detect the vulnerable programs simply by reading the ELF header. >  > Versions of GCC Affected > ======================== > GCC 8.1, 7.3, and 7.1 were tested.  Each version generated code with this flaw.  No other versions of GCC were tested. > Other versions which support nested C functions are likely to be vulnerable as well. >  > Many products, including the popular Git for Windows, and Cygwin tools are compiled with GCC versions that produce > vulnerable executables. >  > Webroot Detection > ================= > Webroot Exploit Shield (available only to closed beta participants as of 1 August detects various forms of stack > exploitation including some forms of Return Oriented Programming (ROP), Stack Pivots, and Stacks being made executable. > Users are warned of such potential exploits in progress and urged to terminate the process when such behavior is > detected.  The default behavior of Exploit Shield (absent a customer response) is to terminate processes where a stack > exploit is identified.  Currently Webroot Exploit Shield identifies stack exploitation in the following applications > due this flaw in GCC: >  > * Git for Windows Installer > * Cygwin Installer > * MinTTY > * Git Bash Shell > * and many other similar tools >  > Research Provided by Andrew Sandoval / Senior Principal Engineer, Webroot Software Inc.  FWIW this is already documented in the GCC docs, https://gcc.gnu.org/onlinedocs/gccint/Trampolines.html. Quoting from there:  âThe use of trampolines requires an executable stack, which is a security risk. To avoid this problem, GCC also supports another strategy: using descriptors for nested functions. Under this model, taking the address of a nested function results in a pointer to a non-executable function descriptor object. Initializing the static chain from the descriptor is handled at indirect call sites.â  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      