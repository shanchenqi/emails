  oss-security - SEC Consult :: Multiple buffer overflow vulnerabilities  in InfoZip UnZip            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [thread-next>] [day] [month] [year] [list]  Date: Thu, 8 Feb From: SEC Consult Vulnerability Lab <research@...-consult.com> To: <oss-security@...ts.openwall.com> Subject: SEC Consult :: Multiple buffer overflow vulnerabilities  in InfoZip UnZip  SEC Consult Vulnerability Lab Security Advisory < > =======================================================================               title: Multiple buffer overflow vulnerabilities             product: InfoZip UnZip  vulnerable version: UnZip <= / UnZip <=       fixed version:          CVE number:                                   impact: high            homepage: http://www.info-zip.org/UnZip.html               found:                  by: R. Freingruber (Office Vienna)                      SEC Consult Vulnerability Lab                       An integrated part of SEC Consult                      Bangkok - Berlin - Linz - Luxembourg - Montreal - Moscow                      Kuala Lumpur - Singapore - Vienna (HQ) - Vilnius - Zurich                       https://www.sec-consult.com  =======================================================================  Vendor description: ------------------- "UnZip is an extraction utility for archives compressed in .zip format (also called "zipfiles"). Although highly compatible both with PKWARE's PKZIP and PKUNZIP utilities for MS-DOS and with Info-ZIP's own Zip program, our primary objectives have been portability and non-MSDOS functionality. UnZip will list, test, or extract files from a .zip archive, commonly found on MS-DOS systems. The default behavior (with no options) is to extract into the current directory (and subdirectories below it) all files from the specified zipfile."  Source: http://www.info-zip.org/UnZip.html  InfoZip's UnZip is used as default utility for uncompressing ZIP archives on nearly all *nix systems. It gets shipped with many commerical products on Windows to provide (un)compressing functionality as well.   Business recommendation: ------------------------ InfoZip Unzip should be updated to the latest available version.   Vulnerability overview/description: ----------------------------------- 1) Heap-based buffer overflow in password protected ZIP archives  InfoZip's UnZip suffers from a heap-based buffer overflow when uncompressing password protected ZIP archives. An attacker can exploit this vulnerability to overwrite heap chunks to get arbitrary code execution on the target system.  For newer builds the risk for this vulnerability is partially mitigated because modern compilers automatically replace unsafe functions with length checking variants of the same function (for example sprintf gets replaced by sprintf_chk). This is done by the compiler at locations were the length of the destination buffer can be calculated.  Nevertheless, it must be mentioned that UnZip is used on many systems including older systems or on exotic architectures on which this protection is not in place. Moreover, pre-compiled binaries which can be found on the internet lack the protection because the last major release of InfoZip's UnZip was in and compilers didn't enable this protection per default at that time. The required compiler flags are also not set in the Makefile of UnZip. Compiled applications are therefore only protected if the used compiler has this protection enabled per default which is only the case with modern compilers.  To trigger this vulnerability (and the following) it's enough to uncompress a manipulated ZIP archive. Any of the following invocations can be used to trigger and abuse the vulnerabilities:  > unzip malicious.zip > unzip -p malicious.zip > unzip -t malicious.zip  2) Heap-based out-of-bounds write  This vulnerability only affects UnZip (next beta version of UnZip). InfoZip's UnZip suffers from a heap-based out-of-bounds write if the archive filename does not contain a .zip suffix.  3) Heap/BSS-based buffer overflow (Bypass of  This vulnerability only affects UnZip (next beta version of UnZip). InfoZip's UnZip suffers from a heap/BSS-based buffer-overflow which can be used to write null-bytes out-of-bound when converting attacker-controlled strings to the local charset.  4) Heap out-of-bounds access in ef_scan_for_stream  This vulnerability only affects UnZip (next beta version of UnZip). InfoZip's UnZip suffers from a heap out-of-bounds access vulnerability.  5) Multiple vulnerabilities in the LZMA compression algorithm  This vulnerability only affects UnZip (next beta version of UnZip). InfoZip's UnZip suffers from multiple vulnerabilities in the LZMA implementation. Various crash dumps have been supplied to the vendor but no further analysis has been performed.   Proof of concept: ----------------- 1) Heap-based buffer overflow in password protected ZIP archives  Unzipping a malicious archive results in the following output: (On Ubuntu with UnZip 6.0 which was installed via aptitude install unzip)  *** buffer overflow detected ***: unzip terminated ======= Backtrace: =========  Function names can be mapped to the backtrace by compiling the application with debug symbols:  (gdb) backtrace #0  in UzpPassword () #1  in decrypt () #2  in extract_or_test_entrylist () #3  in extract_or_test_files () #4  in do_seekable () #5  in process_zipfiles () #6  in unzip ()  The vulnerability resides inside the UzpPassword function in the following code snippet (file ./fileio.c):  ((prompt = (char *)malloc(2*FILNAMSIZ + 15)) != (char *)NULL) { LoadFarString(PasswPrompt), FnFilter2(efn)); ... 					 The allocation at line allocates a fixed size buffer and then writes into it at line It writes the following format string (PasswPrompt) into the buffer: "[%s] %s password: "  This string has a length of 15 including the null-termination which explains the +15 in the allocation. The developer allocated 2*FILENAMESIZ which corresponds to 2 * PATH_MAX for the two format strings (zfn and efn). zfn is the archive filename and can therefore not exceed PATH_MAX. efn is the current processed filename inside the ZIP archive which should typically be smaller than PATH_MAX for normal files. However, since an attacker can manipulate the archive file the name can arbitrarily be chosen which leads to a heap-based buffer overflow.  As already mentioned, modern compilers replace unsafe functions with safe alternatives as a defense in depth mechanism. This feature is called BOSC (Built-in object size checking) and is part of the FORTIFY_SOURCE=2 protection. The following link shows the source code (and vulnerability) inside the Ubuntu package:  By checking the installed compiled binary the following code can be seen: (UnZip 6.0 from Ubuntu     mov       mov       mov    QWORD PTR    call   <malloc@plt> ...    mov       mov    esi,0x1    xor    eax,eax    call   <__sprintf_chk@plt>  The code allocates + 15) bytes but the unsafe sprintf function was replaced with the length-checking sprintf_chk() function which receives as argument the size of the buffer at address The risk is therefore mitigated on Ubuntu (and other modern operating systems), at least with the currently used compiler default flags.  However, many pre-compiled UnZip binaries can be found on the internet which are not compiled with this protection. For example, the following three links are the first links which can be found when searching for InfoZip UnZIP on the internet and which contain unprotected binaries: http://gnuwin32.sourceforge.net/packages/unzip.htm https://oss.oracle.com/el4/unzip/unzip.tar http://www.willus.com/archive/zip64/   2) Heap-based out-of-bounds write  When uncompressing ZIP archives the following code gets executed (file function set_zipfn_sgmnt_name() in UnZip  #define SGMNT_NAME_BOOST 8 ... 	if (G.zipfn_sgmnt == NULL) 	{ [1]		G.zipfn_sgmnt_size = (int)strlen(G.zipfn)+ SGMNT_NAME_BOOST; 		if ((G.zipfn_sgmnt = izu_malloc(G.zipfn_sgmnt_size)) == NULL) 	... [2]	zfstrcpy(G.zipfn_sgmnt, G.zipfn); 	/* Expect to find ".zXX" at the end of the segment file name. */ [3]	sufx_len = IZ_MAX( 0, ((int)strlen(G.zipfn_sgmnt)- 4)); [4]	suffix = G.zipfn_sgmnt+ sufx_len; 	... 	else	// No .zip extension 	{ [5]		zfstrcpy( (suffix+ sufx_len), ZSUFX); [6]		suffix += sufx_len+ 2; 	} 	/* Insert the next segment number into the file name (G.zipfn_sgmnt). */ [7]	sprintf(suffix, "%02d", (sgmnt_nr+ 1));  G.zipfn is the filename / path of the archive file. Line [1] allocates space for this name plus 8 (SGMNT_NAME_BOOST). Line [2] copies the name. [3] and [4] calculate the end address minus 4 which should point to a suffix if one is present. After [4] the variable suffix already points to this address. However, line [5] adds sufx_len again to suffix, the write target is therefore the base address + 2*(allocation_length - 4) but the buffer can only hold allocation_len bytes. Line [7] is another out-of-bounds write because of line [6].  Memory trace of the crash: #1 in memcpy #2 in set_zipfn_sgmnt_name #3 in find_local_header #4 in extract_or_test_entrylist #5 in extract_or_test_files #6 in extract_archive_seekable #7 in extract_archive #8 in process_zipfiles #9 in unzip #10 in main #11 in __libc_start_main  Please note that this vulnerability must not lead to a crash. If the overwritten memory is not used, the program works as expected.   3) Heap/BSS-based buffer overflow (Bypass of  During parsing ZIP archives the function charset_to_intern() can be called with the "string" argument pointing to attacker controlled data. This function converts the string in-place to another charset (string is an INOUT argument).  The following code performs this task in the function: [1]		slen = strlen(string); [2]		s = string; [3]		dlen = buflen = 2 * slen; [4]		d = buf = izu_malloc(buflen + 1); 		if (d) 		{ [5]			memset( buf, 0, buflen);  			/* William Robinet, SMS.  			 * Added FILNAMSIZ check to avoid buffer overflow. Better would 			 * be to pass in an actual destination buffer size. 			 */ [6]			if ((iconv(cd, &s, &slen, &d, &dlen) != (size_t)-1) && [7]			 (strlen(buf) < FILNAMSIZ)) 			{ [8]				strncpy(string, buf, buflen); 			} 			izu_free(buf); 		} 		 The input string pointer is stored in the variable "string" and "s" (see [2]). Line [6] tries to convert the input ("s") via iconv() to another charset. The destination is "d" / "buf" (see line [4]). This destination buffer has a size of two times the input length plus one ([3]).  The first problem can be found in line [5] which just initializes "buflen" bytes and not "buflen+1" bytes. Consider the input string is empty, therefore slen=0. This will allocate 1 byte at line [4] because of the +1. However, [5] calls memset with buflen=0 which leaves the 1-byte buffer uninitialized. In line [7] strlen() can therefore access data out-of-bounds if the uninitialized byte does not contain a null-byte. This flaw is not critical because it can just crash the application. Nevertheless, it should be fixed.  The second problem is harder to identify. The function do_string() is used to parse strings from ZIP archives. If the option DS_FN gets passed, the string is written into the filename[] array from the global variable G. The code at (in the function extract_or_test_files()) calls for example this function with this option:  do_string(__G__ G.crec.filename_length, DS_FN)) != PK_COOL)  Inside do_string() the following code can be found  Ext_ASCII_TO_Native(G.filename, G.pInfo->hostnum, G.pInfo->hostver, 	G.pInfo->HasUxAtt, (option == DS_FN_L));  The "Ext_ASCII_TO_Native" is a define which redirects to charset_to_intern(). The first argument (G.filename in this case) is passed to this function and can be accessed with the "string" argument in the above code. At line [6] iconv() is used to convert the input string from one charset (e.g.: to another (e.g.: UTF-8). Therefore "buf" contains the converted string after this call. With line [8] this converted string should be copied over the original location from the argument (G.filename in our case).  The strncpy at [8] limits the number of written characters to buflen. Because of [3] buflen is two times the input length and therefore a buffer overflow can happen (the real size of the input buffer is not passed to the function). This vulnerability was and an additional check was added to prevent this buffer overflow. The additional check at [7] checks the length of the converted string with this line: [7]			 (strlen(buf) < FILNAMSIZ))  Only if this check is passed the code at [8] gets executed:  [8]				strncpy(string, buf, buflen);  This should logically limit the number of bytes which can be written to be smaller than FILNAMSIZ (even if the wrong, higher number, is passed to strncpy).  For example: G.filename is defined in (inside the Uz_Globs struct):  char     filename[FILNAMSIZ];  FILNAMSIZ is defined in unzpriv.h and is equal to PATH_MAX Therefore, filename can hold a buffer of size When the above code gets executed and G.filename gets converted to another charset, this code gets executed:  [6]			if ((iconv(cd, &s, &slen, &d, &dlen) != (size_t)-1) && [7]			 (strlen(buf) < FILNAMSIZ)) 			{ [8]				strncpy(string, buf, buflen); 			}  Let's assume that our input string had a length of Because of [3] buflen will be That means if [8] is reached a strncpy with a limit of gets executed, however, the destination buffer only has a size of bytes (G.filename). The check at [7] should protect against this because if strlen(buf) (the source from strncpy) is bigger or equal than FILNAMSIZ the strncpy does not get executed. And since strncpy just copies until the first null-byte, it should just be possible to copy at maximum strlen(buf) bytes in this strncpy.  This assumption is wrong though. Strncpy() always writes n bytes - in the above case it will always write bytes and therefore a buffer overflow will always occur. This behavior can be found in the manpage of strncpy: "If the length of src is less than n, strncpy() writes additional null bytes to dest to ensure that a total of n bytes are written."  The strncpy can therefore be used to write null-bytes out-of-bound in the BSS or heap segment. Since the input string length is under attacker control, the write length can be manipulated. That means that an attacker can perform a partial overwrite to exploit this vulnerability. For example, the attacker can overwrite data in the Uz_Globs struct after G.filename with null-bytes. One attack target can be heap addresses. They can be partially overwritten (lower bytes) to change the heap address to point to an attacker controlled heap chunk to get control over the data and therefore also over the execution.   4) Heap out-of-bounds access in ef_scan_for_stream  The first two arguments to the function ef_scan_for_stream() are: ef_ptr and ef_len. This function is for example called at:  sts = ef_scan_for_stream( G.extra_field, 	(long)G.lrec.extra_field_length, 	&btmp_siz, 	&bitmap[ 0], 	&xlhdr, 	&cmnt);  The second argument (ef_len) stores the length / size of the first argument (ef_ptr) and access checks must be performed to ensure that no out-of-bounds access occurs.  Code line can access data out-of-bounds because length checks are missing:  bitmap = *(ef_ptr+ (data_byte++));  Debugger output:  Program received signal SIGSEGV, Segmentation fault. ef_scan_for_stream (...) at            bitmap = *(ef_ptr+ (data_byte++)); (gdb) print /x ef_ptr $10 = (gdb) print /x data_byte $11 = 0xc6 (gdb) print /x ef_len $12 = 0xc5    5) Multiple vulnerabilities in the LZMA compression algorithm  Invalid access attempts can occur at: - IF_BIT_0(probLen) - IF_BIT_0(prob) - IF_BIT_0(prob) - TREE_6_DECODE(prob, distance); - GET_BIT2(probLit, symbol, offs &= ~bit, offs &= bit) - IF_BIT_0(probLen) - IF_BIT_0(prob) - IF_BIT_0(prob) - TREE_DECODE(probLen, limit, len); - IF_BIT_0(prob)  No further analysis has been performed on the LZMA compression code. The vendor will remove this code entirely in future releases.   Vulnerable / tested versions: ----------------------------- Versions before and including / of InfoZip's Unzip have been found to be vulnerable. Version 6.0 was the latest major release at the time the security vulnerabilities were discovered. The next beta version is which has been tested as well.   Vendor contact timeline: ------------------------ Vulnerability 1 identified, further internal analysis Attempt to contact the developers via bug report page Initial contact to the developer via sms@...inode.info Information from the main developer: A new beta version             which will be released soon, incorporates some security features.             A link to the new beta version was provided. Sending encrypted advisory to sms@...inode.info             Informed developer of the latest possible release date Developer confirms the vulnerability and notes that             it should be easy to fix. The developer asks for a notification             if vulnerabilities are found in version Vulnerability 2-5 in UnZip identified,             the updated encrypted advisory with crash files was sent to             the developer. Developer confirmed the e-mail containing the updated advisory. Asking the developer when an update will be available and             to coordinate the release of the advisory together. E-mail from the developer: All vulnerabilities (except LZMA             vulnerabilities) are fixed in version A link to the new             version was provided. The LZMA code / feature will likely be disabled             until a better solution is available. Asking the developer for a coordinated release of the advisory. Informing the developer about the changed release date because             of the holidays. Distribution mailing lists will be informed on             the advisory will be released about one week after that.             Asking the developer for an InfoZip version with LZMA disabled. Informing the developer again that the current solution is to             upgrade to version which still contains the LZMA             vulnerabilities and if a version without LZMA is available. Informing distros@...openwall.org about the upcoming advisory. Received CVE numbers. Publication of the advisory    Solution: --------- Update to version Please note that the LZMA vulnerabilities are not yet fixed in this version.   Workaround: ----------- None   Advisory URL: ------------- https://www.sec-consult.com/en/vulnerability-lab/advisories/index.html   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SEC Consult Vulnerability Lab  SEC Consult Bangkok - Berlin - Linz - Luxembourg - Montreal - Moscow Kuala Lumpur - Singapore - Vienna (HQ) - Vilnius - Zurich  About SEC Consult Vulnerability Lab The SEC Consult Vulnerability Lab is an integrated part of SEC Consult. It ensures the continued knowledge gain of SEC Consult in the field of network and application security to stay ahead of the attacker. The SEC Consult Vulnerability Lab supports high-quality penetration testing and the evaluation of new offensive and defensive technologies for our customers. Hence our customers obtain the most current information about vulnerabilities and valid recommendation about the risk profile of new technologies.  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Interested to work with the experts of SEC Consult? Send us your application https://www.sec-consult.com/en/career/index.html  Interested in improving your cyber security with the experts of SEC Consult? Contact our local offices https://www.sec-consult.com/en/contact/index.html ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Mail: research at sec-consult dot com Web: https://www.sec-consult.com Blog: http://blog.sec-consult.com Twitter: https://twitter.com/sec_consult  EOF R. Freingruber   Download attachment "smime.p7s" of type "application/pkcs7-signature" bytes)  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      