  oss-security - X41 D-Sec GmbH Security Advisory Multiple  Vulnerabilities in OpenSC            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Tue, 14 Aug From: X41 D-Sec GmbH Advisories <advisories@...-dsec.de> To: bugtraq@...urityfocus.com, oss-security@...ts.openwall.com,  fulldisclosure@...lists.org Subject: X41 D-Sec GmbH Security Advisory Multiple  Vulnerabilities in OpenSC  -----BEGIN PGP SIGNED MESSAGE----- Hash:  X41 D-Sec GmbH Security Advisory:  Multiple Vulnerabilities in OpenSC ==================================   Overview - -------- Confirmed Affected Versions: Confirmed Patched Versions: possibly Vendor: OpenSC Vendor URL: https://github.com/OpenSC/OpenSC Credit: X41 D-Sec GmbH, Eric Sesterhenn Status: Public Advisory-URL:   Summary and Impact - ------------------ Multiple issues have been identified in OpenSC, ranging from stack based buffer overflows to out of bounds reads and writes on the heap. They can be triggered by malicious smartcards sending malformed responses to APDU commands. Additionally to those fixes reported here, a lot of minor issues (eg. OOB reads and similar) have been reported and fixed. The OpenSC team (especially Frank Morgner) did an excellent job on identifying and fixing further issues. Due to the large amount of issues, no individual issues have been rated with CVSS / CVE ID yet. X41 did not perform a full test or audit on the software, but tried to help identifying as many bugs as possible in over the course of a year.   Product Description - ------------------- OpenSC provides a set of libraries and utilities to work with smart cards. Its main focus is on cards that support cryptographic operations, and facilitate their use in security applications such as authentication, mail encryption and digital signatures.  OOB Write in musclelistfiles() ============================== In function muscle_list_files() in file src/libopensc/card-muscle.c an out of bounds write might occur, since bufLen is not checked.  {% highlight c %} static int musclelistfiles(sccardt card, u8 *buf, sizet bufLen) {         muscleprivate_t priv = MUSCLEDATA(card);         mscfst fs = priv->fs;         int x;         int count = 0;         mscfscheckcache(priv->fs);         for(x = 0; x < fs->cache.size; x++) {                 u8 oid= fs->cache.array[x].objectId.id;                 scdebug(card->ctx, SCLOGDEBUGNORMAL,                         "FILE:                                         if(0 == memcmp(fs->currentPath, oid, 2)) {                         buf[0] = oid[2];                         buf[1] = oid[3];                         if(buf[0] == && buf[1] == continue; /* No directories/null names outside of root */                         buf += 2;                         count+=2;                 }         }         return count; } {% endhighlight %}   OOB Write in tcosselectfile() ============================= In function tcos_select_file) in file src/libopensc/card-tcos.c a filename is extracted from an APDU response and written into the internal file->name variable.  {% highlight c %}                 case                         memcpy(file->name, d, len);                         file->namelen = len;                         break; {% endhighlight %}  No check is performed whether the string retrieved from the card fits into the buffer, which could trigger an OOB write.  OOB Write in pivvalidategeneral_authentication() ================================================ In case piv_validate_general_authentication()in src/libopensc/card-piv.c is called with a datalen parameter greater than an out of bound write occurs. Currently no caller seems to do this.  OOB Write in gemsafegetcert_len() ================================= The function gemsafe_get_cert_len() in file might write beyond the gemsafe_prkeys and gemsafe_cert arrays in case more than 12 containers are stored on the card.  {% highlight c %}         ind = 2; /* skip length */         while (ibuf[ind] == {                 if (ibuf[ind+1] == 0xFE) {                         gemsafeprkeys[i].ref = ibuf[ind+4];                         sclog(card->ctx, "Key container %d is allocated and uses keyref %d",                                         i+1, gemsafeprkeys[i].ref);                         ind += 9;                 }                 else {                         gemsafeprkeys[i].label = NULL;                         gemsafecert[i].label = NULL;                         sc_log(card->ctx, "Key container %d is unallocated", i+1);                         ind += 8;                 }                 i++;         } {% endhighlight %}   OOB Write in utilaclto_str() ============================ In function util_acl_to_str() in file src/tools/util.c no checks are performed whether the string put together fits into line, which could be abused to trigger limited out of bounds writes.  OOB Write in readpublickey() and readprivatekey() ================================================= In function read_public_key() in file src/tools/cryptoflex-tool.c the bufsize variable is overwritten with file->size retrieved from the smartcard. This could be bigger than allowing for a stack based buffer overflow in the sc_read_binary() call.  {% highlight c %}         u8 *p = buf;         sizet bufsize, keysize;         r = selectappdf();         if (r)                 return 1;         &path);         r = scselectfile(card, &path, &file);         if (r) {                 fprintf(stderr, "Unable to select public key file: %s\n", scstrerror(r));                 return 2;         }         bufsize = file->size;         scfilefree(file);         r = screadbinary(card, 0, buf, bufsize, 0); {% endhighlight %}  The same issue can be found in read_private_key()  {% highlight c %}         bufsize = file->size;         scfilefree(file);         r = screadbinary(card, 0, buf, bufsize, 0); {% endhighlight %}   OOB Write in decrypt_response() =============================== In function decrypt_response() in file an out of bounds overwrite can occur. No check is performed if the plaintext buffer fits into the out buffer before copying, leading to a memory overwrite.  {% highlight c %}         memcpy(out, plaintext, inlen - 2);         *outlen = in_len - 2;         return 0; {% endhighlight %}   OOB Write in cacgetserialnrfrom_CUID() ====================================== In function cac_get_serial_nr_from_CUID() in file src/libopensc/card-cac.c a serial number is copied into serial->value. The length argument of the memcpy() is the length of the source, not the destination, which can lead to an out of bounds memory write.  {% highlight c %}         if (priv->cacidlen) {                 serial->len = MIN(priv->cacidlen, SCMAXSERIALNR);                 memcpy(serial->value, priv->cacid, priv->cacidlen);                 SCFUNCRETURN(card->ctx, SCLOGDEBUGNORMAL, SC_SUCCESS);         } {% endhighlight %}   Off by One Write in scpkcs15emuesteid_init() ============================================ In function sc_pkcs15emu_esteid_init() in file src/libopensc/pkcs15-esteid.c an off by one write with a \x00 occurs in case the sc_read_record() functions returns sizeof(buf) read bytes.  {% highlight c %}         /* read the serial (document number) */         r = screadrecord (card, SCESTEIDPDDOCUMENTNR, buff, sizeof(buff), SCRECORDBYRECNR);         SCTESTRET(card->ctx, SCLOGDEBUG_NORMAL, r, "read document number failed");         buff[r] = '\0'; {% endhighlight %}   Double Free in scfilesetsecattr() ================================= In function sc_file_set_sec_attr() in file src/libopensc/sc.c a double free occurs in case sec_attr_len is equal to 0, since the call to realloc() will free file->sec_attr and return NULL. The variable is then freed again in the error handling path.  {% highlight c %}         tmp = (u8 *) realloc(file->secattr, secattrlen);         if (!tmp) {                 if (file->secattr)                         free(file->secattr);                 file->secattr     = NULL;                 file->secattrlen = 0;                 return SCERROROUTOFMEMORY;         } {% endhighlight %}   Double Free in read_file() ========================== In function read_file() in file src/tools/egk-tool.c a double free can be triggered in case two calls to sc_select_file() return a file->size of zero. The first call to realloc() frees the memory, the second frees it again.  {% highlight c %}         len = file ? file->size :         p = realloc(*data, len);         if (!p) {                 goto err;         } {% endhighlight %}   Double free in scpkcs15emuschsminit() ===================================== In function sc_pkcs15emu_sc_hsm_init() in file src/libopensc/pkcs15-sc-hsm.c a double free can occur, since this function can be called twice. The call to realloc() with a size of 0 would free priv->EF_C_DevAut with a second call freeing the already freed memory.  {% highlight c %}                 /* save EFCDevAut for further use */                 ptr = realloc(priv->EFCDevAut, len);                 if (ptr) {                         memcpy(ptr, efbin, len);                         priv->EFCDevAut = ptr;                         priv->EFCDevAut_len = len;                 }                 ptr = efbin; {% endhighlight %}   Unbound Recursion in iaseccselectmf()/iaseccselectfile() ======================================================== Function iasecc_select_file() in file src/libopensc/card-iasecc.c calls iasecc_select_mf() in the same file, which calls iasecc_select_file() again. This can lead to an infinite recursion exhausting the stack.  Timeline ======== Issues found Vendor contacted Vendor reply Technical details provided Private git branch created, fixing started Patched version released: https://github.com/x41sec/OpenSC Advisory released - --  X41 D-SEC GmbH, Dennewartstr. Aachen T: +49 Fax: -9 Unternehmenssitz: Aachen, Amtsgericht Aachen: Geschäftsführer: Markus Vervier -----BEGIN PGP SIGNATURE-----  =/aWX -----END PGP SIGNATURE-----  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      