  oss-security - Re: CVE request: 3 flaws in libobby and libnet6            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [<thread-prev] [thread-next>] [day] [month] [year] [list]  Date: Sun, 30 Oct From: Armin Burgmeier <armin@...ur.net> To: Vasiliy Kulikov <segoon@...nwall.com> Cc: oss-security@...ts.openwall.com, Armin Burgmeier <armin@...39.de>,   Philipp Kern <phil@...39.de> Subject: Re: CVE request: 3 flaws in libobby and libnet6  Hi Vasiliy,  thanks for your report!  I have fixed the issues 1+3 in git [1,2]. It would be great if you could confirm the patches to really fix the issues you raised.  As for the second issue, I do not think it is worth the effort to implement SSL certificate handling in obby. Both net6 and obby are replaced by libinfinity in the current development version of Gobby. libinfinity makes use of SSL certificates.  We would be pleased if you could check for similar flaws in libinfinity though I admit that it is much more code and probably more complicated to analyze.  Cheers, Armin   [1]  [2]   On Sun, at Vasiliy Kulikov wrote: > Hi, >  > 1) the libobby's server checks for users' color collisions before > checking users' passwords.  Any user without password authentication > may check whether a specific color is used by someone.  With knowledge > of person's color preferences he may learn whether a specific person > uses the server.  Also, he may enumerate all default colors and learn > the number of users. >  >     inc/server_buffer.hpp:  >  >     bool basic_server_buffer<Document, Selector>::on_auth() >     { >     ... >         // Check colour >         if(!basic_buffer<Document, Selector>::check_colour(colour) ) >         { >             error = login::ERROR_COLOUR_IN_USE; >             return false; >         } >  >         // Check global password >         if(!m_global_password.empty() ) >         { >             if(global_password != m_global_password) >             { >                 error = login::ERROR_WRONG_GLOBAL_PASSWORD; >                 return false; >             } >         } >     ... >     } >  >  > 2) libobby doesn't check server's SSL certificate and passes the > password in plain text over SSL channel.  All remote clients are > vulnerable to a MITM attack. >  >     • The attacker (A) learns the client's (C) and the server's (S) IP >         addresses and used ports. >     • A breaks the established TCP connection between C and S. >     • A changes the way C's packets with dst = S are routed, resulting >         in all packets from C to S's IP go to A.  The simplest way is >         ARP cache poisoning. >     • A starts listening on the same IP:port as S did. >     • C notices the connection interruption and tries to reconnect to S. >         (Note: if the client is gobby, this step needs user's interaction.) >     • As all C's packets intended for S are routed to A, so, in reality >         C connects to A, not S. >     • C starts SSL session and, as C doesn't check SSL certificate, he >         think it talks to S. >     • A requests C' password. >     • C passes the password in plain text over SSL channel. >  >  > 3) libnet6 doesn't check basic_server::id_counter for integer overflow. > This number is used to distinguish among different users.  An attacker > may open UINT_MAX successive connections and get an identifier of the > already established connection, resulting in the connection hijacking. > On uint is a 32 bit counter, so an attacker should be able to open > connections to complete the attack.  This is a rather big > number: if an attacker may create connections per second, it would > took ~24 days of continuous connection attempts.  However, it is a real > threat for servers with a huge uptime. >  > Thanks, >     Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      