  oss-security - Re: Randomness Attacks Against PHP Applications            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [<thread-prev] [thread-next>] [day] [month] [year] [list]  Date: Sun, 23 Sep From: Solar Designer <solar@...nwall.com> To: George Argyros <argyros.george@...il.com> Cc: oss-security@...ts.openwall.com, Aggelos Kiayias <aggelos@...yias.com>, 	Vladimir Vorontsov <vladimir.vorontsov@...ec.ru>, 	gifts <gifts.antichat@...il.com>, 	Anthony Ferrara <ircmaxell@...il.com>, 	Pierre Joye <pierre.php@...il.com> Subject: Re: Randomness Attacks Against PHP Applications  George,  I watched a video of your USENIX Security talk the other day (after I was done with my experiments with mt_rand() seed cracking, though):  http://www.youtube.com/watch?v=yE0qTTi-_iQ  Thanks.  Shortly before that, I released a faster version of my PHP mt_rand() seed cracker, now down to 1 minute worst case on CPU:  http://download.openwall.net/pub/projects/php_mt_seed/  $ time ./php_mt_seed Found 0, trying - speed seeds per second seed = Found 1, trying - speed seeds per second seed = Found 2, trying - speed seeds per second Found 2  real    user    sys      In one minute of real time (on an CPU, using vectorized fused multiply-add instructions), it found the original seed, another seed that also produces the same mt_rand() output, and it searched the rest of the 32-bit seed space (not finding other matches in this case).  Gifts implemented the same thing in OpenCL:  https://github.com/Gifts/pyphp_rand_ocl https://github.com/Gifts/pyphp_rand_ocl/tree/SpeedyOCL  His SpeedyOCL branch achieves similar performance (and even 10% better than mine in his test of both on a Core on CPUs (with Intel's OpenCL SDK) and several times better performance on GPUs.  On Thu, Sep 20, at George Argyros wrote: > FYI, we have also released some code to exploit such vulnerabilities > about a month ago in github > (https://github.com/GeorgeArgyros/Snowflake).  We hope that this > framework will allow the easier development of exploits for such > vulnerabilities. > The main difference with the code mentioned in the previous posts, is > that it may not always be possible to obtain the first output from > mt_rand() after seeding. For example, many applications only leak > truncated mt_rand() outputs in which case we should really compare > bits of different mt_rand outputs to test whether we found the correct > seed.  Yes.  Your implementation is far more generic.  The way I'd approach this is by limiting the set of possible seeds based on the first mt_rand() output (perhaps with a min-max range, so _many_ seeds will be potentially valid - could be millions, yet significantly fewer than the full 4 billion set).  This can be accomplished almost as quickly as cracking the seed based on an exact mt_rand() output (full 31 bits of it, no min-max range) - that is, in one minute on CPU.  Then slower, but more generic code may be used to filter out the impossible seeds based on further mt_rand() outputs, until there's just one seed value left.  The slowness of that second cracker would not matter much because it'd only need to search a much smaller seed space.  A limitation, though, is that the very first mt_rand() output after seeding must be among those available, even if in truncated form.  If it is not, then more of the state has to be maintained in the initial cracking pass, thereby making it slightly slower.  When the first output is (at least partially) available, we only need 3 state elements, so they're kept in registers nicely.  > For this reason, in our tool the user defines a "hash" function > that expresses any mt_rand dependent output and then we search for a > preimage for this hash function.  That's a generic and curious approach, but I think it's slower than what I described above while not being _more_ generic.  > We also include a python API for this functionalities as well as a > sample exploit for mediawiki Some POCs might indeed help... >  > We will also release the gaussian solver based tool we developed in > order to recover the internal state of mt_rand from its (truncated) > outputs in the following days.  Cool!  > I agree too that education is important. This is something that we > came to an agreement with the PHP team (for example that additional > information is needed on the mt_rand manual). However, as pointed out > nothing has changed yet (the conversations between us and the PHP team > took place in March/April).  Did PHP 5.4's change of session IDs (vs. 5.3's) occur before or after your conversations with them?  > However I think that the specific issue goes beyond education. First > of all, We believe that adding simple exploit mitigations such as > secure seeding in these functions is something that should definitely > happen. Secure seeding is easy to add using randomness from the > operating system and furthermore it will incur a negligible > performance overhead since it would happen only once in the process > lifetime.  Agreed.  > For a more concrete solution I think that the existence of secure > PRNGs is not enough. Even if mt_rand() was producing secure random > numbers we would still be having a lot of vulnerable applications just > from the way this function is used.  Right.  > Just as PHP devs use > session_start() to start a new PHP session there is a need for a > generate_token() function that will return a random token and take > care of providing the necessary level of security for this token.  Perhaps, and this is in line with Anthony Ferrara's work on a new password hashing API for PHP 5.5 (which will eventually obsolete phpass, I guess).  Simpler interfaces that are easier to use correctly than not.  However, a reason why many PHP app devs use mt_rand() and the like is because they want to generate tokens of a certain format, such as to meet a standard.  One such use is crypt() salts, which we're helping eliminate with phpass and then with Anthony Ferrara's new API.  But I guess other uses will remain.  So perhaps that generate_token() function would need to accept arguments and return tokens of different target formats accordingly.  Maybe it should have a format argument similar to that of pack().  Its advantage over separate calls to a PRNG and then to pack() on the PRNG's output would be that it'd keep the distribution uniform.  It is curious how it is often overlooked that simple modulo division may turn a uniform distribution into non-uniform.  Here's an illustration (in case this is news to someone on oss-security):  $ php -r 'for ($n = $i = 0; $i < $i++) { $x = mt_rand(); $n += ($x < } echo "$n\n";' $ php -r 'for ($n = $i = 0; $i < $i++) { $x = mt_rand(); $n += ($x < } echo "$n\n";'  $ php -r 'for ($n = $i = 0; $i < $i++) { $x = mt_rand() % $n += ($x < } echo "$n\n";' $ php -r 'for ($n = $i = 0; $i < $i++) { $x = mt_rand() % $n += ($x < } echo "$n\n";'  First two runs show uniform distribution of mt_rand() outputs themselves (assuming the 0 to 0x7fffffff range).  The other two runs show non-uniform distribution over the 0 to million minus 1 range, after the modulo division by million.  (Values lower than half the maximum suddenly became more common than higher values.  It was before the modulo division, but became afterwards.  The reason is obvious: the original space is not divisible into a whole number of million sub-spaces.)  This is why having separate functions that return a random number and those that process it to the desired format might not be good enough. A single function that does both jobs at once (avoiding the above problem by using a smarter approach) could work better.  Alexander  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      