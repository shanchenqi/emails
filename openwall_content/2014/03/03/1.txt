  oss-security - -- Linux kernel: kvm: mmio_fragments out-of-the-bounds  access            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Mon, 3 Mar From: Petr Matousek <pmatouse@...hat.com> To: oss-security@...ts.openwall.com Cc: Paolo Bonzini <pbonzini@...hat.com>, gleb <gleb@...hat.com>,         Lars Bull <larsbull@...gle.com>, Andrew Honig <ahonig@...gle.com> Subject: -- Linux kernel: kvm: mmio_fragments out-of-the-bounds  access  The problem occurs when the guest performs a pusha with the stack address pointing to an mmio address (or an invalid guest physical address) to start with, but then extending into an ordinary guest physical address. When doing repeated emulated pushes emulator_read_write sets mmio_needed to 1 on the first one.  On a later push when the stack points to regular memory, mmio_nr_fragments is set to 0, but mmio_is_needed is not set to 0.  As a result, KVM exits to userspace, and then returns to complete_emulated_mmio.  In complete_emulated_mmio vcpu->mmio_cur_fragment is incremented.  The termination condition of vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments is never achieved. The code bounces back and fourth to userspace incrementing mmio_cur_fragment past it's buffer.  If the guest does nothing else it eventually leads to a a crash on a memcpy from invalid memory address.  However if a guest code can cause the vm to be destoryed in another vcpu with excellent timing, then kvm_clear_async_pf_completion_queue can be used by the guest to control the data that's pointed to by the call to cancel_work_item, which can be used to gain execution.  Introduced by:  Upstream patch:  Acknowledgements:  Red Hat would like to thank Lars Bull of Google for reporting this issue.  --  Petr Matousek / Red Hat Security Response Team PGP: AF16 F9AF  77CA  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      