  oss-security - Re: Vendor adoption of PIE oss-security            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [<thread-prev] [thread-next>] [day] [month] [year] [list]  Date: Sun, 16 Feb From: "CERT(R) Coordination Center" <cert@...t.org> To: Solar Designer <solar@...nwall.com> CC: oss-security@...ts.openwall.com,         "CERT(R) Coordination Center" <cert@...t.org> Subject: Re: Vendor adoption of PIE oss-security  -----BEGIN PGP SIGNED MESSAGE----- Hash: SHA1   Hi Alexander,   Solar Designer <solar@...nwall.com> writes: > >With bzip2, the irony is that most(?) distros incur this performance >impact anyway, because most processing occurs in libbz2, which is >typically linked to bzip2 dynamically, and the dynamic library is built >as PIC (should be same performance impact as PIE).  Yeah, this is something that I was thinking about early on in my research here.  There seems to be reluctance to adopt PIE in a more widespread manner, yet it seems that real-world applications (as opposed to synthetic benchmarks) are doing plenty of work in DSOs, so therefore are *already* feeling the PIC performance hit.  e.g. the Ogg Vorbis example from Wikipedia: <http://en.wikipedia.org/wiki/File:Ogg_vorbis_libs_and_application_dia.svg> At least for this particular case, it looks like libs are where the work happens, and the program is just a frontend.  >I'd expect nearly zero performance impact for  The paper says >there's "average overhead of and a geometric mean of but >given this arch's PC-relative addressing it is unclear to me where the >impact is coming from.  Having manually changed some assembly >code in JtR -jumbo from absolute to PC-relative addressing, I saw no >performance impact at all (although I tested only on a handful of CPU >types) - and this is for CPU-bound code.  Is gcc doing something >dumb, or are there CPUs where PC-relative addressing has performance >impact, or is it indirect effect via code size increase (did it >increase? why? IIRC, it didn't for me), or was the test flawed?   Based on some responses I've received so far, I'm getting the impression that the current gcc toolchain perhaps isn't set up in a way to to PIE in an optimal manner.  But I don't have enough low-level understanding of this stuff to confirm or deny that.  See in particular:   Thank you,    Will Dormann  ============================= Vulnerability Analyst CERT Coordination Center Fifth Ave. Pittsburgh, PA =============================  -----BEGIN PGP SIGNATURE----- Version: GnuPG (GNU/Linux)  =FfdX -----END PGP SIGNATURE-----  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      