  oss-security - Potential security bugs in "eapmd5pass" software (3 CVE IDs)            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Mon, 31 Jul From: Dhiru Kholia <dhiru.kholia@...il.com> To: oss-security@...ts.openwall.com Subject: Potential security bugs in "eapmd5pass" software (3 CVE IDs)  Summary -------  This report describes 4 bugs in the eapmd5pass software package as shipped with Kali Linux. Bug 1 is a regular functionality related bug. The other 3 bugs are memory safety bugs that can be triggered remotely.  I found these bugs with the help of libFuzzer.  The worst case security impact of these three memory safety bugs seems to be limited to a remote denial of service (eapmd5pass crash and loss of intended functionality) under certain circumstances.  Reproducers are available at https://github.com/kholia/reproducers URL.   Steps to reproduce ------------------  http://www.willhackforsushi.com/?page_id=67  https://tools.kali.org/wireless-attacks/eapmd5pass  Add "-fsanitize=address" to Makefile and build eapmd5pass.  After building eapmd5pass with "make", ensure that ASan is enabled.  $ ldd ./eapmd5pass | grep asan 	libasan.so.3 =>   Bug 1 -----  $ ./eapmd5pass -r brad.eaptest.cap -w wordlist eapmd5pass - Dictionary attack against EAP-MD5 Error placing pcap interface in non-blocking mode. pcap_setnonblock: No such file or directory  It seems eapmd5pass has a non-security bug which causes it to fail to process .pcap files. Here is a patch to fix this problem,  diff --git a/eapmd5pass.c b/eapmd5pass.c index --- a/eapmd5pass.c +++ b/eapmd5pass.c @@ @@ int main(int argc, char *argv[])         }          /* Set non-blocking */ -       if (pcap_setnonblock(p, PCAP_DONOTBLOCK, errbuf) != 0) { +       if (!strlen(pcapfile) > 0 && pcap_setnonblock(p, PCAP_DONOTBLOCK, errbuf) != 0) {                 fprintf(stderr, "Error placing pcap interface in non-blocking "                         "mode.\n");                 perror("pcap_setnonblock");   After applying this patch,  $ ./eapmd5pass -r brad.eaptest.cap -w wordlist eapmd5pass - Dictionary attack against EAP-MD5 Collected all data necessary to attack password for "brad-foundstone", starting attack. User password is "bradtest". 1 passwords in seconds: passwords/second.   Bug 2 -----  $ ./eapmd5pass -r -w wordlist  AddressSanitizer: heap-buffer-overflow on address at pc bp sp READ of size 1 at thread T0     #0 in assess_packet     #1 in pcap_offline_read     #2 in main     #3 in __libc_start_main     #4 in _start  The "offset" variable is -2 and "if == 1 && == 1)" line is dereferencing out-of-bounds memory.  Here is a fix for ignoring invalid "offset" values,  diff --git a/eapmd5pass.c b/eapmd5pass.c index --- a/eapmd5pass.c +++ b/eapmd5pass.c @@ @@ void assess_packet(char *user, struct pcap_pkthdr *h, u_int8_t *pkt)          dot11buf = (pkt + offset);  +       if (offset < 0) +               return; +         pcount++; /* Global packet counter */         if (__verbosity > 2) {                 printf("Checking Frame: %ld....\n",pcount);   Affected Component: Function "assess_packet" in eapmd5pass.c  Affected Product Code Base: eapmd5pass - 1.4  Attack Type: Remote  Impact Denial of Service: true  Attack Vectors: Network: processing crafted network traffic, Local: opening a crafted .pcap file.  The Common Vulnerabilities and Exposures (CVE) project has assigned the ID to this issue.  Summary: An out-of-bounds read flaw related to was found in the way eapmd5pass handled processing of network packets. A remote attacker could potentially use this flaw to crash the eapmd5pass process under certain circumstances by generating specially crafted network traffic.   Bug 3 -----  $ ./eapmd5pass -r -w wordlist ================================================================= AddressSanitizer: heap-buffer-overflow on address at pc bp sp READ of size 1 at thread T0     #0 in assess_packet     #1 in pcap_offline_read     #2 in main     #3 in __libc_start_main     #4 in _start   This invalid read occurs on "if (dot2hdr->dsap != || dot2hdr->ssap != line. The packet length is too small, and it isn't validated before the packet is consumed.  Here is a patch to fix this problem,  index --- a/eapmd5pass.c +++ b/eapmd5pass.c @@ @@ void assess_packet(char *user, struct pcap_pkthdr *h, u_int8_t *pkt)          dot11buf = (pkt + offset);  +       /* Check minimum packet length */ +       if (offset + sizeof(struct dot11hdr) > h->caplen) +               return; +         pcount++; /* Global packet counter */         if (__verbosity > 2) {                 printf("Checking Frame: %ld....\n",pcount);  Affected Component: Function "assess_packet" in eapmd5pass.c  Note: Similar validation checks should be added at other places in this function.  The Common Vulnerabilities and Exposures (CVE) project has assigned the ID to this issue. This issue is different from (Bug 2).  Summary: An out-of-bounds read flaw related to was found in the way eapmd5pass handled processing of network packets. A remote attacker could potentially use this flaw to crash the eapmd5pass process under certain circumstances by generating specially crafted network traffic.   Bug 4 -----  $ ./eapmd5pass -r -w wordlist AddressSanitizer: negative-size-param: (size=-1)     #0      #1 in extract_eapusername     #2 in extract_eapusername     #3 in assess_packet     #4 in pcap_offline_read     #5 in main     #6 in __libc_start_main     #7 in _start   This crash occurs in "memcpy(em->username, (eap+5), usernamelen)" line. "usernamelen" is negative at this point in the execution flow.  This bug can be reliably used to crash eapmd5pass (non-ASan and ASan builds) remotely.  Here is a patch to fix this problem,  diff --git a/eapmd5pass.c b/eapmd5pass.c index --- a/eapmd5pass.c @@ @@ int extract_eapusername(uint8_t *eap, int len, struct eapmd5pass_data *em)         /* 5 bytes for EAP header information without identity information */         usernamelen = (eaplen - 5);  +       if (usernamelen < 0) +               return 1; +         usernamelen = (eaplen > sizeof(em->username))                         ? sizeof(em->username) : usernamelen;         memcpy(em->username, (eap+5), usernamelen);   Affected Component: Function "extract_eapusername" in eapmd5pass.c  The Common Vulnerabilities and Exposures (CVE) project has assigned the ID to this issue.  Summary: An out-of-bounds read and write flaw was found in the way eapmd5pass handled network traffic. A remote attacker could potentially use this flaw to crash the eapmd5pass process by generating specially crafted network traffic.  --  Dhiru  View attachment "combined-fixes.diff" of type "text/plain" bytes)  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      