  oss-security - minicom and prl-vzvncserver escparms[] buffer overflow            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Tue, 18 Apr From: Solar Designer <solar@...nwall.com> To: oss-security@...ts.openwall.com Cc: Adam Lackorzynski <adam@...inf.tu-dresden.de> Subject: minicom and prl-vzvncserver escparms[] buffer overflow  Hi,  This is to announce a vulnerability that has just been fixed in minicom released earlier today, and that had been found and fixed in derived code in prl-vzvncserver (a Virtuozzo 7 component) earlier this year.  minicom is available for download at:  https://alioth.debian.org/projects/minicom/  The main bug is that in minicom's escparms[] is declared as:  static void (*vt_keyb)(int, int);/* Gets called for NORMAL/APPL switch. */ static void (*termout)(const char *, int);/* Gets called to output a string. */  static int escparms[8];         /* Cumulated escape sequence. */ static int ptr;                 /* Index into escparms array. */ static long vt_tabs[5];         /* Tab stops for max. = columns. */  but is filled as:    /* See if a number follows */   if (c >= '0' && c <= '9') {     escparms[ptr] = 10*escparms[ptr] + c - '0';     return;   }   /* Separation between numbers ? */   if (c == ';') {     if (ptr < 15)       ptr++;     return;   }  Notice the 8 vs. 15 (meaning 16 elements) discrepancy.  At least in the Fedora 23 package of minicom, this lets me adjust or replace the termout function pointer.  If the variables were put in .bss in the other order (perhaps by a different compiler), then ptr could be overwritten, which is likely also exploitable.  Here's how to reproduce:  mkfifo fifo gdb /usr/bin/minicom  (gdb) r -oD fifo Starting program: /usr/bin/minicom -oD fifo  On another terminal:  echo -ne > fifo  Then press Enter in minicom, and:  Program received signal SIGSEGV, Segmentation fault.                                                     in v_termout () (gdb) disass Dump of assembler code for function v_termout: [...]    <+70>:	mov    %r12d,%esi    <+73>:	mov    %rbp,%rdi    <+76>:	pop    %rbp    <+77>:	pop    %r12 => <+79>:	jmpq          #    <+85>:	nopl   (%rax)    <+88>:	mov    $0xa,%edi    <+93>:	callq  <vt_out>    <+98>:	jmp    <v_termout+52> End of assembler dump. (gdb) x/2x  As you can see, I am able to control the address to branch to.  Moreover, on typical 64-bit little-endian there's partial ASLR (PIE) bypass due to ability to keep most significant 32 bits of the function pointer intact.  Thus, this bug likely allows for remote code execution.  In the PoC above, the decimal numbers (corresponding to the 32-bit pointer halves) include leading zeroes (for exactly 32 digits in each number) in order to completely shift out, one bit at a time, the previous contents of the v_termout pointer.  This works due to the multiplier 10 including 2 as a factor.  The fix included in minicom is simply:  -	if (ptr < 15) +	if (ptr < 7)  (I guess a later code revision could introduce a macro for this array's size, or determine the array size by dividing two sizeof's.)  I'd like to thank Adam Lackorzynski, CC'ed here, for producing the new minicom release promptly and in time for this announcement.  I first found the bug during Openwall's security audit of the Virtuozzo 7 product, which contains derived downstream code in its prl-vzvncserver component.  The corresponding Virtuozzo 7 fix is:   We would like to thank the Virtuozzo company for funding the effort.  In prl-vzvncserver, the escparms[] overflow wasn't obviously exploitable due to different nearby variables:  static int esc_s = 0;  #define ESC 27  static unsigned char vt_fg;             /* Standard foreground color. */ static unsigned char vt_bg;             /* Standard background color. */  static int escparms[8];         /* Cumulated escape sequence. */ static int ptr;                 /* Index into escparms array. */  static short newy1 = 0;         /* Current size of scrolling region. */ static short newy2 = 23;  but it also was clearly triggerable, as seen in an ASan-enabled build:  ERROR: AddressSanitizer: global-buffer-overflow on address at pc bp sp READ of size 4 at thread T0     #0     #1     #2     #3 is located 32 bytes to the left of global variable 'vt_bg of size 1   'vt_bg is ascii string '' is located 0 bytes to the right of global variable 'escparms of size 32   'escparms is ascii string ''  In VzLinux's build of prl-vzvncserver as of when this issue was discovered, the following variables happened to follow escparms[] and were close enough: esc_s, vt_fg, vt_bg.  Changing esc_s is benign - for valid values, it could as well be done directly (with the proper escapes), and the invalid values are unused.  Changing vt_fg or/and vt_bg might have some other ill effects, although we'd expect only out of bound reads, so at worst crashes.  That's because prl-vzvncserver's console.c defines only a 16 entry colourMap.  In LibVNCServer, that table appears to be used to initialize related tables with bigger elements, but those inherit the size of 16.  Out of bound reads from those tables in LibVNCServer might be triggered through having the color numbers above 15 written to the frameBuffer (which console.c will happily do once we overwrote vt_fg or/and vt_bg with such values) and then accessed via certain parts of LibVNCServer's code.  We did not actually test for these potential ill effects of overwriting vt_fg or/and vt_bg.  Regardless, it is inappropriate and unsafe to rely on a specific memory layout of a binary build, and of course the issue was promptly fixed.  Some other issues inherited from minicom likely were exploitable in prl-vzvncserver - namely, incomplete validation of cursor coordinates in  In minicom itself, there's further validation in mc_*() functions.  In prl-vzvncserver, there was no such validation in its equivalent functions - and there are now more commits in the above repository fixing those issues (besides the commit referenced above). Specifically, a likely exploitable code path was triggered e.g. with:  echo -ne  but this appears to do little against minicom.(*)  In fact, I ran a rather extensive set of escape sequences against minicom, which triggered no other crashes besides the escparms[] buffer overflow reported here.  (*) Formally speaking, the code is also triggering C's undefined behavior when it allows signed integers to overflow.  In practice, so far compilers only make use of compile-time detectable UB of this kind (such as to drop the UB-triggering code as an optimization, since they are allowed to).  One change minicom could make later is switch to using unsigned types for escparms and coordinates.  But we'd need to carefully review all uses for that, in case any place relies on a value temporarily becoming negative and on checking for that.  prl-vzvncserver was using int and switched to "unsigned short". This may be weird, but it actually helps avoid integer overflows in calculations as inputs to calculations become more limited whereas intermediate results get promoted to int.  Besides minicom and prl-vzvncserver, I managed to identify just one other project reusing this code (and also containing the issues), but it's obscure (likely unused):   I did not bother notifying this project in advance (putting the information at unjustified risk), but I intend to notify it now.  For those into CVEs: is only for the escparms[] buffer overflow (in all projects reusing this code), not for other issues casually mentioned in here (even if some of them had higher impact on prl-vzvncserver).  Those other issues have no CVE IDs.  Timeline:  - bug found in prl-vzvncserver - report to Virtuozzo - fix committed in Virtuozzo (became part of an update later) - report to minicom - initial heads-up and CVE request via distros@vs, no detail - detail shared with distros@vs - fixed minicom release, public disclosure  Alexander  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      