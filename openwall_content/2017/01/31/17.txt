  oss-security - Bugs fixed in libevent            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [thread-next>] [day] [month] [year] [list]  Date: Tue, 31 Jan From: Leo Famulari <leo@...ulari.name> To: oss security list <oss-security@...ts.openwall.com> Subject: Bugs fixed in libevent  Libevent fixed three bugs that may have security implications. Can you assign CVE IDs as appropriate?  Below I quote from the upstream bug reports:  1) libevent dns remote stack overread vulnerability ------ the name_parse() function in libevent's DNS code is vulnerable to a buffer overread.          if (cp != name_out) {             if (cp + 1 >= end) return -1;             *cp++ = '.';         }         if (cp + label_len >= end) return -1;         memcpy(cp, packet + j, label_len);         cp += label_len;         j += label_len;  No check is made against length before the memcpy occurs. [...] azat closed this in on Feb 1, ------  2) libevent (stack) buffer overflow in evutil_parse_sockaddr_port() ------ in evutil.c:      char ... ...     cp = strchr(ip_as_string, ':');     if (*ip_as_string == '[') {         int len;         if (!(cp = strchr(ip_as_string, ']'))) {             return -1;         }         len = (int) ( cp-(ip_as_string + 1) );         if (len > (int)sizeof(buf)-1) {             return -1;         }         memcpy(buf, ip_as_string+1, len);  Length between '[' and ']' is cast to signed 32 bit integer on line Is the length is more than (INT_MAX), len will hold a negative value. Consequently, it will pass the check at line Segfault happens at line [...] azat closed this in on Feb 1, ------  3) out-of-bounds read in search_make_new() ------ The DNS code of Libevent contains this rather obvious OOB read:  static char * search_make_new(const struct search_state *const state, int n, const char *const base_name) {     const size_t base_len = strlen(base_name);     const char need_to_append_dot = base_name[base_len - 1] == '.' ? 0 : 1;  If the length of base_name is 0, then line reads 1 byte before the buffer. This will trigger a crash on ASAN-protected builds. [...] azat closed this in on Mar 24, ------  Download attachment "signature.asc" of type "application/pgp-signature" bytes)  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      