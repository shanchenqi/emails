  oss-security - and Exploitable buffer overflows in apk  (Alpine's package manager)            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Sun, 25 Jun From: Ariel Zelivansky <ariel@...stlock.com> To: oss-security@...ts.openwall.com Subject: and Exploitable buffer overflows in apk  (Alpine's package manager)  Hello,  I'm a security researcher at Twistlock. I've recently found two heap overflow vulnerabilities in apk (the package manager of Alpine Linux). With either of these vulnerabilities I was able to achieve remote code execution from a naive call to "apk update" (under some restrictions - i.e. no ASLR). MITRE has assigned and for these issues.  I privately disclosed the issue with Timo TerĂ¤s (apk's maintainer) and he had already released fixes to solve these issues. The fixes are available from apk-tools and and all alpine repositories back to 3.2-stable are updated with it (3.3-stable is actually the latest supported version but Timo updated 3.2 too).  I've discussed the possibility of publicly disclosing the vulnerabilities with Timo and he agreed to have this advisory published. A blog post with similar details is to be posted on Twistlock's blog in the following days.  Find below the original disclosure (plus a reasonable disclaimer):  1. blob_realloc --------------- The function blob_realloc accepts a pointer to apk_blob_t and a size - of type int - and resizes the underlying buffer to size using realloc. [0] Before calling realloc, it compares the current buffer size to the requested size. If it is bigger or equal, it does not call realloc and returns 0. See line  if (b->len >= newsize) return 0;  This is generally OK as long as the code around it also expects size to be a signed int.  1.1 longname overflow -------------------------------------  The function apk_tar_parse is used to parse a tar stream. One of the tar block types is a longname (or "GNU long name extension", see line Consult the tar format standard to learn about block types. [1] When dealing with a longname block apk_tar_parse calls blob_realloc with the size read from the block header plus one byte for null terminator. See line  if (blob_realloc(&longname, entry.size+1)) goto err_nomem;  After the call to blob_realloc, the name buffer is copied from the stream to the allocated buffer. See lines  entry.name = longname.ptr; is->read(is, entry.name, entry.size); entry.name[entry.size] = 0;  When the stream is a gzipped tar (tar.gz) such as with update files for apk, the read function of the stream results in gzi_read (gunzip.c:40). gzi_read accepts a size of size_t. This is significant because size_t is unsigned by definition. So let's see what happens when we have a negative size - the call to blob_realloc will not do anything and return 0 (the buffer pointer is not changed), and later the call to gzi_read will attempt to copy a huge amount of bytes - i.e. a number from to 0xffffffff bytes. If the result buffer (the allocated buffer) is not null, the bytes will be read from the gzipped stream, resulting in an overflow of that buffer.  Versions affected -----------------  The call to blob_realloc was added in (from commit However it seems that all versions before it (from the first commit to archive.c) may be vulnerable to an integer overflow that could lead to a buffer overflow after a failing call to malloc... However vulnerabilities in older versions is beyond the scope of this advisory.  1.2 pax header overflow ---------------------------------------  The latter is also possible with the call to blob_realloc with a block type of a pax header. See line  if (blob_realloc(&pax, (paxlen + & goto err_nomem;  A buffer overflow in the following call to is->read may be exploited in the same fashion.  Versions affected -----------------  Any version from (same commit as 1.1. All versions before that are not vulnerable because pax headers were not parsed).  2. Impact --------- There are numerous ways in which these buffer overflows could be exploited. To demonstrate the impact, I've crafted a malicious tar.gz file (specifically, an APKINDEX.tar.gz file [2]) that leads the code to the buffer overflow copy, in which a struct on the heap that has a function pointer is overridden. The execution is then lead to a call to `system` with a string that I control as a parameter.  To put it simply, a man in the middle attacker could result in code execution when a call to apk update is made. At a later date, I may decide to release the proof of concept with the details of such an attack.  It is also worth noting that even if the call to read failed, in some scenarios it may also be possible to use the null byte write (line to write to specific addresses. This could be dangerous especially on 32-bit (in 64-bit the addresses are too high to actually reach anything significant such as the stack).  As another anecdote, I originally discovered this issue from a crash by a null deference. When fuzzing, I used apk_tar_parse with the stream from a file and not from the gzip stream. Unlike gzip_read, fdi_read (io.c:71) calls lseek when the target buffer pointer is null. And it fails when there is not enough data on the file (gzip just reads whatever it has before failing). This resulted in a scenario where handle_extended_header is called, and then in apk_blob_pull_uint a null deference occurred if the pax buffer was never allocated. [3] I have not assigned a CVE ID for this issue because I did not reach a scenario where apk_tar_parse gets a file stream, besides my fuzzer, and since the previous CVE IDs can relate to the same issue.  2.1 Attack examples -------------------  Disclaimer: As a perquisite to the examples below, the attacker must be able to fully predict the memory layout of the execution.  1. Remote shell by `apk update`: https://asciinema. 2. Remote shell from within `docker build`: https://asciinema.org/  3. Use https ------------  As a general suggestion, consider fully enforcing the use of HTTPS in your CDN servers (and in the /etc/apk/repositories file). The impact of these vulnerabilities would be significantly lower if a MITM attack was infeasible (or at least difficult). [4]  Credits -------  All bugs were found with the use of afl-fuzz.  Footnotes ---------  [0] All line references are from the apk branch of [1] http://www.gnu.org/software/tar/manual/html_node/Standard.html [2] https://wiki.alpinelinux.org/wiki/Apkindex_format [3] This is still achievable in theory if we have a huge stream bytes) so gzip reads bytes and then moves on to the call to handle_extended_header, but the size is converted to off_t as explained and it is 64-bit and I'm unlikely to hold more than bytes in memory... at least in the meantime. [4] Also consider certificate/PK pinning https://www.owasp.org/ index.php/Certificate_and_Public_Key_Pinning   Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      