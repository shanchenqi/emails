  oss-security - exiv2: multiple memory safety issues            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [thread-next>] [day] [month] [year] [list]  Date: Fri, 30 Jun From: Hanno Bรถck <hanno@...eck.de> To:   "oss-security@...ts.openwall.com" <oss-security@...ts.openwall.com> Subject: exiv2: multiple memory safety issues  Hi,  I'm reporting three issues here in exiv2, a parser libary for image metadata. These are only examples, exiv2 is full of memory safety bugs that can trivially be found by running afl with asan for a few hours.  Minified sample files for all three example bugs attached.  I have not reported thoses issues upstream. When I previously tried to report bugs in exiv2 found via fuzzing the upstream author made it clear to me that he has little interest in fixing those issues and doesn't consider his software suitable to parse defect files (which basically means it's unsuitable for untrusted input). The discussion can be read here [1]. (the page is sometimes not available, searching for it in the google cache usually works though)  exiv2 is to my knowledge used by the major Linux Desktops GNOME and KDE. I'll also inform their security teams. I leave it up to Linux distros how to handle this, but it certainly is problematic that a crucial parser used by major desktop applications is not interested in fixing potential security issues.  [1]   ----------------  Heap overflow (write) in tiff parser  A malformed tiff file can cause a one byte heap overflow in exiv2.  Stack trace:  AddressSanitizer: heap-buffer-overflow on address at pc bp sp WRITE of size 1 at thread T0     #0 in Exiv2::ul2Data(unsigned char*, unsigned int, Exiv2::ByteOrder)     #1 in long Exiv2::toData<unsigned int>(unsigned char*, unsigned int, Exiv2::ByteOrder)     #2 in Exiv2::ValueType<unsigned int>::copy(unsigned char*, Exiv2::ByteOrder) const     #3 in Exiv2::Exifdatum::copy(unsigned char*, Exiv2::ByteOrder) const     #4 in Exiv2::TiffImage::readMetadata()     #5 in Action::Print::printSummary()     #6 in Action::Print::run(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)     #7 in main     #8 in __libc_start_main     #9 in _start  is located 0 bytes to the right of 1-byte region allocated by thread T0 here:     #0 in operator new[](unsigned long)     #1 in Exiv2::DataBuf::alloc(long)  ----------------  Heap out of bounds read in jp2 / parser  A malformed file causes a (large) out of bounds read.  Stack trace:  AddressSanitizer: heap-buffer-overflow on address at pc bp sp READ of size at thread T0     #0 in __asan_memcpy     #1 in Exiv2::Jp2Image::readMetadata()     #2 in Action::Print::printSummary()     #3 in Action::Print::run(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)     #4 in main     #5 in __libc_start_main     #6 in _start  is located 0 bytes to the right of region allocated by thread T0 here:     #0 in operator new[](unsigned long)     #1 in Exiv2::DataBuf::DataBuf(long)     #2 in Exiv2::Jp2Image::readMetadata()     #3 in Action::Print::printSummary()     #4 in Action::Print::run(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)     #5 in     __libc_start_main  ----------------  Stack out of bounds read in webp parser  A malformed webp file causes a six bytes stack out of bounds read.  Stack trace:  AddressSanitizer: stack-buffer-overflow on address at pc bp sp READ of size 6 at thread T0     #0 in __interceptor_memcmp.part.76     #1 in Exiv2::WebPImage::getHeaderOffset(unsigned char*, long, unsigned char*, long)     #2 in Exiv2::WebPImage::decodeChunks(unsigned long)     #3 in Exiv2::WebPImage::readMetadata()     #4 in Action::Print::printSummary()     #5 in Action::Print::run(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)     #6 in main     #7 in __libc_start_main     #8 in _start  Address is located in stack of thread T0 at offset in frame     #0 in Exiv2::WebPImage::decodeChunks(unsigned long)    This frame has 13 object(s):     [32, 36) 'size_buff' (line     [48, 64) 'payload' (line     [80, 84) 'size_buf' (line     [96, 'size_buf48' (line     'size_buf_w' (line     'size_buf_h' (line     (line     (line     (line <== Memory access at offset overflows this variable     (line     'xmpData' (line     'temp.lvalue'     HINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext       (longjmp and C++ exceptions *are* supported)  --  Hanno Bรถck https://hboeck.de/  mail/jabber: hanno@...eck.de GPG:  Download attachment "exiv2-poc.tar.gz" of type "application/gzip" bytes)  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      