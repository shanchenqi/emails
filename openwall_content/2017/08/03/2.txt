  oss-security - kernel: inotify: a race between  inotify_handle_event() and sys_rename()            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [thread-next>] [day] [month] [year] [list]  Date: Thu, 3 Aug (EDT) From: Vladis Dronov <vdronov@...hat.com> To: oss-security@...ts.openwall.com Cc: fulldisclosure@...lists.org, bugtraq@...urityfocus.com Subject: kernel: inotify: a race between  inotify_handle_event() and sys_rename()  Hello,  A race condition was found in Linux kernel present since upto including. The race happens between threads of inotify_handle_event() and vfs_rename() while running the rename operation against the same file. The next slab data or the slab's free list pointer can be corrupted with attacker-controlled data as a result of the race.  The researchers of this flaw are Fan Wu and Shixiong Zhao from a research group supervised by Dr. Heming Cui of the Department of Computer Science, The University of Hong Kong. Thanks to Rui Gu and Prof. Junfeng Yang from Columbia University for tools and suggestions.  References:      An upstream patch:   So as for the flaw itself.  There is quite easily reached race condition between inotify_handle_event() and sys_rename(). A rename thread can change the dentry name before an fsnotify thread is copying the dentry name but after a memory for this is allocated:  CPU 1                          CPU 2  fsnotify()   inotify_handle_event(.., file_name)     strlen(file_name)  // file_name is "foobar"     alloc_len += len + 1;     event = kmalloc(alloc_len, GFP_KERNEL); // 7 bytes for the file_name                                 sys_rename()                                  __d_move() [in fs/dcache.c]                                    copy_name()                                    // rename to "foobar_lol_kek_u_pwned"      strcpy(event->name, file_name);     // now file_name points to "foobar_lol_kek_u_pwned"     // but there is a space only for "foobar\0"     // the next slab or slab's *freelist is corrupted with user controlled data  There is a working exploit allowing privileges escalation in the wild for 32 bit kernels. We are unaware of such exploit for 64 bit kernels, but these are affected by this race too and we believe such an exploit could exist.  The result of exploiting the flaw is modified data after the slab, which can be the next slab data, freelist pointer or something else (if the slab is the last one in the cache).  The slab corruption caused by the exploit or the reproducer cat be easily seen with "slub_debug=FZ" kernel parameter. The following log indicates a write beyond the allocated slab, in this case a write to the slab's red zone:  [  ============================================================================= [  BUG kmalloc-64 (Not tainted): Redzone overwritten [  ----------------------------------------------------------------------------- [  Disabling lock debugging due to kernel taint [  INFO: First byte instead of 0xcc [  INFO: Slab objects=51 used=23 [  INFO: Object [  [  Bytes b4 cc cc cc cc cc cc cc cc 00 00 00 00 00 00 00 00  ................ [  Object b0 44 b5 bb 00 88 ff ff b0 44 b5 bb 00 88 ff ff  .D.......D...... [  Object b8 78 62 bb 00 88 ff ff 20 00 00 08 00 00 00 00  .xb..... ....... [  Object 01 00 00 00 00 00 00 00 01 00 00 00 61 61 61 61  ............aaaa [  Object 33 32 31 30 33 32 31 30 33 32 31 30 33 32 31 30  [  Redzone 33 32 31 30 33 32 31 30                          [  Padding 00 00 00 00 00 00 00 00                          ........ [  CPU: 2 PID: Comm: inotify Tainted: G    B          ------------   #1 [  Hardware name: QEMU Standard PC + PIIX, BIOS [   [   [   [  Call Trace: [   [   [   [   [   [   ? [   ? [   ? [   [   ? [   ? [   ? [   [   [   [   [   ? [   [   [   ? [   [  FIX kmalloc-64: Restoring  Best regards, Vladis Dronov | Red Hat, Inc. | Product Security Engineer  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      