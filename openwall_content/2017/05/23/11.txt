  oss-security - autotrace: multiple vulnerabilities (The autotrace nightmare)            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Tue, 23 May From: "Agostino Sarubbo" <ago@...too.org> To: "oss-security@...ts.openwall.com" <oss-security@...ts.openwall.com> Subject: autotrace: multiple vulnerabilities (The autotrace nightmare)  Description: autotrace is a program for converting bitmaps to vector graphics.  Time ago I tried to fuzz autotrace, but the first attempt resulted in a crash-by-default so I was unable to complete the task. See â autotrace: heap-based buffer overflow in pstoedit_suffix_table_init (output-pstoedit.c) for more info about. Some days ago I noticed that the debian team patched the mentioned issue ( you can blame them for the following you will see đ ), so I took the patch and I started the job. Iâm sure there are  duplicates, or better to say, issues that have the same root cause. But for completeness Iâm providing all stacktraces/testcases. Since we applied several patches, Iâm providing the tarball as well, to verify the lines where the faults happen. There are enough issues to kill the package from each repository since the latest upstream release was about 15 years ago.  Some details to avoid to repeat them multiple times. â reproducible with: autotrace $FILE â affected version: â Fixed version: N/A â Commit fix: N/A  AddressSanitizer: heap-buffer-overflow on address at pc bp sp                                                                          WRITE of size 1 at thread T0                                                                                                                                                                            #0 in pnm_load_ascii                                                                                            #1 in input_pnm_reader                                                                                           #2 in at_bitmap_read                                                                                            #3 in main                                                                                                                 #4 in __libc_start_main                                                                                             #5 in _init                                                                                                                                                                                                                                                                                                                                                                                is located 0 bytes to the right of 1-byte region                                                                                                                    allocated by thread T0 here:                                                                                                                                                                                           #0 in calloc                                                                               #1 in at_bitmap_init                                                                                             #2 in input_pnm_reader                                                                                          #3 in at_bitmap_read                                                                                            #4 in main                                                                                                                 #5 in __libc_start_main SUMMARY: AddressSanitizer: heap-buffer-overflow in pnm_load_ascii Reproducer: CVE:  #########################################  AddressSanitizer: heap-buffer-overflow on address at pc bp sp READ of size 1 at thread T0     #0 in pnm_load_raw     #1 in input_pnm_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  is located 0 bytes to the right of 30-byte region allocated by thread T0 here:     #0 in calloc     #1 in at_bitmap_init     #2 in input_pnm_reader     #3 in at_bitmap_read     #4 in main     #5 in __libc_start_main  SUMMARY: AddressSanitizer: heap-buffer-overflow in pnm_load_raw Reproducer: CVE:  #########################################  AddressSanitizer: heap-buffer-overflow on address at pc bp sp WRITE of size 1 at thread T0     #0 in pnm_load_rawpbm     #1 in input_pnm_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  is located 0 bytes to the right of region allocated by thread T0 here:     #0 in calloc     #1 in at_bitmap_init     #2 in input_pnm_reader     #3 in at_bitmap_read     #4 in main     #5 in __libc_start_main  SUMMARY: AddressSanitizer: heap-buffer-overflow in pnm_load_rawpbm Reproducer: CVE:  #########################################  AddressSanitizer: SEGV on unknown address (pc bp sp T0) signal is caused by a READ memory access.     #0 in GET_COLOR     #1 in is_outline_edge     #2 in next_point     #3 in find_one_outline     #4 in find_outline_pixels     #5 in at_splines_new_full     #6 in main     #7 in __libc_start_main     #8 in _init  AddressSanitizer can not provide additional info. SUMMARY: AddressSanitizer: SEGV in GET_COLOR Reproducer: CVE:  #########################################  AddressSanitizer: SEGV on unknown address (pc bp sp T0) signal is caused by a READ memory access. address points to the zero page.     #0 in input_pnm_reader     #1 in at_bitmap_read     #2 in main     #3 in __libc_start_main     #4 in _init  AddressSanitizer can not provide additional info. SUMMARY: AddressSanitizer: SEGV in input_pnm_reader Reproducer: CVE:  #########################################  AddressSanitizer: SEGV on unknown address (pc bp sp T0) signal is caused by a WRITE memory access. address points to the zero page.     #0 in pnm_load_ascii     #1 in input_pnm_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  AddressSanitizer can not provide additional info. SUMMARY: AddressSanitizer: SEGV in pnm_load_ascii Reproducer: CVE:  #########################################  AddressSanitizer: SEGV on unknown address (pc bp sp T0) signal is caused by a WRITE memory access. address points to the zero page.     #0 in pnm_load_ascii     #1 in input_pnm_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  AddressSanitizer can not provide additional info. SUMMARY: AddressSanitizer: SEGV in pnm_load_ascii Reproducer: CVE:  #########################################  AddressSanitizer: SEGV on unknown address (pc bp sp T0) signal is caused by a WRITE memory access. address points to the zero page.     #0      #1 in __GI__IO_file_xsgetn     #2 in fread     #3 in pnm_load_raw     #4 in input_pnm_reader     #5 in at_bitmap_read     #6 in main     #7 in __libc_start_main     #8 in _init  AddressSanitizer can not provide additional info. SUMMARY: AddressSanitizer: SEGV Reproducer: CVE:  #########################################  AddressSanitizer: SEGV on unknown address (pc bp sp T0) signal is caused by a WRITE memory access. address points to the zero page.     #0 in pnm_load_rawpbm     #1 in input_pnm_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  AddressSanitizer can not provide additional info. SUMMARY: AddressSanitizer: SEGV in pnm_load_rawpbm Reproducer: CVE:  #########################################  AddressSanitizer: stack-buffer-overflow on address at pc bp sp WRITE of size 1 at thread T0     #0 in pnmscanner_gettoken     #1 in pnm_load_ascii     #2 in input_pnm_reader     #3 in at_bitmap_read     #4 in main     #5 in __libc_start_main     #6 in _init  Address is located in stack of thread T0 at offset in frame     #0 in pnm_load_ascii    This frame has 1 object(s):     [32, 'buf' <== Memory access at offset overflows this variable HINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext       (longjmp and C++ exceptions *are* supported) SUMMARY: AddressSanitizer: stack-buffer-overflow in pnmscanner_gettoken Reproducer: CVE:  #########################################  runtime error: signed integer overflow: * cannot be represented in type 'int' Reproducer: CVE:  #########################################  runtime error: signed integer overflow: * cannot be represented in type 'int' Reproducer: CVE:  #########################################  runtime error: signed integer overflow: * cannot be represented in type 'int' Reproducer: CVE:  #########################################  AddressSanitizer: heap-buffer-overflow on address at pc bp sp READ of size 1 at thread T0     #0 in GET_COLOR     #1 in is_outline_edge     #2 in next_point     #3 in find_one_outline     #4 in find_outline_pixels     #5 in at_splines_new_full     #6 in main     #7 in __libc_start_main     #8 in _init  is located 8 bytes to the right of region allocated by thread T0 here:     #0 in malloc     #1 in ReadImage     #2 in input_bmp_reader     #3 in at_bitmap_read     #4 in main     #5 in __libc_start_main  SUMMARY: AddressSanitizer: heap-buffer-overflow in GET_COLOR Reproducer: CVE:  #########################################  AddressSanitizer: heap-buffer-overflow on address at pc bp sp READ of size 1 at thread T0     #0 in GET_COLOR     #1 in find_outline_pixels     #2 in at_splines_new_full     #3 in main     #4 in __libc_start_main     #5 in _init  is located 0 bytes to the right of 1-byte region allocated by thread T0 here:     #0 in malloc     #1 in ReadImage     #2 in input_bmp_reader     #3 in at_bitmap_read     #4 in main     #5 in __libc_start_main  SUMMARY: AddressSanitizer: heap-buffer-overflow in GET_COLOR Reproducer: CVE:  #########################################  AddressSanitizer: heap-buffer-overflow on address at pc bp sp READ of size 1 at thread T0     #0 in GET_COLOR     #1 in is_outline_edge     #2 in next_point     #3 in find_one_outline     #4 in find_outline_pixels     #5 in at_splines_new_full     #6 in main     #7 in __libc_start_main     #8 in _init  is located 0 bytes to the right of region allocated by thread T0 here:     #0 in malloc     #1 in ReadImage     #2 in input_bmp_reader     #3 in at_bitmap_read     #4 in main     #5 in __libc_start_main  SUMMARY: AddressSanitizer: heap-buffer-overflow in GET_COLOR Reproducer: CVE:  #########################################  AddressSanitizer: heap-buffer-overflow on address at pc bp sp WRITE of size 1 at thread T0     #0 in ReadImage     #1 in input_bmp_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  is located 3 bytes to the left of 3-byte region allocated by thread T0 here:     #0 in malloc     #1 in ReadImage     #2 in input_bmp_reader     #3 in at_bitmap_read     #4 in main     #5 in __libc_start_main  SUMMARY: AddressSanitizer: heap-buffer-overflow in ReadImage Reproducer: CVE:  #########################################  AddressSanitizer: heap-buffer-overflow on address at pc bp sp WRITE of size 1 at thread T0     #0 in ReadImage     #1 in input_bmp_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  is located 3 bytes to the left of 3-byte region allocated by thread T0 here:     #0 in malloc     #1 in ReadImage     #2 in input_bmp_reader     #3 in at_bitmap_read     #4 in main     #5 in __libc_start_main  SUMMARY: AddressSanitizer: heap-buffer-overflow in ReadImage Reproducer: CVE:  #########################################  AddressSanitizer: heap-buffer-overflow on address at pc bp sp WRITE of size 1 at thread T0     #0 in ReadImage     #1 in input_bmp_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  is located 0 bytes to the right of 72-byte region allocated by thread T0 here:     #0 in malloc     #1 in at_fitting_opts_new     #2 in main     #3 in __libc_start_main  SUMMARY: AddressSanitizer: heap-buffer-overflow in ReadImage Reproducer: CVE:  #########################################  AddressSanitizer: heap-buffer-overflow on address at pc bp sp WRITE of size 1 at thread T0     #0 in ReadImage     #1 in input_bmp_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  is located 3 bytes to the left of 3-byte region allocated by thread T0 here:     #0 in malloc     #1 in ReadImage     #2 in input_bmp_reader     #3 in at_bitmap_read     #4 in main     #5 in __libc_start_main  SUMMARY: AddressSanitizer: heap-buffer-overflow in ReadImage Reproducer: CVE:  #########################################  AddressSanitizer: heap-buffer-overflow on address at pc bp sp READ of size 1 at thread T0     #0 in ReadImage     #1 in input_bmp_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  is located 0 bytes to the right of region allocated by thread T0 here:     #0 in malloc     #1 in ReadImage     #2 in input_bmp_reader     #3 in at_bitmap_read     #4 in main     #5 in __libc_start_main  SUMMARY: AddressSanitizer: heap-buffer-overflow in ReadImage Reproducer: CVE:  #########################################  AddressSanitizer: heap-buffer-overflow on address at pc bp sp WRITE of size 1 at thread T0     #0 in ReadImage     #1 in input_bmp_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  is located 0 bytes to the right of 1-byte region allocated by thread T0 here:     #0 in malloc     #1 in ReadImage     #2 in input_bmp_reader     #3 in at_bitmap_read     #4 in main     #5 in __libc_start_main  SUMMARY: AddressSanitizer: heap-buffer-overflow in ReadImage Reproducer: CVE:  #########################################  AddressSanitizer: heap-buffer-overflow on address at pc bp sp WRITE of size 1 at thread T0     #0 in ReadImage     #1 in input_bmp_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  is located 0 bytes to the right of region allocated by thread T0 here:     #0 in malloc     #1 in ReadImage     #2 in input_bmp_reader     #3 in at_bitmap_read     #4 in main     #5 in __libc_start_main  SUMMARY: AddressSanitizer: heap-buffer-overflow in ReadImage Reproducer: CVE:  #########################################  AddressSanitizer: SEGV on unknown address (pc bp sp T0) signal is caused by a READ memory access.     #0 in GET_COLOR     #1 in is_outline_edge     #2 in next_point     #3 in find_one_outline     #4 in find_outline_pixels     #5 in at_splines_new_full     #6 in main     #7 in __libc_start_main     #8 in _init  AddressSanitizer can not provide additional info. SUMMARY: AddressSanitizer: SEGV in GET_COLOR Reproducer: CVE:  #########################################  AddressSanitizer: SEGV on unknown address (pc bp sp T0) signal is caused by a WRITE memory access.     #0 in ReadImage     #1 in input_bmp_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  AddressSanitizer can not provide additional info. SUMMARY: AddressSanitizer: SEGV in ReadImage Reproducer: CVE:  #########################################  AddressSanitizer: SEGV on unknown address (pc bp sp T0) signal is caused by a WRITE memory access.     #0 in ReadImage     #1 in input_bmp_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  AddressSanitizer can not provide additional info. SUMMARY: AddressSanitizer: SEGV in ReadImage Reproducer: CVE:  #########################################  AddressSanitizer: SEGV on unknown address (pc bp sp T0) signal is caused by a READ memory access.     #0 in ReadImage     #1 in input_bmp_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  AddressSanitizer can not provide additional info. SUMMARY: AddressSanitizer: SEGV in ReadImage Reproducer: CVE:  #########################################  AddressSanitizer: SEGV on unknown address (pc bp sp T0) signal is caused by a WRITE memory access.     #0 in ReadImage     #1 in input_bmp_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  AddressSanitizer can not provide additional info. SUMMARY: AddressSanitizer: SEGV in ReadImage Reproducer: CVE:  #########################################  AddressSanitizer: SEGV on unknown address (pc bp sp T0) signal is caused by a READ memory access.     #0 in ReadImage     #1 in input_bmp_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  AddressSanitizer can not provide additional info. SUMMARY: AddressSanitizer: SEGV in ReadImage Reproducer: CVE:  #########################################  AddressSanitizer: SEGV on unknown address (pc bp sp T0) signal is caused by a READ memory access. address points to the zero page.     #0 in ReadImage     #1 in input_bmp_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  AddressSanitizer can not provide additional info. SUMMARY: AddressSanitizer: SEGV in ReadImage Reproducer: CVE:  #########################################  AddressSanitizer: SEGV on unknown address (pc bp sp T0) signal is caused by a WRITE memory access.     #0 in ReadImage     #1 in input_bmp_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  AddressSanitizer can not provide additional info. SUMMARY: AddressSanitizer: SEGV in ReadImage Reproducer: SEGV-input-bmp.c.BMP CVE:  #########################################  AddressSanitizer: heap-use-after-free on address at pc bp sp READ of size 1 at thread T0     #0 in GET_COLOR     #1 in is_outline_edge     #2 in next_point     #3 in find_one_outline     #4 in find_outline_pixels     #5 in at_splines_new_full     #6 in main     #7 in __libc_start_main     #8 in _init  is located bytes inside of region freed by thread T0 here:     #0 in __interceptor_cfree     #1 in ReadImage     #2 in input_bmp_reader     #3 in at_bitmap_read     #4 in main     #5 in __libc_start_main  previously allocated by thread T0 here:     #0 in malloc     #1 in ReadImage     #2 in input_bmp_reader     #3 in at_bitmap_read     #4 in main     #5 in __libc_start_main  SUMMARY: AddressSanitizer: heap-use-after-free in GET_COLOR Reproducer: CVE:  #########################################  runtime error: signed integer overflow: * 3 cannot be represented in type 'int' Reproducer: CVE:  #########################################  runtime error: signed integer overflow: * cannot be represented in type 'int' Reproducer: CVE:  #########################################  runtime error: signed integer overflow: * cannot be represented in type 'int' Reproducer: CVE:  #########################################  runtime error: signed integer overflow: - 1 cannot be represented in type 'int' Reproducer: CVE:  #########################################  runtime error: signed integer overflow: * 3 cannot be represented in type 'int' Reproducer: CVE:  #########################################  runtime error: left shift of by 24 places cannot be represented in type 'int' Reproducer: CVE:  #########################################  AddressSanitizer: unknown-crash on address at pc bp sp READ of size 1 at thread T0     #0 in GET_COLOR     #1 in is_outline_edge     #2 in next_point     #3 in find_one_outline     #4 in find_outline_pixels     #5 in at_splines_new_full     #6 in main     #7 in __libc_start_main     #8 in _init  Address is a wild pointer. SUMMARY: AddressSanitizer: unknown-crash in GET_COLOR Reproducer: CVE:  #########################################  AddressSanitizer: attempting free on address which was not malloc()-ed: in thread T0                                        #0 in __interceptor_cfree     #1 in free_bitmap                                       #2 in at_bitmap_free                                #3 in main                                                     #4 in __libc_start_main                                #5 in _init                                                                                                                                                                                                                                                      is located 48 bytes inside of region                                                    CHECK failed: "((res.trace)) != (0)" (0x0, 0x0)                                                                                                                       #0 in AsanCheckFailed                  #1 in __sanitizer::CheckFailed(char const*, int, char const*, unsigned long long, unsigned long long)                                                              #2 in GetStackTraceFromId     #3 in __asan::HeapAddressDescription::Print() const     #4 in __asan::AddressDescription::Print(char const*) const     #5 in __asan::ErrorFreeNotMalloced::Print()     #6 in __asan::ErrorDescription::Print()     #7 in __asan::ScopedInErrorReport::~ScopedInErrorReport()     #8 in __asan::ReportFreeNotMalloced(unsigned long, __sanitizer::BufferedStackTrace*)     #9 in __asan::Allocator::ReportInvalidFree(void*, unsigned char, __sanitizer::BufferedStackTrace*)     #10 in __asan::Allocator::AtomicallySetQuarantineFlagIfAllocated(__asan::AsanChunk*, void*, __sanitizer::BufferedStackTrace*)     #11 in __asan::Allocator::Deallocate(void*, unsigned long, __sanitizer::BufferedStackTrace*, __asan::AllocType)     #12 in __asan::asan_free(void*, __sanitizer::BufferedStackTrace*, __asan::AllocType)     #13 0x4cfedc in __interceptor_cfree     #14 in free_bitmap     #15 in at_bitmap_free     #16 in main     #17 in __libc_start_main     #18 in _init Reproducer: CVE:  #########################################  AddressSanitizer: heap-buffer-overflow on address at pc bp sp WRITE of size 4 at thread T0     #0 in __asan_memcpy     #1 in rle_fread     #2 in ReadImage     #3 in input_tga_reader     #4 in at_bitmap_read     #5 in main     #6 in __libc_start_main     #7 in _init  is located 0 bytes to the right of region allocated by thread T0 here:     #0 in calloc     #1 in at_bitmap_init     #2 in ReadImage     #3 in input_tga_reader     #4 in at_bitmap_read     #5 in main     #6 in __libc_start_main  SUMMARY: AddressSanitizer: heap-buffer-overflow in __asan_memcpy Reproducer: CVE:  #########################################  AddressSanitizer: heap-buffer-overflow on address at pc bp sp WRITE of size at thread T0     #0 in __asan_memset     #1 in ReadImage     #2 in input_tga_reader     #3 in at_bitmap_read     #4 in main     #5 in __libc_start_main     #6 in _init  is located 0 bytes to the right of region allocated by thread T0 here:     #0 in calloc     #1 in at_bitmap_init     #2 in ReadImage     #3 in input_tga_reader     #4 in at_bitmap_read     #5 in main     #6 in __libc_start_main  SUMMARY: AddressSanitizer: heap-buffer-overflow Reproducer: CVE:  #########################################  AddressSanitizer: heap-buffer-overflow on address at pc bp sp              READ of size 1 at thread T0                                                                                                                #0 in ReadImage                                    #1 in input_tga_reader                                #2 in at_bitmap_read                               #3 in main                                                    #4 in __libc_start_main                                #5 in _init                                                                                                                                                                                                                                                      Address is a wild pointer.                                                                                                             SUMMARY: AddressSanitizer: heap-buffer-overflow in ReadImage Reproducer: CVE:  #########################################  AddressSanitizer: heap-buffer-overflow on address at pc bp sp READ of size 1 at thread T0     #0 in ReadImage     #1 in input_tga_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  is located 1 bytes to the right of region allocated by thread T0 here:     #0 in calloc     #1 in at_bitmap_init     #2 in ReadImage     #3 in input_tga_reader     #4 in at_bitmap_read     #5 in main     #6 in __libc_start_main  SUMMARY: AddressSanitizer: heap-buffer-overflow in ReadImage Reproducer: CVE:  #########################################  AddressSanitizer: heap-buffer-overflow on address at pc bp sp READ of size 1 at thread T0     #0 in ReadImage     #1 in input_tga_reader     #2 in at_bitmap_read     #3 in main     #4 in __libc_start_main     #5 in _init  Address is a wild pointer. SUMMARY: AddressSanitizer: heap-buffer-overflow in ReadImage Reproducer: CVE:  #########################################  AddressSanitizer: negative-size-param:     #0 in __asan_memset     #1 in ReadImage     #2 in input_tga_reader     #3 in at_bitmap_read     #4 in main     #5 in __libc_start_main     #6 in _init  is located 0 bytes inside of region allocated by thread T0 here:     #0 in calloc     #1 in at_bitmap_init     #2 in ReadImage     #3 in input_tga_reader     #4 in at_bitmap_read     #5 in main     #6 in __libc_start_main  SUMMARY: AddressSanitizer: negative-size-param in __asan_memset Reproducer: CVE:  #########################################  runtime error: signed integer overflow: * 3 cannot be represented in type 'int'                                        SUMMARY: AddressSanitizer: undefined-behavior in                                                                                   runtime error: signed integer overflow: * cannot be represented in type 'int'                                         SUMMARY: AddressSanitizer: undefined-behavior in                                                                                   runtime error: signed integer overflow: * 4 cannot be represented in type 'int'                                        SUMMARY: AddressSanitizer: undefined-behavior in                                                                                   runtime error: signed integer overflow: * 4 cannot be represented in type 'int'  Reproducer: UNDEF-input-tga.c.TGA CVE:  #########################################  Credit: These bugs were discovered by Agostino Sarubbo of Gentoo.  Reproducer:  Sources:  Timeline: bugs discovered blog post about the issues CVE assigned  Note: These bugs were found with American Fuzzy Lop.  Permalink:  -- Agostino Sarubbo Gentoo Linux Developer    Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      