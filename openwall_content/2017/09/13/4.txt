  oss-security - Linux BlueBorne vulnerabilities            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [thread-next>] [day] [month] [year] [list]  Date: Wed, 13 Sep From: Armis Security <security@...is.com> To: oss-security@...ts.openwall.com Subject: Linux BlueBorne vulnerabilities  Hello,  We are writing to inform you of two security vulnerabilities we have found in the Bluetooth stack in Linux (BlueZ).  These vulnerabilities have been made public yesterday (Sept. 12, and are part of 8 vulnerabilities we have disclosed to various vendors (as a group they are called "BlueBorne").  Both Linux-related vulnerabilities where disclosed to distros@...openwall.org. The kernel-related vulnerability was also disclosed to security@...nel.org Both disclosures began on Sept. 5, and patches were made available yesterday and today. I will link to these patches bellow.  1) This vulnerability lies in the bluetoothd process, in the processing of incoming requests in the SDP server. It is an information disclosure vulnerability in the function service_search_attr_req (src/sdpd-request.c) that handles incoming sdp search attribute requests. It can be triggered without any user interaction in the victim’s machine and without any prior authentication (pairing), as it is part of stack’s Service discovery protocol (SDP) server that is meant to be accessed prior to authentication. This vulnerability can lead to a very large information disclosure from the heap of the bluetoothd process, that can potentially hold critical information including Bluetooth encryption keys, or other valuable data.  Here are the specifics of this vulnerability: In the SDP server search attribute request handler (service_search_attr_req, under src/sdpd-request.c), this flow exists: ... } else { /* continuation State exists -> get from cache */ sdp_buf_t *pCache = sdp_get_cached_rsp(cstate); if (pCache) { uint16_t sent = MIN(max, pCache->data_size -   cstate->cStateValue.maxBytesSent); pResponse = pCache->data; memcpy(buf->data,                              pResponse + cstate->cStateValue.maxBytesSent,                              sent); buf->data_size += sent; cstate->cStateValue.maxBytesSent += sent; if (cstate->cStateValue.maxBytesSent == pCache->data_size) cstate_size = sdp_set_cstate_pdu(buf, NULL); else cstate_size = sdp_set_cstate_pdu(buf, cstate); } else { status = SDP_INVALID_CSTATE; SDPDBG("Non-null continuation state, but null cache buffer"); } } ...  When a long response is returned to a specific search attribute request, a continuation state is returned to allow reception of additional fragments, via additional requests that contain the last continuation state sent. However, the incoming “cstate” that requests additional fragments isn’t validated properly, and thus an out-of-bounds read of the response buffer (pResponse) can be achieved, leading to information disclosure of the heap.  A patch for this vulnerability was pushed today to BlueZ upstream:  2)  This vulnerability is an RCE vulnerability in the Kernel's implementation of Bluetooth's L2CAP (net/bluetooth/l2cap_core.c):  In l2cap_config_rsp this flow exists: ...      case L2CAP_CONF_PENDING:          set_bit(CONF_REM_CONF_PEND, &chan->conf_state);          if (test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {              char buf[64];              len = l2cap_parse_conf_rsp(chan, rsp->data, len,                             buf, &result); ... The function l2cap_parse_conf_rsp parses the configuration elements in the configuration response (rsp->data), and copies them (after validating them) to the output buffer (buf). The function does not receive a maximum length of the output buffer, and this buffer is allocated on the stack of l2cap_config_rsp. So sending a configuration response which contains a large number of configuration elements (they can also be the same type of element repeated multiple times) - would cause a stack overflow of the output buffer (buf). Reaching this case (L2CAP_CONF_PENDING) is achievable by sending a configuration request with an EFS element, and setting the stype field to L2CAP_SERV_NOTRAFIC, prior to the crafted configuration response that would trigger the stack overflow.  A patch for this vulnerability was pushed yesterday to upstream Linux Kernel:     If you need any additional information on these issues we would be happy to help.  Thank you, Armis Labs   Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      