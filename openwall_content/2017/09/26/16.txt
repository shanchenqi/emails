  oss-security - Qualys Security Advisory - Linux PIE/stack corruption             Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [thread-next>] [day] [month] [year] [list]  Date: Tue, 26 Sep From: Qualys Security Advisory <qsa@...lys.com> To: oss-security@...ts.openwall.com Subject: Qualys Security Advisory - Linux PIE/stack corruption    Qualys Security Advisory  Linux PIE/stack corruption   ======================================================================== Contents ========================================================================  Summary Analysis Exploitation Acknowledgments   ======================================================================== Summary ========================================================================  Linux distributions that have not patched their long-term kernels with (committed on April 14, are vulnerable to a Local Privilege Escalation.  Most notably, all versions of CentOS 7 before (released on September 13, all versions of Red Hat Enterprise Linux 7 before 7.4 (released on August 1, and all versions of CentOS 6 and Red Hat Enterprise Linux 6 are exploitable.   ======================================================================== Analysis ========================================================================  ------------------------------------------------------------------------ Pre-Stack-Clash kernels ------------------------------------------------------------------------  Occasionally, we have noticed a strange behavior with PIEs (Position-Independent Executables) on CentOS 7:  Linux localhost.localdomain #1 SMP Thu May 25 UTC GNU/Linux  r-xp fd:00                       ---p fd:00                       r--p fd:00                       rw-p fd:00                       rw-p 0  r-xp fd:00                       rw-p 0  rw-p 0  r-xp 0                          [vdso] r--p fd:00                       rw-p fd:00                       rw-p 0  r-xp fd:00                    /tmp/PIE rw-p 0                          [stack] r--p fd:00                    /tmp/PIE rw-p fd:00                    /tmp/PIE rw-p 0                          [heap] r-xp 0                  [vsyscall] rsp  In this example, the kernel's execve() code erroneously mapped the PIE's read-write segment into the stack memory region, thus corrupting and dividing the stack into three parts:  - the lowest part of the stack, is where the   stack pointer (rsp) points to, after execve() returns to the userland;  - the middle part of the stack, was replaced   by the PIE's read-write segment was later   mprotect()ed read-only by RELRO), and hence a write to this part of   the stack smashes the PIE's read-write segment, and vice versa;  - the highest part of the stack, is   incorrectly displayed as the "[heap]" in /proc/pid/maps (because the   program brk() points there), but is correctly flagged as a stack in   /proc/pid/smaps (the "gd" flag, "grows down").  This kernel vulnerability was fixed in April by commit (backported to Linux in May but it was not recognized as a security threat. This fix was therefore not backported to long-term distributions such as CentOS:  ------------------------------------------------------------------------  From: Michael Davidson <md@...gle.com> Date: Tue, 14 Apr Subject: fs/binfmt_elf.c: fix bug in loading of PIE binaries  With CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE enabled, and a normal top-down address allocation strategy, load_elf_binary() will attempt to map a PIE binary into an address range immediately below mm->mmap_base.  Unfortunately, load_elf_ binary() does not take account of the need to allocate sufficient space for the entire binary which means that, while the first PT_LOAD segment is mapped below mm->mmap_base, the subsequent PT_LOAD segment(s) end up being mapped above mm->mmap_base into the are that is supposed to be the "gap" between the stack and the binary.  Since the size of the "gap" on is only guaranteed to be this means that binaries with large data segments > can end up mapping part of their data segment over their stack resulting in corruption of the stack (and the data segment once the binary starts to run).  Any PIE binary with a data segment > is vulnerable to this although address randomization means that the actual gap between the stack and the end of the binary is normally greater than  The larger the data segment of the binary the higher the probability of failure.  Fix this by calculating the total size of the binary in the same way as load_elf_interp().  Signed-off-by: Michael Davidson <md@...gle.com> Cc: Alexander Viro <viro@...iv.linux.org.uk> Cc: Jiri Kosina <jkosina@...e.cz> Cc: Kees Cook <keescook@...omium.org> Cc: <stable@...r.kernel.org> Signed-off-by: Andrew Morton <akpm@...ux-foundation.org> Signed-off-by: Linus Torvalds <torvalds@...ux-foundation.org> ---  fs/binfmt_elf.c | 9 ++++++++-  1 file changed, 8 insertions(+), 1 deletion(-)  diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c index --- a/fs/binfmt_elf.c +++ b/fs/binfmt_elf.c @@ @@ static int load_elf_binary(struct linux_binprm *bprm)             i < loc->elf_ex.e_phnum; i++, elf_ppnt++) {                 int elf_prot = 0, elf_flags;                 unsigned long k, vaddr; +               unsigned long total_size = 0;                   if (elf_ppnt->p_type != PT_LOAD)                         continue; @@ @@ static int load_elf_binary(struct linux_binprm *bprm)  #else                         load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);  #endif +                       total_size = total_mapping_size(elf_phdata, +                                                       loc->elf_ex.e_phnum); +                       if (!total_size) { +                               error = -EINVAL; +                               goto out_free_dentry; +                       }                 }                   error = elf_map(bprm->file, load_bias + vaddr, elf_ppnt, -                               elf_prot, elf_flags, 0); +                               elf_prot, elf_flags, total_size);                 if (BAD_ADDR(error)) {                         retval = IS_ERR((void *)error) ?                                 PTR_ERR((void*)error) : -EINVAL;  ------------------------------------------------------------------------  Unfortunately, this vulnerability is not limited to the PIEs whose read-write segment is larger than Indeed, is the minimum distance between the mmap_base and the highest address of the stack, not the lowest address of the stack consequently, and as shown in our Stack Clash advisory, if we pass 1.5GB of argument strings to execve(), then any PIE may be mapped directly below the stack (and trigger with a probability of (5 hours on average, if each run takes 1 second).  ------------------------------------------------------------------------ Post-Stack-Clash kernels ------------------------------------------------------------------------  As a proof-of-concept, we will publish an exploit for ping on CentOS-7 kernel versions and (the first kernel updates after the Stack Clash). The PIE/stack layout on these post-Stack-Clash kernels differs slightly from the layout on pre-Stack-Clash kernels, since the size of the stack guard-page was increased from 4KB to 1MB:  Linux localhost.localdomain #1 SMP Thu Jun 29 UTC GNU/Linux  r-xp fd:00                       ---p fd:00                       r--p fd:00                       rw-p fd:00                       rw-p 0  r-xp fd:00                       rw-p 0  rw-p 0  r-xp 0                          [vdso] r--p fd:00                       rw-p fd:00                       rw-p 0  r-xp fd:00                    /tmp/PIE rw-p 0  r--p fd:00                    /tmp/PIE rw-p fd:00                    /tmp/PIE rw-p 0                          [heap] r-xp 0                  [vsyscall] rsp  In this example, the kernel's execve() code also mapped the PIE's read-write segment into the stack memory region, and divided the stack into three parts, but:  - the lowest part of the stack, is not   displayed as the "[stack]" in /proc/pid/maps (because rsp does not   point there), but is correctly flagged as a stack in /proc/pid/smaps;  - the middle part of the stack, was replaced   by the PIE's read-write segment, and is where rsp points to, after   execve() returns to the userland;  - the highest part of the stack, is (again)   incorrectly displayed as the "[heap]" in /proc/pid/maps, but is   correctly flagged as a stack in /proc/pid/smaps.  Older kernels (such as and newer kernels (such as other distributions and other privileged PIEs (including SUID-root PIEs), are also exploitable, but the exploitation method must be adapted to slightly different PIE/stack layouts. This is left as an exercise for the interested reader.   ======================================================================== Exploitation ========================================================================  Our exploit for CentOS-7 kernel versions and is very similar to our stack-clash exploit Linux_ldso_dynamic.c (we smash the PIE's .dynamic section with a stack-based string operation, and force ld.so to load and execute our own shared library), but with two important differences:  - we do not need to jump over the stack guard-page, because rsp   naturally points into the PIE's read-write segment after we trigger    - on 64-bit, all .dynamic tags contain null-bytes, a serious problem if   we want to smash the .dynamic section with a null-terminated string.  To solve this problem, we smash the .dynamic section with multiple calls to process_dl_debug(), a function called by process_envvars() very early in dl_main(), before elf_get_dynamic_info() parses the .dynamic section. process_dl_debug() is called for each LD_DEBUG environment variable, and calls strndupa() (strnlen(), alloca(), memcpy()) for each unknown option in LD_DEBUG, thus allowing us to smash the .dynamic section with multiple null-terminated strings, and hence multiple null-bytes.  Unfortunately, the .dynamic entries that we build on the stack with process_dl_debug():  - DT_SYMTAB (tag value unused);  - DT_STRTAB (tag an offset (into the PIE's   read-execute segment) to our own .dynstr section -- this is later   transformed by elf_get_dynamic_info() into an absolute address,   allowing us to bypass ASLR;  - DT_NEEDED (tag an offset (into our .dynstr   section) to the pathname of our own shared library -- we use offset   into the PIE's read-execute segment, where the string   is always stored;  - DT_NULL (tag value unused);  are partially destroyed by the stack-frames of further function calls (_dl_error_printf(), for example). Our solution to this problem is very specific to CentOS 7, and restricts this particular exploit to the PIEs whose .dynamic section's address modulo 16 is equal to 8:  - we build our .dynamic tags through a stack variable used by memcpy()   to store the address modulo 16 of the unknown options in LD_DEBUG;  - we store our .dynamic values in an unused slot of process_dl_debug()'s   stack-frame.  One last, unexpected problem with this particular exploit is that rsp can never point into the highest part of the stack (after the kernel's execve() code divided the stack into three parts): indeed, the kernel's page-fault handler would then try to insert a stack guard-page below the highest part of the stack, and would SIGKILL our process because the PIE's read-write segment is already mapped there.  The solution to this problem is simple, but further restricts this particular exploit to the PIEs whose read-write segment is large enough to encompass rsp: the kernel's page-fault handler will not try to insert a stack guard-page there, because the PIE's read-write segment is not flagged as a stack (VM_GROWSDOWN). For example, on a default, minimal CentOS 7, ping is privileged (cap_net_admin and cap_net_raw) and exploitable:  [user@...alhost tmp]$ getcap -r / 2>/dev/null /usr/bin/ping = cap_net_admin,cap_net_raw+p ...  [user@...alhost tmp]$ readelf -a /usr/bin/ping ...   Type           Offset             VirtAddr           PhysAddr                  FileSiz            MemSiz              Flags  Align ...   LOAD                             RW       DYNAMIC                          RW     8 ...  [user@...alhost tmp]$ /usr/bin/ping argv_size smash_size hi_smash_size lo_smash_size probability try 1 exited 2 try 2 exited 2 try 3 exited 2 try 4 exited 2 try 5 exited 2 try 6 exited 2 try 7 exited 2 ... try exited 2 try exited 2 try exited 2 try exited 2 try exited 2 try exited 2 try exited 2 Pid:    Uid:          Gid:          CapInh: CapPrm: CapEff:  [root@...alhost tmp]# cat Name:   ping ... Pid:    ... Uid:             Gid:             ... CapInh: CapPrm: CapEff: ...  [root@...alhost tmp]# cat r-xp fd:00                       ---p fd:00                       r--p fd:00                       rw-p fd:00                       rw-p 0  r-xp fd:00                    ---p fd:00                    r--p fd:00                    rw-p fd:00                    r-xp fd:00                       rw-p 0  rw-p 0  r-xp 0                          [vdso] r--p fd:00                       rw-p fd:00                       rw-p 0  r-xp fd:00                   /usr/bin/ping rw-p 0  r--p fd:00                   /usr/bin/ping rw-p fd:00                   /usr/bin/ping rw-p 0                          [stack] rw-p 0                          [heap] r-xp 0                  [vsyscall]  [root@...alhost tmp]# gdb /usr/bin/ping ... (gdb) + 8                                    ...                                                                                                                                                                                                              ... (gdb) x/s +   ======================================================================== Acknowledgments ========================================================================  We thank Red Hat and the members of the linux-distros@...nwall list.   Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      