  oss-security - Qt QXmlSimpleReader            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [thread-next>] [day] [month] [year] [list]  Date: Sat, 24 Dec From: Solar Designer <solar@...nwall.com> To: oss-security@...ts.openwall.com Subject: Qt QXmlSimpleReader  Hi,  To what extent has Qt's QXmlSimpleReader class been reviewed for vulnerabilities?  I found only Florian Weimer's "XML entity expansion denial of service", which Red Hat somehow chose not to fix (no intent to parse untrusted XML?) even though they got upstream to fix it.   Is high memory consumption for large XML files/inputs expected by users of this library, or is there an expectation that there would be some safety limits in place in the library?  In my testing, for very long tag names or element contents, memory consumption is 4x their size - e.g., about 8 GB for an almost 2 GB tag or element.  I guess was worse than that?  Did it result in recursive expansion, meaning that even a tiny input would exhaust all memory? (I didn't try triggering it specifically.)  I just found that (at least for a rebuild of the RHEL7 package of it is possible to trigger a stack overflow by nesting many XML opening tags.  Luckily, there doesn't appear to be a way to jump over the guard page to another thread's stack on but that's platform specific.  Sample crash 1:  Program received signal SIGSEGV, Segmentation fault. [Switching to Thread (LWP in _int_malloc () from (gdb) bt #0  in _int_malloc () from #1  in malloc () from #2  in operator new(unsigned long) () from #3  in QDomDocumentPrivate::createElement(QString const&) () from #4  in QDomHandler::startElement(QString const&, QString const&, QString const&, QXmlAttributes const&) () from #5  in QXmlSimpleReaderPrivate::parseElement() () from #6  in QXmlSimpleReaderPrivate::parseContent() () from #7  in QXmlSimpleReaderPrivate::parseElement() () from #8  in QXmlSimpleReaderPrivate::parseContent() () from #9  in QXmlSimpleReaderPrivate::parseElement() () from #10 in QXmlSimpleReaderPrivate::parseContent() () from #11 in QXmlSimpleReaderPrivate::parseElement() () from #12 in QXmlSimpleReaderPrivate::parseContent() () from       callq  <malloc_consolidate>      mov         mov    (%rsp),%r10d      mov    %r14d,%eax =>   movq   $0x1,(%rsp)      lea         shr    $0x4,%eax      mov         mov    %eax,0x8(%rsp)  (gdb) p $rsp $1 = (void *)  ---p 0  rw-p 0                           Sample crash 2 (combining nested tags with long content in each element, but maybe the difference from the above crash is actually just luck):  Program received signal SIGSEGV, Segmentation fault. [Switching to Thread (LWP in sysmalloc () from (gdb) bt #0  in sysmalloc () from #1  in _int_malloc () from #2  in _int_realloc () from #3  in realloc () from #4  in QString::realloc(int) () from #5  in QString::resize(int) () from #6  in updateValue(QString&, QChar const*, int&, int&) () from #7  in QXmlSimpleReaderPrivate::parseContent() () from #8  in QXmlSimpleReaderPrivate::parseElement() () from #9  in QXmlSimpleReaderPrivate::parseContent() () from #10 in QXmlSimpleReaderPrivate::parseElement() () from #11 in QXmlSimpleReaderPrivate::parseContent() () from #12 in QXmlSimpleReaderPrivate::parseElement() () from     <sysmalloc+38>:   je        <sysmalloc+44>:   cmp           # <mp_+16>    <sysmalloc+51>:   jbe    => <sysmalloc+57>:   movb      <sysmalloc+62>:   mov       <sysmalloc+66>:   lea           # <main_arena>    <sysmalloc+73>:   mov     (gdb) p $rsp $1 = (void *)  ---p 0  rw-p 0                           So parseElement() and parseContent() call each other recursively.  Since thread stacks are typically tiny this issue is easy to trigger with small XML files/streams.  Looking further at the source code for a version of Qt similar to RHEL7's:   I notice this:   inline static void updateValue(QString &value, const QChar *array, int &arrayPos, int &valueLen)  {      value.resize(valueLen + arrayPos);      memcpy(value.data() + valueLen, array, arrayPos * sizeof(QChar));      valueLen += arrayPos;      arrayPos = 0;  }  Here, arrayPos is at most but valueLen might be large.  Can this signed int overflow on "valueLen + arrayPos" and "valueLen += arrayPos"? I guess so.  (Unfortunately, the specific app I am testing with limits me to passing < 2 GB, so I can't test this easily.  Someone should write a testcase.)  This would be UB, but since it's not detectable as UB at compile time, I guess in practice and in typical builds the value will wrap around.  Then there's value.resize(), which also accepts a signed int (so the above code's use of signed int may have been justified, after all):  http://doc.qt.io/qt-4.8/qstring.html#resize  "If size is greater than the current size, the string is extended to make it size characters long with the extra characters added to the end. The new characters are uninitialized.  If size is less than the current size, characters are removed from the end."  No clear explanation on what will happen on a negative size, and besides it might also be possible to exceed 4 GB and get to positive values again.  Is there anything at higher layers, yet applicable to all published Qt's APIs, consistenly limiting XML inputs to below 2 GB?  If so, this may be OK (but a comment would be nice).  If not, we have a problem.  Speaking of the fix, it also looks susceptible to integer overflows, albeit possibly only for inputs so ridiculously large that mitigating that original DoS is irrelevant?  In the code below "++referencesToOtherEntities[toSearch][entityName];" and/or "*expandedIt += expandedSizes.value(referenceTo) * references + literalEntitySizes.value(referenceTo) * references;" might overflow, including possibly in ways that the second main loop doesn't run or that the check "*expandedIt > entityCharacterLimit" is false.        // The entity at (QMap<QString,) referenced the entities at (QMap<QString,) (int>) times.       QHash<QString, QHash<QString, int> > referencesToOtherEntities;       QHash<QString, int> expandedSizes;   bool QXmlSimpleReaderPrivate::isExpandedEntityValueTooLarge(QString *errorMessage)  {      QString entityNameBuffer;        // For every entity, check how many times all entity names were referenced in its value.      for (QMap<QString,QString>::const_iterator toSearchIt = entities.constBegin();           toSearchIt != entities.constEnd();           ++toSearchIt) {          const QString &toSearch = toSearchIt.key();            // Don't check the same entities twice.          if (!literalEntitySizes.contains(toSearch)) {              // The amount of characters that weren't entity names, but literals, like 'X'.              QString leftOvers = entities.value(toSearch);              // How many times was entityName referenced by toSearch?              for (QMap<QString,QString>::const_iterator referencedIt = entities.constBegin();                   referencedIt != entities.constEnd();                   ++referencedIt) {                  const QString &entityName = referencedIt.key();                    for (int i = 0; i < leftOvers.size() && i != -1; ) {                      entityNameBuffer = QLatin1Char('&') + entityName + QLatin1Char(';');                        i = leftOvers.indexOf(entityNameBuffer, i);                      if (i != -1) {                          leftOvers.remove(i, entityName.size() + 2);                          // The entityName we're currently trying to find was matched in this string; increase our count.                          ++referencesToOtherEntities[toSearch][entityName];                      }                  }              }              literalEntitySizes[toSearch] = leftOvers.size();          }      }        for (QHash<QString, QHash<QString, int> >::const_iterator entityIt = referencesToOtherEntities.constBegin();           entityIt != referencesToOtherEntities.constEnd();           ++entityIt) {          const QString &entity = entityIt.key();            QHash<QString, int>::iterator expandedIt = expandedSizes.find(entity);          if (expandedIt == expandedSizes.end()) {              expandedIt = expandedSizes.insert(entity, literalEntitySizes.value(entity));              for (QHash<QString, int>::const_iterator referenceIt = entityIt->constBegin();                   referenceIt != entityIt->constEnd();                   ++referenceIt) {                  const QString &referenceTo = referenceIt.key();                  const int references = referencesToOtherEntities.value(entity).value(referenceTo);                  // The total size of an entity's value is the expanded size of all of its referenced entities, plus its literal size.                  *expandedIt += expandedSizes.value(referenceTo) * references + literalEntitySizes.value(referenceTo) * references;              }                if (*expandedIt > entityCharacterLimit) {                  if (errorMessage) {                      *errorMessage = QString::fromLatin1("The XML entity \"%1\" expands to a string that is too large to process (%2 characters > %3).")                          .arg(entity, *expandedIt, entityCharacterLimit);                  }                  return true;              }          }      }      return false;  }  I'd appreciate any comments, especially from Florian and from upstream.  I am Bcc'ing this to the address given at https://wiki.qt.io/Qt_Project_Security_Policy so that they have this message with the Message-ID for replies to the same thread, and I will also notify them separately.  Alexander  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      