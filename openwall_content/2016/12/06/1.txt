  oss-security - Linux af_packet.c race condition (local root)            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [thread-next>] [day] [month] [year] [list]  Date: Tue, 6 Dec From: Philip Pettersson <philip.pettersson@...il.com> To: oss-security@...ts.openwall.com Subject: Linux af_packet.c race condition (local root)  Hello,  This is an announcement about which is a race-condition I found in Linux (net/packet/af_packet.c). It can be exploited to gain kernel code execution from unprivileged processes.  The bug was introduced on Aug 19,  Fixed on Nov 30,  =*=*=*=*=*=*=*=*=   BUG DETAILS  =*=*=*=*=*=*=*=*=  To create AF_PACKET sockets you need CAP_NET_RAW in your network namespace, which can be acquired by unprivileged processes on systems where unprivileged namespaces are enabled (Ubuntu, Fedora, etc). It can be triggered from within containers to compromise the host kernel. On Android, processes with are able to create AF_PACKET sockets (mediaserver) and can trigger the bug.  I found the bug by reading code paths that have been opened up by the emergence of unprivileged namespaces, something I think should be off by default in all Linux distributions given its history of security vulnerabilities.  The problem is inside packet_set_ring() and packet_setsockopt(). We can reach packet_set_ring() by calling setsockopt() on the socket using the PACKET_RX_RING option.  If the version of the packet socket is TPACKET_V3, a timer_list object will be initialized by packet_set_ring() when it calls init_prb_bdqc().  ...                 switch (po->tp_version) {                 case TPACKET_V3:                 /* Transmit path is not supported. We checked                  * it above but just being paranoid                  */                         if (!tx_ring)                                 init_prb_bdqc(po, rb, pg_vec, req_u);                         break;                 default:                         break;                 } ...  The function flow to set up the timer is: packet_set_ring()->init_prb_bdqc()->prb_setup_retire_blk_timer()-> prb_init_blk_timer()->prb_init_blk_timer()->init_timer()  When the socket is closed, packet_set_ring() is called again to free the ring buffer and delete the previously initialized timer if the packet version is > TPACKET_V2:  ...         if (closing && (po->tp_version > TPACKET_V2)) {                 /* Because we don't support block-based V3 on tx-ring */                 if (!tx_ring)                         prb_shutdown_retire_blk_timer(po, rb_queue);         } ...  The issue is that we can change the packet version to TPACKET_V1 with packet_setsockopt() after init_prb_bdqc() has been executed and before packet_set_ring() has returned.  There is an attempt to deny changing socket versions after a ring buffer has been initialized, but it is insufficient:  ...         case PACKET_VERSION:         { ...                 if (po->rx_ring.pg_vec || po->tx_ring.pg_vec)                         return -EBUSY; ...  There's plenty of room to race this code path between the calls to init_prb_bdqc() and swap(rb->pg_vec, pg_vec) in packet_set_ring().  When the socket is closed, packet_set_ring() will not delete the timer since the socket version is now TPACKET_V1. The struct timer_list that describes the timer object is located inside the struct packet_sock for the socket itself however and will be freed with a call to kfree().  We then have a use-after-free on a timer object that can be exploited by various poisoning attacks on the SLAB allocator (I find add_key() to be the most reliable). This will ultimately lead to the kernel jumping to a manipulated function pointer when the timer expires.  The bug is fixed by taking lock_sock(sk) in packet_setsockopt() when changing the packet version while also taking the lock at the start of packet_set_ring().  My exploit defeats SMEP/SMAP and will give a rootshell on Ubuntu I will hold off a day on publishing it so people have some time to update.  New Ubuntu kernels are out so please update as soon as possible.  =*=*=*=*=*=*=*=*=    TIMELINE    =*=*=*=*=*=*=*=*=  Bug reported to security@...nel.org Patch submitted to netdev, notification sent to linux-distros Patch committed to mainline kernel Public announcement  =*=*=*=*=*=*=*=*=     LINKS      =*=*=*=*=*=*=*=*=   =*=*=*=*=*=*=*=*=     CREDIT     =*=*=*=*=*=*=*=*=  Philip Pettersson  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      