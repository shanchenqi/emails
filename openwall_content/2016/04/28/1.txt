  oss-security - php: integer overflow in ZipArchive::getFrom*            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Thu, 28 Apr From: Hans Jerry Illikainen <hji@...topia.com> To: bugtraq@...urityfocus.com, fulldisclosure@...lists.org, oss-security@...ts.openwall.com Subject: php: integer overflow in ZipArchive::getFrom*  Details =======  An integer wrap may occur in PHP 7.x before version when reading zip files with the getFromIndex() and getFromName() methods of ZipArchive, resulting in a heap overflow.  ,---- | static void php_zip_get_from(INTERNAL_FUNCTION_PARAMETERS, int type) /* {{{ */ | { | .... |     struct zip_stat sb; | .... |     zend_long len = 0; | .... |     zend_string *buffer; | .... |     if (type == 1) { |         if (zend_parse_parameters(ZEND_NUM_ARGS(), "P|ll", &filename, &len, &flags) == FAILURE) { |             return; |         } |         PHP_ZIP_STAT_PATH(intern, ZSTR_VAL(filename), ZSTR_LEN(filename), flags, sb);  // (1) |     } else { |         if (zend_parse_parameters(ZEND_NUM_ARGS(), "l|ll", &index, &len, &flags) == FAILURE) { |             return; |         } |         PHP_ZIP_STAT_INDEX(intern, index, 0, sb);                                      // (1) |     } | .... |     if (len < 1) { |         len = sb.size; |     } | .... |     buffer = zend_string_alloc(len, 0);                                                // (2) |     n = zip_fread(zf, ZSTR_VAL(buffer), ZSTR_LEN(buffer));                             // (3) | .... | } `----  With `sb.size' from (1) being:  ,---- | ZIP_EXTERN int | zip_stat_index(zip_t *za, zip_uint64_t index, zip_flags_t flags, |                zip_stat_t *st) | { | ... |     zip_dirent_t *de; | |     if ((de=_zip_get_dirent(za, index, flags, NULL)) == NULL) |         return -1; | ... |         st->size = de->uncomp_size; | ... | } `----  Both `size' and `uncomp_size' are unsigned 64bit integers:  ,---- | struct zip_dirent { | ... |     zip_uint64_t uncomp_size;        /* (cl) size of uncompressed data */ | ... | }; `----  ,---- | struct zip_stat { | ... |     zip_uint64_t size;            /* size of file (uncompressed) */ | ... | }; `----  Whereas `len' is signed and has a platform-dependent size:  ,---- | #if || defined(__LP64__) || defined(_LP64) || defined(_WIN64) | # define ZEND_ENABLE_ZVAL_LONG64 1 | #endif | ... | #ifdef ZEND_ENABLE_ZVAL_LONG64 | typedef int64_t zend_long; | ... | #else | typedef int32_t zend_long; | ... | #endif `----  Uncompressed file sizes in zip-archives may be specified as either 32- or 64bit values; with the latter requiring that the size be specified in the extra field in zip64 mode.  Anyway, as for the invocation of `zend_string_alloc()' in (2):  ,---- | static zend_always_inline zend_string *zend_string_alloc(size_t len, int persistent) | { |     zend_string *ret = (zend_string *)pemalloc(ZEND_MM_ALIGNED_SIZE(_ZSTR_STRUCT_SIZE(len)), persistent); // (4) | ... |     ZSTR_LEN(ret) = len;                                                                                  // (5) |     return ret; | } `----  The `size' argument to the `pemalloc' macro is aligned/adjusted in (4) whilst the *original* value of `len' is stored as the size of the allocated buffer in (5).  No boundary checking is done in (4) and it may thus wrap, which would lead to a heap overflow during the invocation of `zip_fread()' in (3) as the `toread' argument is `ZSTR_LEN(buffer)':  ,---- | #define ZSTR_LEN(zstr)  (zstr)->len `----  On a 32bit system:  ,---- | (gdb) p/x ZEND_MM_ALIGNED_SIZE(_ZSTR_STRUCT_SIZE(0xfffffffe)) | $1 = `----  The wraparound may also occur on 64bit systems with `uncomp_size' specified in the extra field (Zip64 mode; However, it won't result in a buffer overflow because of `zip_fread()' bailing on a size that would have wrapped the allocation in (4):  ,---- | ZIP_EXTERN zip_int64_t | zip_fread(zip_file_t *zf, void *outbuf, zip_uint64_t toread) | { | ... |     if (toread > ZIP_INT64_MAX) { |         zip_error_set(&zf->error, ZIP_ER_INVAL, 0); |         return -1; |     } | ... | } `----  ,---- | #define ZIP_INT64_MAX     0x7fffffffffffffffLL `----  ,---- | (gdb) p/x ZEND_MM_ALIGNED_SIZE(_ZSTR_STRUCT_SIZE(0x7fffffffffffffff)) | $1 = `----   PoC ===  Against Arch Linux with php-fpm behind nginx [1]:  ,---- | $ python exploit.py --bind-port | [*] this may take a while | [*] of | [+] connected to |  | id | uid=33(http) gid=33(http) groups=33(http) |  | uname -a | Linux arch32 #1 SMP PREEMPT Thu Apr 14 CEST | GNU/Linux |  | pacman -Qs php-fpm | local/php-fpm |     FastCGI Process Manager for PHP |  | cat upload.php | <?php | $zip = new ZipArchive(); | if ($zip->open($_FILES["file"]["tmp_name"]) !== TRUE) { |     echo "cannot open archive\n"; | } else { |     for ($i = 0; $i < $zip->numFiles; $i++) { |         $data = $zip->getFromIndex($i); |     } |     $zip->close(); | } | ?> `----   Solution ========  This issue has been fixed in php    Footnotes _________  [1]   --  Hans Jerry Illikainen  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      