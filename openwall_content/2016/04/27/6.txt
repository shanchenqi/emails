  oss-security - 回复： 3 bugs refer to buffer overflow in in libtiff            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [<thread-prev] [thread-next>] [day] [month] [year] [list]  Date: Wed, 27 Apr From: "PXO炳林" To: "oss-security" <oss-security@...ts.openwall.com> Subject: 回复： 3 bugs refer to buffer overflow in in libtiff  It seems not a patch upstream.   The bugs detail I add as follows:   3 bugs: one stack buffer overflow in thumbnail and two heap buffer overflows in bmp2tiff.   Because they deal with different buffer(stack and heap), stack trace of alloc and read are also different.   ##################################### 1) stack buffer overflow in thumbnail  #####################################   Memory corruption bugs can be triggered when thumbnail function _TIFFVGetField handling maliciously crafted tiff file, it will cause the target application to crash.   overview:   alloc workflow:    read workflow :   -->  // if (!cpIFD(in, out) || !TIFFWriteDirectory(out)) -->  // cpTags(in, out) -->  // cpTag(in, out, p->tag, p->count, p->type) -->  // CopyField(tag, shortv) -->   // status = TIFFVGetField(tif, tag, ap); -->   // return (fip && (isPseudoTag(tag) || TIFFFieldSet(tif, fip->field_bit)) ? (*tif->tif_tagmethods.vgetfield)(tif, tag, ap) : 0); -->   // *va_arg(ap, uint32*) = (uint32)tv->count;   my gdb log as follows:   1) gdb --args thumbnail poc1.tiff out.tiff    // crash   Program received signal SIGSEGV, Segmentation fault. in _TIFFVGetField (tif=<optimized out>, at void **) = tv->value; (gdb) p tv->value  $1 = (void *) (gdb) info registers rax            rbx            rcx            rdx            rsi            rdi            rbp            rsp            r8             r9             r10            r11            r12            r13            r14            r15            rip            eflags         PF IF RF ] cs             ss             ds             es             fs             gs             (gdb) x/i $rip =>    %rdx,(%rax) (gdb) x/x $ebx access memory at address (gdb) bt #0  in _TIFFVGetField (tif=<optimized out>, at #1  in TIFFGetField (tif=<optimized out>, at #2  in cpTag count=<optimized out>,      type=<optimized out>) at #3  in cpTags (out=<optimized out>, in=<optimized out>) at #4  cpIFD (out=<optimized out>, in=<optimized out>) at #5  main (argc=<optimized out>, argv=<optimized out>) at (gdb)      2) gdb thumbnail b main b     //  if (!cpIFD(in, out) || !TIFFWriteDirectory(out)), this function is called many times b b b     //  CopyField(tag, shortv); b      //  status = TIFFVGetField(tif, tag, ap), this function is called many times b   r poc1.tiff out.tiff   (gdb) r poc1.tiff out.tiff Starting program: /usr/local/bin/thumbnail poc1.tiff out.tiff TIFFReadDirectoryCheckOrder: Warning, Invalid TIFF directory; tags are not sorted in ascending order. TIFFReadDirectory: Warning, Unknown field with tag (0xffff) encountered. TIFFReadDirectory: Warning, Unknown field with tag encountered. TIFFReadDirectory: Warning, Unknown field with tag encountered. TIFFReadDirectory: Warning, Unknown field with tag encountered. TIFFReadDirectory: Warning, Unknown field with tag encountered. TIFFReadDirectory: Warning, Unknown field with tag encountered. TIFFReadDirectory: Warning, Unknown field with tag encountered. TIFFReadDirectory: Warning, Unknown field with tag encountered. TIFFFetchNormalTag: Warning, Incorrect count for "ModeNumber"; tag ignored. TIFFFetchNormalTag: Warning, ASCII value for tag "Software" contains null byte in value; value incorrectly truncated during reading due to implementation limitations. TIFFReadDirectory: Warning, Ignoring ColorMap since BitsPerSample tag not found. TIFFReadDirectory: Warning, TIFF directory is missing required "StripByteCounts" field, calculating from imagelength.   ...... ...... Breakpoint 1, TIFFGetField at = TIFFVGetField(tif, tag, ap); (gdb) bt #0  TIFFGetField at #1  in cpTag      type=type@...ry=TIFF_ASCII) at #2  in generateThumbnail at #3  main (argc=<optimized out>, argv=<optimized out>) at (gdb) c Continuing.   Breakpoint 1, TIFFGetField at = TIFFVGetField(tif, tag, ap); (gdb) bt #0  TIFFGetField at #1  in cpTag      type=type@...ry=TIFF_ASCII) at #2  in generateThumbnail at #3  main (argc=<optimized out>, argv=<optimized out>) at ...... ...... Breakpoint 1, TIFFGetField at = TIFFVGetField(tif, tag, ap); ...... ...... (gdb) c Continuing.   Breakpoint 1, TIFFGetField at = TIFFVGetField(tif, tag, ap); (gdb) c Continuing.   Program received signal SIGSEGV, Segmentation fault. in _TIFFVGetField (tif=<optimized out>, at void **) = tv->value; (gdb) c     When , crash happens   3) If we make a breakpoint in      Program received signal SIGSEGV, Segmentation fault. in _TIFFVGetField (tif=<optimized out>, at void **) = tv->value; (gdb) bt #0  in _TIFFVGetField (tif=<optimized out>, at #1  in TIFFGetField (tif=<optimized out>, at #2  in cpTag count=<optimized out>,      type=<optimized out>) at #3  in cpTags (out=<optimized out>, in=<optimized out>) at #4  cpIFD (out=<optimized out>, in=<optimized out>) at #5  main (argc=<optimized out>, argv=<optimized out>) at (gdb) list (fip->field_type == TIFF_ASCII    || fip->field_readcount == TIFF_VARIABLE    || fip->field_readcount == TIFF_VARIABLE2    || fip->field_readcount == TIFF_SPP    || tv->count > 1) { void **) = tv->value;        //   tv->value = 1; else { *val = (char *)tv->value; tv->count == 1 ); (gdb)      memory error can be detected by asan and log as follows:   AddressSanitizer: stack-buffer-overflow on address at pc bp sp 0xbfabcc8c WRITE of size 4 at thread T0     #0 in _TIFFVGetField     #1 in TIFFVGetField     #2 in TIFFGetField     #3 in cpTag     #4 in cpTags     #5 in cpIFD     #6 in main     #7 in __libc_start_main     #8   Address is located in stack of thread T0 at offset 96 in frame     #0 in cpTag     This frame has 7 object(s):     [32, 34) 'shortv1'     [96, 98) 'shortv1' <== Memory access at offset 96 partially overflows this variable     'tr'     'tg'     'tb'     'doubleav'     'ifd8' HINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext       (longjmp and C++ exceptions *are* supported) SUMMARY: AddressSanitizer: stack-buffer-overflow _TIFFVGetField Shadow bytes around the buggy address:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1   f1 f1 04 f4 f4 f4 f3 f3 f3 f3 00 00 00 00 00 00   00 00 00 00 f1 f1 f1 f1 02 f4 f4 f4 f2 f2 f2 f2 f4 f4 f2 f2 f2 f2 04 f4 f4 f4 f2 f2 f2 f2   04 f4 f4 f4 f2 f2 f2 f2 04 f4 f4 f4 f2 f2 f2 f2   04 f4 f4 f4 f2 f2 f2 f2 00 f4 f4 f4 f3 f3 f3 f3   00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1   02 f4 f4 f4 f3 f3 f3 f3 00 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 Shadow byte legend (one shadow byte represents 8 application bytes):   Addressable:           00   Partially addressable: 01 02 03 04 05 06 07    Heap left redzone:       fa   Heap right redzone:      fb   Freed heap region:       fd   Stack left redzone:      f1   Stack mid redzone:       f2   Stack right redzone:     f3   Stack partial redzone:   f4   Stack after return:      f5   Stack use after scope:   f8   Global redzone:          f9   Global init order:       f6   Poisoned by user:        f7   Contiguous container OOB:fc   ASan internal:           fe     #################################### 2) heap buffer overflow in bmp2tiff ####################################   Memory corruption bugs can be triggered when bmp2tiff handling maliciously crafted bmp file, it will cause the target application to crash.   overview:   alloc workflow:   --> bmp2tiff.c:line , comprbuf = (unsigned char *) _TIFFmalloc( compr_size )  // allocate space for compressed scanline buffer     --> allocate space for compressed scanline buffer              --> _TIFFmalloc in libtiff/tif_unix.c:line  	        --> call malloc   read workflow : from bmp2tiff.c:line to line               if (comprbuf[i] == 0) /* Next scanline */              i++;      else if (comprbuf[i] == 1) /* End of image */              break;      else if (comprbuf[i] == 2) { /* Move to... */              i++;              if (i < compr_size - 1) {                   j+=comprbuf[i]+comprbuf[i+1]*width;   // line                   i += 2;          } 										 bmp2tiff.c:line deals with comprbuf and does not check the length of Image width.     memory error can be detected by asan and log as follows:   ./bmp2tiff 1.tiff ================================================================= AddressSanitizer: heap-buffer-overflow on address at pc bp sp READ of size 1 at thread T0     #0 in main     #1 in __libc_start_main     #2   is located 0 bytes to the right of 25-byte region allocated by thread T0 here:     #0 in __interceptor_malloc     #1 in _TIFFmalloc     #2 in main     #3 in __libc_start_main   SUMMARY: AddressSanitizer: heap-buffer-overflow main Shadow bytes around the buggy address:   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 00 00   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa Shadow byte legend (one shadow byte represents 8 application bytes):   Addressable:           00   Partially addressable: 01 02 03 04 05 06 07    Heap left redzone:       fa   Heap right redzone:      fb   Freed heap region:       fd   Stack left redzone:      f1   Stack mid redzone:       f2   Stack right redzone:     f3   Stack partial redzone:   f4   Stack after return:      f5   Stack use after scope:   f8   Global redzone:          f9   Global init order:       f6   Poisoned by user:        f7   Contiguous container OOB:fc   ASan internal:           fe   #################################### 3) heap buffer overflow in bmp2tiff ####################################   Memory corruption bugs can be triggered when bmp2tiff handling maliciously crafted bmp file, it will cause the target application to crash.   overview:   alloc workflow:   --> bmp2tiff.c:line , uncomprbuf = (unsigned char *)_TIFFmalloc(uncompr_size)  //allocate space for uncompressed scanline buffer     --> allocate space for compressed scanline buffer              --> _TIFFmalloc in libtiff/tif_unix.c:line  		 read workflow : from bmp2tiff.c:line to line     -->    //  if (TIFFWriteScanline(out, uncomprbuf + (length - row - 1) * width, row, 0) < 0)      -->    //  status = (*tif->tif_encoderow)(tif, (uint8*) buf, tif->tif_scanlinesize, sample);         --> tif_packbits.c:85   //  PackBitsEncode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s) -->  for (; cc > 0 && b == *bp; cc--, bp++)   PackBitsEncode.c:line 85 does not check the length of bp passed through buf.   memory error can be detected by asan and log as follows:   ./bmp2tiff 1.tiff================================================================= AddressSanitizer: heap-buffer-overflow on address at pc bp sp READ of size 1 at thread T0     #0 in PackBitsEncode     #1 in TIFFWriteScanline     #2 in main     #3 in __libc_start_main     #4   is located 0 bytes to the right of region allocated by thread T0 here:     #0 in __interceptor_malloc     #1 in _TIFFmalloc     #2 in main     #3 in __libc_start_main   SUMMARY: AddressSanitizer: heap-buffer-overflow PackBitsEncode Shadow bytes around the buggy address:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa Shadow byte legend (one shadow byte represents 8 application bytes):   Addressable:           00   Partially addressable: 01 02 03 04 05 06 07    Heap left redzone:       fa   Heap right redzone:      fb   Freed heap region:       fd   Stack left redzone:      f1   Stack mid redzone:       f2   Stack right redzone:     f3   Stack partial redzone:   f4   Stack after return:      f5   Stack use after scope:   f8   Global redzone:          f9   Global init order:       f6   Poisoned by user:        f7   Contiguous container OOB:fc   ASan internal:           fe      ------------------ From Debug_Orz          ------------------ 原始邮件 ------------------ 发件人: "Jodie Cunningham";<jodie.cunningham@...il.com>; 发送时间: 收件人: "oss-security"<oss-security@...ts.openwall.com>;   主题: Re: [oss-security] 3 bugs refer to buffer overflow in in libtiff    On Tue, Apr 26, at PM, PXO炳林 wrote: > > Hello oss-security, > > I did some test and found three bugs refer to buffer overflow: one stack > buffer overflow in thumbnail and two buffer overflows in bmp2tiff. > > Please let me know whether CVE Identifier number could be assigned. > > Overview: > > Running each poc file crashes thumbnail and bmp2tiff made with > AddressSanitizer in I have attached poc and log files . > ------------------ > From Debug_Orz >   Is there a patch upstream? Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      