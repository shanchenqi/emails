  oss-security - cve request: local DoS by overflowing kernel mount table using  shared bind mount            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [thread-next>] [day] [month] [year] [list]  Date: Wed, 13 Jul (EDT) From: CAI Qian <caiqian@...hat.com> To: oss-security@...ts.openwall.com Cc: cve-assign@...re.org Subject: cve request: local DoS by overflowing kernel mount table using  shared bind mount  Below is the discussion between myself and staffs from security@...nel.org.    CAI Qian  === Initial Report === It was reported that the mount table expands by a power-of-two with each bind mount command. This is a change of behavior against the older kernel (i.e., Hence, the older kernel won't be affected or harder to exploit.  If the system is configured in the way that a non-root user allows bind mount even if with limit number of bind mount allowed, a non-root user could cause a local DoS by quickly overflow the mount table. For example,  $ cat /etc/fstab ... /tmp/1        /tmp/2        none        user,bind        0         0  Even if the application could say only allow 30 bind mounts to increase the security.  $ for i in `seq 1 20`; do mount /tmp/1; done $ mount | wc -l  Once this happened, it will cause a deadlock for the whole system,  [ NMI backtrace for cpu 0 [ CPU: 0 PID: 29 Comm: kworker/0:1 Not tainted #1 [ Hardware name: QEMU Standard PC + PIIX, BIOS [ Workqueue: events qxl_fb_work [qxl] [ task: ti: task.ti: [ RIP: [ RSP:  EFLAGS: [ RAX: RBX: RCX: [ RDX: RSI: RDI: [ RBP: R08: R09: [ R10: R11: R12: [ R13: R14: R15: [ FS: [ CS: DS: ES: CR0: [ CR2: CR3: CR4: [ DR0: DR1: DR2: [ DR3: DR6: DR7: [ Stack: [ [ [ [ Call Trace: [ [ ? [ [ [ [ [ [ [ ? [ [ ? [ [ [ [ [ [drm] [ [qxl] [ ? [qxl] [ [qxl] [ [qxl] [ [qxl] [ [qxl] [ [qxl] [ [ [ ? [ [ ? [ [ ? [ Code: 0f 1f 84 00 00 00 00 00 0f 1f 44 00 00 55 48 89 e5 41 57 41 56 49 89 f6 41 55 4c 8d af 50 fc ff ff 41 54 53 4c 8b 46 08 48 89 fb <4d> 85 c0 74 09 f6 06 80 0f 84 2f 01 00 00 48 8b 83 80 fc ff ff [ Kernel panic - not syncing: hung_task: blocked tasks  === From Al Viro === the number of vfsmounts getting propagation from /tmp is doubling on each step.  You are asking to take a subtree at /tmp/2 and attach it to /tmp/1 *and* *all* *existing* peers.  Turning all copies into peers of what was on /tmp/2.  So after the first mount --bind you get two vfsmounts - /tmp and /tmp/1. And the damn things are peers - you mount anything on /tmp/1/shit, you get its clone attached to the matching directory (/2/shit) in /tmp.  After the second mount --bind you've got two more vfsmounts - one overmounting /tmp/1 and another - /tmp/2.  And again, all of them constitute one peer group. With 4 elements now.  Etc.  === From Eric W. Biederman === First let's be clear, it is systemd that calls MS_SHARED|MS_REC on /.  Furthermore the configuration interface for mount propagation is error prone and pretty much requires the most problematic cases be the default makine the interfaces very easy to use incorrectly.  Especially for code that was only tested on systems prior to systemd.   All of this is currently allowed if a user namespace creates a mount namespace so the concern is real.  Of course we also allow using as much memory as we want with virtual addresses as well.  It is slightly worse on 32bit in that it is kernel memory we are consuming and not user memory.  Still it is just another form of unlimited memory consumption that is causing the problem.  We have cases where in typical deployments we allow users to consume all of the memory on the system.   That said this definitely is a case where we could set a reasonable upper limits on the number mount objects and catch it when people do crazy things by accident before the system gets stuck in an OOM.   I am in the process of cooking up a number up limits of that kind and I will see about adding a limit on the number of mounts as well.  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      