  oss-security - Re: snprintf return value misuse in a lot of projects            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [<thread-prev] [day] [month] [year] [list]  Date: Sat, 13 Feb From: Alexander Cherepanov <ch3root@...nwall.com> To: oss-security@...ts.openwall.com Subject: Re: snprintf return value misuse in a lot of projects  On Yuriy M. Kaminskiy wrote: > I noticed dangerous pattern in a lot of projects, where snprintf(3) > return value is used without checking, with potentially disasterous > consequences:  It's kinda a known. E.g., some such patterns are listed in  .  The same problem is with strlcpy.  > And there are yet another very common pattern: > >    p += snprintf(p, end-p,[....]); >    p += snprintf(p, end-p,[....]); >    p += snprintf(p, end-p,[....]); >    ... > > which may be 'barely safe' by posix (if you'd read `man 3posix snprintf`, > you'd expect 2nd line is [somewhat] safe (end-p is negative, then > casted to size_t and produce value larger than (size_t)INT_MAX, that > should result in error EOVERFLOW), and third and following will dance > around last byte, likely remaining safe), but it is TOTALLY > broken on glibc, as glibc's snprintf DOES NOT follow posix, and accepts > *any* size.  For a glibc discussion please see  .  As for POSIX, the requirement of EOVERFLOW for a big second parameter is  a (rejected) bug in POSIX --  . A closely related bug -- .  ISO C describes the size parameter of snprintf as a limit to the number  of output characters written, without any connections to the size of the  buffer. Thus, the following examples are valid in ISO C:     char s[10];    snprintf(s, 20, "abc");    snprintf(s, SIZE_MAX, "%s", "abc");  OTOH POSIX describes the size parameter as the actual size of the buffer  (bug and requires to reject buffers of size larger than INT_MAX  (bug  Even though POSIX contradicts ISO C in this question (while formally  deferring to ISO C) there is a sentiment that the POSIX approach is  better for safety/security. (E.g., it was expressed during the recent  discussion about strlcpy/strlcat in the glibc mailing list.)  As it turned out, the same problem affects the fread function, with the  Linux kernel instead of POSIX contradicting ISO C. See  and  .  Perhaps this is a topic that will benefit from input from a wider community.  --  Alexander Cherepanov  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      