  oss-security - Re: CVE Request -- Broadcom Wifi Driver Brcmfmac  Buffer Overflow            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [<thread-prev] [thread-next>] [day] [month] [year] [list]  Date: Thu, 13 Oct From: freener <freener.gdx@...il.com> To: oss-security@...ts.openwall.com Subject: Re: CVE Request -- Broadcom Wifi Driver Brcmfmac  Buffer Overflow  hi,     I found a stack buffer overflow vulnerability in Broadcom wifi driver brcmfmac, this issue has been fixed, I would like to request a CVE-ID for this issue.  Description =========  module in kernel is the main interface to operate on wifi. This module defines an operation data structure which stores many commands and callback functions to control the wifi, and those callback functions are implemented in wifi driver finally, executables can communicate with this module by netlink socket.  To trigger the bug the exploit should send a or command to socket in kernel. is equal with according with the definition in Hostapd uses         static struct genl_ops = {                  ...                  {                          .cmd =                          .policy =                          .flags = GENL_ADMIN_PERM,                          .doit  =                          .internal_flags = |                  },                  ...        }  When kernel receives the command then it will call function,  but it requries executable owns CAP_NET_ADMIN permission.  In it will parse the data received from user, and store the result in structureă         static int struct sk_buff *skb, struct genl_info *info ) {                 ...                 struct params;                 ...                 memset( &params,  0, sizeof(params) );                 ...                 err = info, &params.beacon );                  if ( ) {                          params.ssid = nla_data( );                          params.ssid_len = nla_len( );                          if ( params.ssid_len == 0 || params.ssid_len > )                                  return -EINVAL;                 }                 ...                err = rdev_start_ap( rdev, dev, &params );                ...        }        struct { 	    struct chandef;  	    struct beacon;  	     int beacon_interval, dtim_period; 	     const u8 *ssid; 	     size_t ssid_len; 	     enum hidden_ssid; 	     struct crypto; 	     bool privacy; 	     enum auth_type; 	     int inactivity_timeout; 	     u8 p2p_ctwindow; 	     bool p2p_opp_ps; 	     const struct *acl; 	     bool radar_required;        };         struct {               const u8 *head, *tail;               const u8 *beacon_ies;               const u8 *proberesp_ies;               const u8 *assocresp_ies;               const u8 *probe_resp;               size_t head_len, tail_len;              size_t beacon_ies_len;              size_t proberesp_ies_len; 	     size_t assocresp_ies_len; 	     size_t probe_resp_len;         };  It also does many checks, the interface type must be or and data must contain informations about Finally it will call rdev_start_ap function.  is optional, user can send a netlink packet which does not contain information about so params.ssid and params.ssid_len will be 0. It's the key point in the exploit.         static inline int rdev_start_ap( struct *rdev, struct net_device *dev, struct *settings ) {                 ...                 ret = rdev->ops->start_ap( &rdev->wiphy, dev, settings );                 ...        }  rdev_start_ap will call the callback function defined in brcmfmac driver.        static struct = {               ...               .start_ap =               ...       }  If the netlink packet does not contian info about will call brcmf_parse_tlvs to parse head data further. The data format is TLV (Type, Length, Value ), it will parse type WLAN_EID_SSID info in data, all those datas are controlled by user. It does not check the length of data before calling memcpy to copy the data to stack buffer. The length of stack buffer ssid_le.SSID is 32, so we can construct a malicous data packet in command, and make WLAN_EID_SSID's length large then 32. When it copies the data, it will overflow the stack buffer.           struct *settings ) {                s32  ie_offset;                struct brcmf_tlv *ssid_ie;                struct brcmf_ssid_le ssid_le;                 memset( &ssid_le, 0, sizeof(ssid_le) );                 if  ( settings->ssid == NULL || settings->ssid_len == 0 ) {                         ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;                         ssid_ie = brcmf_parse_tlvs( (u8 *)&settings->beacon.head[ie_offset], settings->beacon.head_len - ie_offset, WLAN_EID_SSID );                        if ( !ssid_ie )                               return -EINVAL;                        memcpy( ssid_le.SSID, ssid_ie->data, ssid_ie->len );   //overflow here.                       ssid_le.SSID_len = cpu_to_le32( ssid_ie->len );                }                else {                       memcpy( ssid_le.SSID, settings->ssid, settings->ssid_len );                       ssid_le.SSID_len = cput_to_le32( (u32)settings->ssid_len);                }                ...       }   Credit ===== This issue was discovered by Daxing Guo of Tencent's Xuanwu Lab   Patch =====  freener <freener.gdx@...il.com>:  > hi, > >     This is a buffer overflow vulnerability in wifi driver brcmfmac. > >     The vulnerability has been patched in in Linux kernel and > >      > > >      thanks. >   Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      