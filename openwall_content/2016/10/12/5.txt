  oss-security - bubblewrap LPE            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [thread-next>] [day] [month] [year] [list]  Date: Wed, 12 Oct From: Sebastian Krahmer <krahmer@...e.com> To: oss-security@...ts.openwall.com Subject: bubblewrap LPE   Hi  There is a beautiful, easy to exploit, logical bug within the bubblewrap program, thats part of the flatpak container-app framework, but also used with other container solutions.  /usr/bin/bwrap may be installed mode or with cap_sys_admin and other file caps. I dont know if there are any dists already shipping it that way, but the Makefile and some RedHat spec files contain file caps for it.  bubblewrap's aim is to setup a container and seccomp sandbox for programs to be run as user.  For some reason it sets the PR_SET_DUMPABLE flag, as seen below. The comment about it looks strange to me. If thats really true, suid programs shouldn't be forced to play with the dumpable flag to achieve their goal.  Once the dumpable flag is set, there is a chance we could attach to the process, once the remaining caps are dropped and the whole process runs as user.  Luckily, that happens at line right after a PrivSep socket has been opened!  Once attached to the (now running as unprived user) process, we can inject commands into that socket. We could do arbitrary mounts, but won't achieve much, since the bwrap process is running in its own mount namespace. However, there is a sethostname() OP, that we can use to affect the hostname of the entire system (not restricted to UTS namespace). Now, just wait for root or other users to login and execute bash to use one of the PS expansion bugs to execute code.  (I wonder that has been re-discovered recently, it was already part of the attack vector.)    acquire_caps (void)  {  [...]     /* We need the process to be dumpable, or we can't access /proc/self/uid_map */    if (prctl (PR_SET_DUMPABLE, 1, 0, 0, 0) < 0)      die_with_error ("prctl(PR_SET_DUMPABLE) failed");  }   [...]   int main (int    argc,       char **argv) {  [...]    /* Get the (optional) capabilities we need, drop root */   acquire_caps ();  [...]    if (is_privileged)     {       pid_t child;       int privsep_sockets[2];       if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0)         die_with_error ("Can't create privsep socket");       child = fork ();       if (child == -1)         die_with_error ("Can't fork unprivileged helper");       if (child == 0)         {           /* Unprivileged setup process */           drop_caps ();                                                            // BOOM           close (privsep_sockets[0]);           setup_newroot (opt_unshare_pid, privsep_sockets[1]);           exit (0);         }       else         {           uint32_t  /* 8k, but is int32 to guarantee nice alignment */           uint32_t op, flags;           const char *arg1, *arg2;           cleanup_fd int unpriv_socket = -1;           unpriv_socket = privsep_sockets[0];           close (privsep_sockets[1]);           do             {               op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer),                                      &flags, &arg1, &arg2);               privileged_op (-1, op, flags, arg1, arg2);               if (write (unpriv_socket, buffer, 1) != 1)                 die ("Can't write to op_socket");             }           while (op != PRIV_SEP_OP_DONE);           /* Continue post setup */         }     }    -s  --   ~ perl self.pl ~ ~ krahmer@...e.com - SuSE Security Team   Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      