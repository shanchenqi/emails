  oss-security - libxml2: stack overflow in xml validator  (parser)            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Tue, 3 May From: Simon Lees <sflees@...e.de> To: fulldisclosure@...lists.org, oss-security@...ts.openwall.com,  security@...me.org, security@...e.com Subject: libxml2: stack overflow in xml validator  (parser)  Hi This is a disclosure of the following issue that was raised a week ago on the distro's mailing list. Both bugs on the gnome bugtracker are currently private and should be made public now. The two attached patches are based off the libxml2 release.  A couple of weeks back while working on a related bug I discovered a specially created xml file is capable of triggering a stack overflow before libxml2 can detect its a invalid xml file.  We raised this issue upstream on and informed them that we would place a two week embargo on the issue in case we didn't here back. As of yet we have had no response so we have posted here.  We intend to keep the current embargo (ending May 3) unless we get advise otherwise here. Below is a script to generate the xml file along with a tested patch to fix the issue. I will also include our unpublished patch and simplified reproducer for as again we have had no response upstream and its likely that you will want to fix this less severe issue at the same time.  python3 repoducer.py ; xmllint repo.xml  repoducer.py ----------------------------------------------------------------------- #!/bin/python3  f = open('repo.xml', 'w')  f.write( "<!DOCTYPE a [ ")  i = 1  while (i <     f.write ("<!ENTITY a" + str(i) + " \"&a" + str(i+1) + ";\">")     i = i+1  f.write("<!ENTITY a" + str(i+1) + " \"&a1;\">]> <bruces bogans=\"&a1;\">")  f.close() -----------------------------------------------------------------------  Patch for this issue. ----------------------------------------------------------------------- From: Peter Simons <psimons@...e.com> Date: Fri, 15 Apr Subject: Add missing increments of recursion depth counter to XML  parser.  The functions xmlParserEntityCheck() and xmlParseAttValueComplex() used to call xmlStringDecodeEntities() in a recursive context without incrementing the 'depth' counter in the parser context. Because of that omission, the parser failed to detect attribute recursions in certain documents before running out of stack space. ---  parser.c | 8 ++++++++  1 file changed, 8 insertions(+)  diff --git a/parser.c b/parser.c index --- a/parser.c +++ b/parser.c @@ @@ xmlParserEntityCheck(xmlParserCtxtPtr ctxt, size_t size,   	ent->checked = 1;  +        ++ctxt->depth;  	rep = xmlStringDecodeEntities(ctxt, ent->content,  				  XML_SUBSTITUTE_REF, 0, 0, 0); +        --ctxt->depth;   	ent->checked = (ctxt->nbentities - oldnbent + 1) * 2;  	if (rep != NULL) { @@ @@ xmlParseEntityValue(xmlParserCtxtPtr ctxt, xmlChar **orig) {  	 * an entity declaration, it is bypassed and left as is.  	 * so XML_SUBSTITUTE_REF is not set here.  	 */ +        ++ctxt->depth;  	ret = xmlStringDecodeEntities(ctxt, buf, XML_SUBSTITUTE_PEREF,  				      0, 0, 0); +        --ctxt->depth;  	if (orig != NULL)  	    *orig = buf;  	else @@ @@ xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {  		} else if ((ent != NULL) &&  		           (ctxt->replaceEntities != 0)) {  		    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) { +			++ctxt->depth;  			rep = xmlStringDecodeEntities(ctxt, ent->content,  						      XML_SUBSTITUTE_REF,  						      0, 0, 0); +			--ctxt->depth;  			if (rep != NULL) {  			    current = rep;  			    while (*current != 0) { /* non input consuming */ @@ @@ xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {  			(ent->content != NULL) && (ent->checked == 0)) {  			unsigned long oldnbent = ctxt->nbentities;  +			++ctxt->depth;  			rep = xmlStringDecodeEntities(ctxt, ent->content,  						  XML_SUBSTITUTE_REF, 0, 0, 0); +			--ctxt->depth;   			ent->checked = (ctxt->nbentities - oldnbent + 1) * 2;  			if (rep != NULL) { --   -----------------------------------------------------------------------  - simplified reproducers echo '<!DOCTYPE b [ <!ENTITY b "&b;"> ]> <b b="&b;">' | xmllint -recover - echo '<!DOCTYPE b [ <!ENTITY b "&c;"> <!ENTITY c "&d;"> <!ENTITY d "&b;">]> | xmllint -recover - -----------------------------------------------------------------------   - Patch ----------------------------------------------------------------------- From: Peter Simons <psimons@...e.com> Date: Thu, 14 Apr Subject: [PATCH] xmlStringGetNodeList: limit the function to recursions  to avoid  This patch prevents stack overflows like the one reported in ---  tree.c | 14 ++++++++++++--  1 file changed, 12 insertions(+), 2 deletions(-)  diff --git a/tree.c b/tree.c index --- a/tree.c +++ b/tree.c @@ @@ out:      return(ret);  }  +static xmlNodePtr xmlStringGetNodeListInternal(const xmlDoc *doc, const xmlChar *value, size_t recursionLevel); +  /**   * xmlStringGetNodeList:   * @doc:  the document @@ @@ out:   */  xmlNodePtr  xmlStringGetNodeList(const xmlDoc *doc, const xmlChar *value) { +  return xmlStringGetNodeListInternal(doc, value, 0); +} + +static xmlNodePtr +xmlStringGetNodeListInternal(const xmlDoc *doc, const xmlChar *value, size_t recursionLevel) {      xmlNodePtr ret = NULL, last = NULL;      xmlNodePtr node;      xmlChar *val; @@ @@ xmlStringGetNodeList(const xmlDoc *doc, const xmlChar *value) {      xmlEntityPtr ent;      xmlBufPtr buf;  +    if (recursionLevel > return(NULL); +      if (value == NULL) return(NULL);       buf = xmlBufCreateSize(0); @@ @@ xmlStringGetNodeList(const xmlDoc *doc, const xmlChar *value) {  			else if ((ent != NULL) && (ent->children == NULL)) {  			    xmlNodePtr temp;  -			    ent->children = xmlStringGetNodeList(doc, -				    (const xmlChar*)node->content); +			    ent->children = xmlStringGetNodeListInternal(doc, +				    (const xmlChar*)node->content, +                                    recursionLevel+1);  			    ent->owner = 1;  			    temp = ent->children;  			    while (temp) { --   -----------------------------------------------------------------------  Cheers  --   Simon Lees (Simotek)                            http://simotek.net  Emergency Update Team                           keybase.io/simotek SUSE Linux                            Adeliade Australia, GPG Fingerprint: DB9D 88DC CEC5  View attachment of type "text/x-patch" bytes)  View attachment of type "text/x-patch" bytes)  Download attachment "signature.asc" of type "application/pgp-signature" bytes)  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      