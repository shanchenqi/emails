  oss-security - Re: CVE request: Multiple vunerabilities in libdwarf & dwarfdump            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [<thread-prev] [day] [month] [year] [list]  Date: Tue, 24 May (EDT) From: cve-assign@...re.org To: Cc: cve-assign@...re.org, oss-security@...ts.openwall.com, davea42@...uxmail.org Subject: Re: CVE request: Multiple vunerabilities in libdwarf & dwarfdump  -----BEGIN PGP SIGNED MESSAGE----- Hash:  > And anther one  > There is a NULL pointer dereference bug in and latest git code. >  > The bug is at file >              byte_length++; >              if (byte_length > BYTESLEBMAX) { >                  /*  Erroneous input. What to do? >                      Abort? Return error? Just stop here?*/ >                  = BYTESLEBMAX;               <- $pc >                  return number; >              } >          } >  > which triggered by >              *return_sval = (Dwarf_Signed) ret_value; >              return DW_DLV_OK; >              } >  >          case DW_FORM_sdata: >              ret_value = >                  NULL)); >              *return_sval = ret_value; >              return DW_DLV_OK; >   Use   > >  >  id: >  >  cve: >  >  datereported: >  >  reportedby: Yue Liu >  >  vulnerability: Null dereference in print_frame_inst_bytes (dwarfdump) >  >  product: libdwarf >  >  description: The null dereference is due to a corrupted object file. >  Libdwarf was not dealing with empty (bss-like) sections since it really >  did not expect to see such in sections it reads! Now libdwarf catches the >  object error so dwarfdump sees the section as empty (as indeed it is!). >  >  datefixed: >  >  references: >  >  gitfixid: >  >  tarrelease:  Use   > >  >  id: >  >  cve: >  >  datereported: >  >  reportedby: Yue Liu >  >  vulnerability: Null dereference in create_fullest_file_path(). >  >  product: libdwarf >  >  description: The null dereference in create_fullest_file_path() causes a >  crash. This is due to corrupted dwarf and the fix detects this corruption >  and if that null string pointer happens undetected a static string is >  substituted so readers can notice the situation. >  >              } >             if (dirno > 0 && fe->fi_dir_index > 0) { >                 inc_dir_name = (char *) >                         line_context->lc_include_directories[ >                     fe->fi_dir_index - 1]; >                 incdirnamelen = strlen(inc_dir_name);  <- $pc >             } >             full_name = (char *) _dwarf_get_alloc(dbg, > #0  create_fullest_file_path (dbg=<optimized out>, > name_ptr_out=<optimized > out>, at > #1  in dwarf_filename (context=<optimized > out>, fileno_in=<optimized out>, > at > #2  dwarf_linesrc (line=<optimized out>, > ret_linesrc=<optimized out>, error=<optimized out>) at > >  >  >  datefixed: >  >  references: >  >  gitfixid: >  >  tarrelease:  Use   > >  >  id: >  >  cve: >  >  datereported: >  >  reportedby: Yue Liu >  >  vulnerability: Null dereference bug in >  _dwarf_calculate_info_section_end_ptr(). >  >  product: libdwarfj >  >  description: NULL dereference bug in >  _dwarf_calculate_info_section_end_ptr(). >  >         Dwarf_Off off2 = 0; >         Dwarf_Small *dataptr = 0; > >         dbg = context->cc_dbg; >         dataptr = context->cc_is_info? dbg->de_debug_info.dss_data:                 <- $pc >             dbg->de_debug_types.dss_data; >         off2 = context->cc_debug_offset; >         info_start = dataptr + off2; >         info_end = info_start + context->cc_length + > #0  _dwarf_calculate_info_section_end_ptr > (context=context@...ry=0x0) at > #1  in > _dwarf_extract_string_offset_via_str_offsets > > "", > attrform=attrform@...ry=26, cu_context=0x0, > > at > #2  in dwarf_get_macro_defundef > > op_number=op_number@...ry=1, > > > > > > at > ------ > _dwarf_calculate_info_section_end_ptr (context=context@...ry=0x0) at >   >        dataptr = context->cc_is_info? dbg->de_debug_info.dss_data: > gef> p/x $rdi > $4 = 0x0 >  >  >  datefixed: >  >  references: >  >  gitfixid: >  >  tarrelease:  Use  However, is this a typo or is there a "libdwarfj" library?   > >  >  id: >  >  cve: >  >  datereported: >  >  reportedby: Yue Liu >  >  vulnerability: Invalid dwarf leads to dwarfdump crash in >  print_frame_inst_bytes. >  >  product: dwarfdump >  >  description: Corrupted dwarf crashes dwarfdump >  >         } >         len = len_in; >         endpoint = instp + len; >         for (; len > 0;) { >             unsigned char ibyte = *instp;           <- $pc >             int top = ibyte & 0xc0; >             int bottom = ibyte & 0x3f; >             int delta = 0; >             int reg = 0; > #0  print_frame_inst_bytes > cie_init_inst=<optimized out>, len_in=<optimized out>, > data_alignment_factor=-4, code_alignment_factor=4, > addr_size=addr_size@...ry=4, offset_size=4, version=3, > <g_config_file_data>) > at > #1  in print_one_cie > cie=<optimized out>, > cie_index=cie_index@...ry=2, address_size=<optimized out>, > <g_config_file_data>) > at > #2  in print_frames > print_debug_frame=print_debug_frame@...ry=1, print_eh_frame=0, > <g_config_file_data>) > at > gef> p/x $r13 > $1 = > gef> p/x *$r13 > Cannot access memory at address >  >  >  datefixed: >  >  references: >  >  gitfixid: >  >  tarrelease:  If the vulnerability is specific to dwarfdump, and is not present in libdwarf itself, then we need additional analysis from you before assigning a CVE ID. "crashes dwarfdump" is not sufficient because we think that dwarfdump has no need to remain running after a bad file is encountered. There cannot be a CVE ID if a simple and complete workaround for the crash problem is to not try to dump that file again. If you believe the crash is potentially exploitable for code execution, please provide further information about that.   > >  >  id: >  >  cve: >  >  datereported: >  >  reportedby: Yue Liu >  >  vulnerability: OOB read bug in print_frame_inst_bytes() >  >  product: libdwarf >  >  description: Test object shows an invalid read in >  print_frame_inst_bytes(). >  >         for (; len > 0;) { >             unsigned char ibyte = *instp;           <- $pc >             int top = ibyte & 0xc0; > #0  print_frame_inst_bytes >    cie_init_inst=<optimized out>, data_alignment_factor=-4, >    code_alignment_factor=1, addr_size=addr_size@...ry=4, offset_size=4, >    version=3, >    <g_config_file_data>) at > #1  in print_one_cie >    cie=<optimized out>, cie_index=cie_index@...ry=1, >    address_size=<optimized out>, config_data= >    <g_config_file_data>) at > #2  in print_frames >    print_debug_frame=print_debug_frame@...ry=1, print_eh_frame=0, >    <g_config_file_data>) >    at > gef> x/10x $r13 >       Cannot access memory at address > gef> p/x $r13 > $14 = >  >  >  datefixed: >  >  references: >  >  gitfixid: >  >  tarrelease:  Use   > >  >  id: >  >  cve: >  >  datereported: >  >  reportedby: Yue Liu >  >  vulnerability: OOB read bug in dwarf_get_xu_hash_entry() >  >  product: libdwarf >  >  description: Test object shows an invalid read in dwarf_get >  _xu_hash_entry, lin >  > #0  dwarf_get_xu_hash_entry >    hash_value= >    >    >    at > #1  in _dwarf_search_fission_for_key ( >    percu_index_out=<synthetic pointer>, >    at > #2  dwarf_get_debugfission_for_key >    >    "tu", >    at >  >  >  datefixed: >  >  references: >  >  gitfixid: >  >  tarrelease:  Use   > >  >  id: >  >  cve: >  >  datereported: >  >  reportedby: Yue Liu >  >  vulnerability: OOB read bug in print_exprloc_content >  >  product: libdwarf >  >  description: Test object shows an invalid write in print_exprloc_content. >  > #0  print_exprloc_content >    >    showhextoo=1) at > #1  in get_attr_value >    tag=<optimized out>, >    dieprint_cu_goffset=dieprint_cu_goffset@...ry=11, >    srcfiles=srcfiles@...ry=0x0, >    cnt=cnt@...ry=0, show_form=0, >    local_verbose=0) at >  >  >  datefixed: >  >  references: >  >  gitfixid: >  >  tarrelease:  Use   > >  >  id: >  >  cve: >  >  datereported: >  >  reportedby: Yue Liu >  >  vulnerability: OOB write. From relocation records >  >  product: libdwarf >  >  description: Test object shows an invalid write in dwarf_elf_access.c >  (when doing the relocations). Adding the relocation value to anything >  overflowed and disguised the bad relocation record. With a 32bit kernel >  build the test could show a double-free and coredump due to the unchecked >  invalid writes from relocations. >  >  datefixed: >  >  references: >  >  gitfixid: >  >  tarrelease:  Use   > >  >  id: >  >  cve: >  >  datereported: >  >  reportedby: Yue Liu >  >  vulnerability: OOB read bug in _dwarf_read_line_table_header >  >  product: libdwarf >  >  description: Test object shows null dereference at line 62 of >  dwarf_line_table_reader.c. Frame code and linetable code was not noticing >  data corruption. >  >  datefixed: >  >  references: regressiontests/liu/OOB_read4.elf >  >  gitfixid: >  >  tarrelease:  Use   > >  >  id: >  >  cve: >  >  datereported: >  >  reportedby: Yue Liu >  >  vulnerability: OOB read bug in dump_block >  >  product: libdwarf >  >  description: Test object shows null dereverence at line of >  dump_block() in print_sections.c Frame code was not noticing frame data >  corruption. >  >  datefixed: >  >  references: regressiontests/liu/OOB_read3.elf >  >  >  gitfixid: >  >  tarrelease:  Use   > >  >  id: >  >  cve: >  >  datereported: >  >  reportedby: Yue Liu >  >  vulnerability: NULL dereference in _dwarf_load_section >  >  product: libdwarf >  >  description: Test object shows null dereverence at line >  if(!strncmp("ZLIB",(const char *)src,4)) { in dwarf_init_finish.c The zlib >  code was not checking for a corrupted length-value. >  >  datefixed: >  >  references: >  >  gitfixid: >  >  tarrelease:  Use   > >  >  id: >  >  cve: >  >  datereported: >  >  reportedby: Yue Liu >  >  vulnerability: OOB read in dwarf_get_macro_startend_file() >  >  product: libdwarf >  >  description: Test object shows out of bound read. OOB at: line >  *src_file_name = macro_context->mc_srcfiles[trueindex]; in dwarf_macro5.c >  A string offset into .debug_str is outside the bounds of the .debug_str >  section. >  >  datefixed: >  >  references: >  >  >  gitfixid: >  >  tarrelease:  Use   > >  >  id: >  >  cve: >  >  datereported: >  >  reportedby: Yue Liu >  >  vulnerability: OOB read bug in get_attr_value() >  >  product: libdwarf >  >  description: Test object shows out of bound read. Object had data >  all-bits-on so the existing length check did not work due to wraparound. >  Added a check not susceptible to that error >  (DW_DLE_FORM_BLOCK_LENGTH_ERROR). >  >  datefixed: >  >  references: >  >  gitfixid: >  >  tarrelease:  Use   > >  >  id: >  >  cve: >  >  datereported: >  >  reportedby: Yue Liu >  >  vulnerability: Two Heap-Overflow bug >  >  product: libdwarf >  >  description: Two test objects showing a heap overflow in libdwarf when >  using dwarfdump. It seems that these were fixed by the previous git >  update. Neither gdb nor valgrind find any errors when building with >  yesterday's commit. >  >  datefixed: >  >  references: regressiontests/liu/free_invalid_address.elf >  regressiontests/liu/heapoverflow01b.elf >  >  gitfixid: >  >  tarrelease:  We cannot assign a CVE ID without more analysis from you about why these two issues are being combined into a single ID, and about whether they are independent of the issue "fixed by the previous git update." A "heap overflow" is often a consequence of other code problems, and the term "heap overflow" is often misused to refer to an invalid read operation instead of an invalid write operation.   > >  >  id: >  >  cve: >  >  datereported: >  >  reportedby: Yue Liu >  >  vulnerability: A specially crafted DWARF section results in reading a >  compilation unit header that crashes the application. >  >  product: libdwarf >  >  description: If the data read for a compilation unit header contains a too >  large length value the library will read outside of its bounds and crash >  the application. >  >  datefixed: >  >  references: regressiontests/liu/null02.elf >  >  gitfixid: >  >  tarrelease:  Use   > >  >  id: >  >  cve: >  >  datereported: >  >  reportedby: Yue Liu >  >  vulnerability: A specially crafted DWARF section results in a null >  dereference reading debugging information entries which crashes the >  application. >  >  product: libdwarf >  >  description: If no DW_AT_name is present in a debugging information entry >  using DWARF5 macros a null dereference in dwarf_macro5.c will crash the >  application. >  >  datefixed: >  >  references: regressiontests/liu/null01.elf >  >  gitfixid: >  >  tarrelease:  Use   > >  >  id: >  >  cve: >  >  datereported: >  >  reportedby: Yue Liu >  >  vulnerability: A specially crafted DWARF section results in an infinite >  loop that eventually crashes the application. >  >  product: libdwarf >  >  description: In dwarf_get_aranges_list() an invalid count will iterate, >  reading from memory addresses that increase till it all fails. >  >  datefixed: >  >  references: regressiontests/liu/infiniteloop.elf >  >  gitfixid: >  >  tarrelease:  Use   > >  >  id: >  >  cve: >  >  datereported: >  >  reportedby: Yue Liu >  >  vulnerability: A specially crafted DWARF section results in a read outside >  the bounds of in memory data so the calling application can crash. >  >  product: libdwarf >  >  description: Out of bound read bug in libdwarf git code. dwarf_dealloc() >  did not check the Dwarf_Ptr space argument before using it. This will lead >  to a out-of-bound read bug. >  > backtrace: > #0  dwarf_dealloc space=0xa0, > alloc_type=alloc_type@...ry=1) at > #1  in dealloc_srcfiles > srcfiles_count=17) at > #2  in dealloc_srcfiles > (srcfiles_count=<optimized out>, srcfiles=<optimized out>, > dbg=<optimized out>) at ----- > gef> p &r->rd_dbg > $14 = (void **) >  >  >  datefixed: >  >  references: regressiontests/liu/outofbound01.elf >  >  gitfixid: >  >  tarrelease:  Use   > >  >  id: >  >  cve: >  >  datereported: >  >  reportedby: Yue Liu >  >  vulnerability: A specially crafted DWARF section results in a duplicate >  free() in libdwarf and the calling application will crash. >  >  product: libdwarf >  >  description: In file >  > WRITE_UNALIGNED(dbg,target_section + offset, >     &outval,sizeof(outval),reloc_size); >  >  >  A crafted ELF file may lead to a large offset value, which bigger than the >  size of target_section heap chunk, then this WRITE_UNALIGNED() function >  will write the value of &outval out of the heap chunk. offset is a 64bit >  unsigned int value, so this is more than a heap overflow bug, but also a >  Out-of-Bound write bug. So WRITE_UNALIGNED() need more strictly checking >  to prevent this. >  >  datefixed: >  >  references: regressiontests/liu/heapoverflow01.elf >  >  gitfixid: >  >  tarrelease:  Use  - --  CVE Assignment Team M/S Burlington Road, Bedford, MA USA [ A PGP key is available for encrypted communications at   http://cve.mitre.org/cve/request_id.html ] -----BEGIN PGP SIGNATURE----- Version: GnuPG v1  =/Qjv -----END PGP SIGNATURE-----  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      