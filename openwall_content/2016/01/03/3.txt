  oss-security - phpecc/phpecc - Timing side-channel in ECDSA signature verification            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Sun, 3 Jan From: Paragon Initiative Enterprises Security Team <security@...agonie.com> To: oss-security@...ts.openwall.com Subject: phpecc/phpecc - Timing side-channel in ECDSA signature verification  Happy new year, OSS-Sec!  We've got something we hope you find interesting.  In the process of auditing a PHP JWT library, we took a look at one of its dependencies, phpecc. https://github.com/phpecc/phpecc  Phpecc describes itself as "Pure PHP Elliptic Curve DSA and DH", and the JWT library was using it to facilitate ECDSA (over NIST with a SHA2-family hash function, of course).  We quickly discovered that the method they were using for signature verification was not implemented in constant-time.  Our analysis: Our proposed patch:  The takeaway, for anyone who ever needs to touch PHP and is thinking of implementing their own crypto:  > gmp_cmp() is not suitable for cryptography, you want hash_equals()  On a related note, we opened to address a common problem in projects that aim to implement cryptography primitives in PHP: Function overloading.  "What is function overloading?" you might ask. It's one of the unresolved PHP design warts from a related school of thought that brought us magic_quotes in PHP 4.  If you set mbstring.func_overload = 2 in your PHP configuration, strlen() and substr() no longer operate over binary strings (the default behavior). Instead, they assume that they're being given Unicode text, which can fit more bytes into each character.  To test this, run:       Without mbstring.func_overload, you get int(4). With it set to 2, and your locale set to UTF-8, you get int(1) instead.  "What does this have to do with cryptography?"  A typical hash_equals() polyfill, e.g. for verifying the HMAC in a cryptography protocol, looks like this:      function hash_equals($a, $b)     {         $d = 0;         $lenA = strlen($a);         $lenB = strlen($b);         if ($lenA !== $lenB) {             return false;         }         for ($i = 0; $i < $lenA; ++$i) {             $d |= ord($a[$i]) ^ ord($b[$i]);         }         return $d === 0;     }  But with mbstring.func_overload, depending on the structure of the expected HMAC output, strlen($a) could become 8.  It's much easier to brute force possible values (especially if you know the resulting hash must conform to a a sequence of eight 4-byte UTF-8 characters) than it is to brute force possible values.  The fix is to be explicit about operating over raw binary:  * strlen($x) -> mb_strlen($x, '8bit') * substr($x, $y, $z) -> mb_substr($x, $y, $z, '8bit')  In sum:  * Don't use gmp_cmp() to compare hashes or signatures * If you don't explicitly handle function overloading (like our patch does), you're almost certainly weakening your protocol somewhere * In fact, you should strongly consider NEVER writing cryptography primitives in PHP  This last bit of advice is brought to you by one of the few teams experienced enough to develop PHP cryptography features. We don't even dare write primitives in PHP. It's a mistake that many make (we're looking at you, php-gpg).  Further reading:  * https://secure.php.net/manual/en/mbstring.overload.php - Function overloading * https://github.com/sarciszewski/php-future/blob/master/src/BaseFuture.php - Mitigation for function overloading * - All about timing attacks * - The audit for lcobucci/jwt * https://github.com/jasonhinkle/php-gpg - An attempt to port GnuPG to PHP  Security Team Paragon Initiative Enterprises <https://paragonie.com>  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      