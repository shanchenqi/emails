  oss-security - [PATCH 3/4] move cred_guard_mutex from task_struct to signal_struct            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [<thread-prev] [thread-next>] [day] [month] [year] [list]  Date: Thu, 16 Sep (JST) From: KOSAKI Motohiro <kosaki.motohiro@...fujitsu.com> To: Linus Torvalds <torvalds@...ux-foundation.org> Cc: kosaki.motohiro@...fujitsu.com, Andrew Morton <akpm@...ux-foundation.org>,         linux-kernel@...r.kernel.org, oss-security@...ts.openwall.com,         Solar Designer <solar@...nwall.com>,         Kees Cook <kees.cook@...onical.com>, Al Viro <viro@...iv.linux.org.uk>,         Oleg Nesterov <oleg@...hat.com>, Neil Horman <nhorman@...driver.com>,         linux-fsdevel@...r.kernel.org, pageexec@...email.hu,         Brad Spengler <spender@...ecurity.net>, Eugene Teo <eugene@...hat.com>,         KAMEZAWA Hiroyuki <kamezawa.hiroyu@...fujitsu.com>,         linux-mm <linux-mm@...ck.org>, David Rientjes <rientjes@...gle.com> Subject: [PATCH 3/4] move cred_guard_mutex from task_struct to signal_struct   Changelog   o since v1     - function comment also change current->cred_guard_mutex to       current->signal->cred_guard_mutex.  Oleg Nesterov pointed out we have to prevent multiple-threads-inside-exec itself and we can reuse ->cred_guard_mutex for it. Yes, concurrent execve() has no worth.  Let's move ->cred_guard_mutex from task_struct to signal_struct. It naturally prevent multiple-threads-inside-exec.  Reviewed-by: Oleg Nesterov <oleg@...hat.com> Cc: Roland McGrath <roland@...hat.com> Signed-off-by: KOSAKI Motohiro <kosaki.motohiro@...fujitsu.com> ---  fs/exec.c                 |   10 +++++-----  fs/proc/base.c            |    8 ++++----  include/linux/init_task.h |    4 ++--  include/linux/sched.h     |    7 ++++---  include/linux/tracehook.h |    2 +-  kernel/cred.c             |    4 +---  kernel/fork.c             |    2 ++  kernel/ptrace.c           |    4 ++--  8 files changed, 21 insertions(+), 20 deletions(-)  diff --git a/fs/exec.c b/fs/exec.c index --- a/fs/exec.c +++ b/fs/exec.c @@ @@ EXPORT_SYMBOL(setup_new_exec);   */  int prepare_bprm_creds(struct linux_binprm *bprm)  { -	if (mutex_lock_interruptible(&current->cred_guard_mutex)) +	if (mutex_lock_interruptible(&current->signal->cred_guard_mutex))  		return -ERESTARTNOINTR;    	bprm->cred = prepare_exec_creds();  	if (likely(bprm->cred))  		return 0;   -	mutex_unlock(&current->cred_guard_mutex); +	mutex_unlock(&current->signal->cred_guard_mutex);  	return -ENOMEM;  }   @@ @@ void free_bprm(struct linux_binprm *bprm)  {  	free_arg_pages(bprm);  	if (bprm->cred) { -		mutex_unlock(&current->cred_guard_mutex); +		mutex_unlock(&current->signal->cred_guard_mutex);  		abort_creds(bprm->cred);  	}  	kfree(bprm); @@ @@ void install_exec_creds(struct linux_binprm *bprm)  	 * credentials; any time after this it may be unlocked.  	 */  	security_bprm_committed_creds(bprm); -	mutex_unlock(&current->cred_guard_mutex); +	mutex_unlock(&current->signal->cred_guard_mutex);  }  EXPORT_SYMBOL(install_exec_creds);    /*   * determine how safe it is to execute the proposed program - * - the caller must hold current->cred_guard_mutex to protect against + * - the caller must hold ->cred_guard_mutex to protect against   *   PTRACE_ATTACH   */  int check_unsafe_exec(struct linux_binprm *bprm) diff --git a/fs/proc/base.c b/fs/proc/base.c index --- a/fs/proc/base.c +++ b/fs/proc/base.c @@ @@ struct mm_struct *mm_for_maps(struct task_struct *task)  {  	struct mm_struct *mm;   -	if (mutex_lock_killable(&task->cred_guard_mutex)) +	if (mutex_lock_killable(&task->signal->cred_guard_mutex))  		return NULL;    	mm = get_task_mm(task); @@ @@ struct mm_struct *mm_for_maps(struct task_struct *task)  		mmput(mm);  		mm = NULL;  	} -	mutex_unlock(&task->cred_guard_mutex); +	mutex_unlock(&task->signal->cred_guard_mutex);    	return mm;  } @@ @@ static ssize_t proc_pid_attr_write(struct file * file, const char __user * buf,  		goto out_free;    	/* Guard against adverse ptrace interaction */ -	length = mutex_lock_interruptible(&task->cred_guard_mutex); +	length = mutex_lock_interruptible(&task->signal->cred_guard_mutex);  	if (length < 0)  		goto out_free;    	length = security_setprocattr(task,  				      (char*)file->f_path.dentry->d_name.name,  				      (void*)page, count); -	mutex_unlock(&task->cred_guard_mutex); +	mutex_unlock(&task->signal->cred_guard_mutex);  out_free:  	free_page((unsigned long) page);  out: diff --git a/include/linux/init_task.h b/include/linux/init_task.h index --- a/include/linux/init_task.h +++ b/include/linux/init_task.h @@ @@ extern struct fs_struct init_fs;  		.running = 0,						\  		.lock = __SPIN_LOCK_UNLOCKED(sig.cputimer.lock),	\  	},								\ +	.cred_guard_mutex =						\ +		 __MUTEX_INITIALIZER(sig.cred_guard_mutex),		\  }    extern struct nsproxy init_nsproxy; @@ @@ extern struct cred init_cred;  	.group_leader	= &tsk,						\  	.real_cred	= &init_cred,					\  	.cred		= &init_cred,					\ -	.cred_guard_mutex =						\ -		 __MUTEX_INITIALIZER(tsk.cred_guard_mutex),		\  	.comm		= "swapper",					\  	.thread		= INIT_THREAD,					\  	.fs		= &init_fs,					\ diff --git a/include/linux/sched.h b/include/linux/sched.h index --- a/include/linux/sched.h +++ b/include/linux/sched.h @@ @@ struct signal_struct {    	int oom_adj;		/* OOM kill score adjustment (bit shift) */  	long oom_score_adj;	/* OOM kill score adjustment */ + +	struct mutex cred_guard_mutex;	/* guard against foreign influences on +					 * credential calculations +					 * (notably. ptrace) */  };    /* Context switch must be unlocked if interrupts are to be enabled */ @@ @@ struct task_struct {  					 * credentials (COW) */  	const struct cred *cred;	/* effective (overridable) subjective task  					 * credentials (COW) */ -	struct mutex cred_guard_mutex;	/* guard against foreign influences on -					 * credential calculations -					 * (notably. ptrace) */  	struct cred *replacement_session_keyring; /* for KEYCTL_SESSION_TO_PARENT */    	char comm[TASK_COMM_LEN]; /* executable name excluding path diff --git a/include/linux/tracehook.h b/include/linux/tracehook.h index --- a/include/linux/tracehook.h +++ b/include/linux/tracehook.h @@ @@ static inline void tracehook_report_syscall_exit(struct pt_regs *regs, int step)   *   * Return %LSM_UNSAFE_* bits applied to an exec because of tracing.   * - * @task->cred_guard_mutex is held by the caller through the do_execve(). + * @task->signal->cred_guard_mutex is held by the caller through the do_execve().   */  static inline int tracehook_unsafe_exec(struct task_struct *task)  { diff --git a/kernel/cred.c b/kernel/cred.c index --- a/kernel/cred.c +++ b/kernel/cred.c @@ @@ EXPORT_SYMBOL(prepare_creds);    /*   * Prepare credentials for current to perform an execve() - * - The caller must hold current->cred_guard_mutex + * - The caller must hold ->cred_guard_mutex   */  struct cred *prepare_exec_creds(void)  { @@ @@ int copy_creds(struct task_struct *p, unsigned long clone_flags)  	struct cred *new;  	int ret;   -	mutex_init(&p->cred_guard_mutex); -  	if (  #ifdef CONFIG_KEYS  		!p->cred->thread_keyring && diff --git a/kernel/fork.c b/kernel/fork.c index --- a/kernel/fork.c +++ b/kernel/fork.c @@ @@ static int copy_signal(unsigned long clone_flags, struct task_struct *tsk)  	sig->oom_adj = current->signal->oom_adj;  	sig->oom_score_adj = current->signal->oom_score_adj;   +	mutex_init(&sig->cred_guard_mutex); +  	return 0;  }   diff --git a/kernel/ptrace.c b/kernel/ptrace.c index --- a/kernel/ptrace.c +++ b/kernel/ptrace.c @@ @@ int ptrace_attach(struct task_struct *task)  	 * under ptrace.  	 */  	retval = -ERESTARTNOINTR; -	if (mutex_lock_interruptible(&task->cred_guard_mutex)) +	if (mutex_lock_interruptible(&task->signal->cred_guard_mutex))  		goto out;    	task_lock(task); @@ @@ int ptrace_attach(struct task_struct *task)  unlock_tasklist:  	write_unlock_irq(&tasklist_lock);  unlock_creds: -	mutex_unlock(&task->cred_guard_mutex); +	mutex_unlock(&task->signal->cred_guard_mutex);  out:  	return retval;  } --      Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      