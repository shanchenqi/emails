  oss-security - [PATCH 1/2] oom: don't ignore rss in nascent mm            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [<thread-prev] [thread-next>] [day] [month] [year] [list]  Date: Thu,  9 Sep (JST) From: KOSAKI Motohiro <kosaki.motohiro@...fujitsu.com> To: KOSAKI Motohiro <kosaki.motohiro@...fujitsu.com> Cc: kosaki.motohiro@...fujitsu.com, Roland McGrath <roland@...hat.com>,         Linus Torvalds <torvalds@...ux-foundation.org>,         Andrew Morton <akpm@...ux-foundation.org>,         linux-kernel@...r.kernel.org, oss-security@...ts.openwall.com,         Solar Designer <solar@...nwall.com>,         Kees Cook <kees.cook@...onical.com>, Al Viro <viro@...iv.linux.org.uk>,         Oleg Nesterov <oleg@...hat.com>, Neil Horman <nhorman@...driver.com>,         linux-fsdevel@...r.kernel.org, pageexec@...email.hu,         "Brad Spengler <spender@...ecurity.net>, Eugene Teo" <eugene@...hat.com>,         KAMEZAWA Hiroyuki <kamezawa.hiroyu@...fujitsu.com> Subject: [PATCH 1/2] oom: don't ignore rss in nascent mm  This patch was made on top "oom: remove totalpage normalization from oom_badness()" patch.  =============================== Execve() makes new mm struct and setup stack and push argv vector, Unfortunately this nascent mm is not pointed any tasks, then OOM-killer can't detect this memory usage. therefore OOM-killer may kill incorrect task.  Thus, this patch added task->in_exec_mm member and track nascent mm usage.  Cc: pageexec@...email.hu Cc: Roland McGrath <roland@...hat.com> Cc: Solar Designer <solar@...nwall.com> Cc: Brad Spengler <spender@...ecurity.net> Cc: Eugene Teo <eteo@...hat.com> Signed-off-by: KOSAKI Motohiro <kosaki.motohiro@...fujitsu.com> ---  fs/compat.c             |    4 +++-  fs/exec.c               |   14 +++++++++++++-  include/linux/binfmts.h |    1 +  include/linux/sched.h   |    1 +  mm/oom_kill.c           |   37 +++++++++++++++++++++++++++++--------  5 files changed, 47 insertions(+), 10 deletions(-)  diff --git a/fs/compat.c b/fs/compat.c index --- a/fs/compat.c +++ b/fs/compat.c @@ @@ int compat_do_execve(char * filename,  	return retval;    out: -	if (bprm->mm) +	if (bprm->mm) { +		set_exec_mm(NULL);  		mmput(bprm->mm); +	}    out_file:  	if (bprm->file) { diff --git a/fs/exec.c b/fs/exec.c index --- a/fs/exec.c +++ b/fs/exec.c @@ @@ int bprm_mm_init(struct linux_binprm *bprm)  	if (err)  		goto err;   +	set_exec_mm(bprm->mm); +  	return 0;    err: @@ @@ int flush_old_exec(struct linux_binprm * bprm)  		goto out;    	bprm->mm = NULL;		/* We're using it now */ +	set_exec_mm(NULL);    	current->flags &= ~PF_RANDOMIZE;  	flush_thread(); @@ @@ int search_binary_handler(struct linux_binprm *bprm,struct pt_regs *regs)    EXPORT_SYMBOL(search_binary_handler);   +void set_exec_mm(struct mm_struct *mm) +{ +	task_lock(current); +	current->in_exec_mm = mm; +	task_unlock(current); +} +  /*   * sys_execve() executes a new program.   */ @@ @@ int do_execve(const char * filename,  	return retval;    out: -	if (bprm->mm) +	if (bprm->mm) { +		set_exec_mm(NULL);  		mmput (bprm->mm); +	}    out_file:  	if (bprm->file) { diff --git a/include/linux/binfmts.h b/include/linux/binfmts.h index --- a/include/linux/binfmts.h +++ b/include/linux/binfmts.h @@ @@ extern void install_exec_creds(struct linux_binprm *bprm);  extern void do_coredump(long signr, int exit_code, struct pt_regs *regs);  extern void set_binfmt(struct linux_binfmt *new);  extern void free_bprm(struct linux_binprm *); +extern void set_exec_mm(struct mm_struct *mm);    #endif /* __KERNEL__ */  #endif /* _LINUX_BINFMTS_H */ diff --git a/include/linux/sched.h b/include/linux/sched.h index --- a/include/linux/sched.h +++ b/include/linux/sched.h @@ @@ struct task_struct {  	int pdeath_signal;  /*  The signal sent when the parent dies  */  	/* ??? */  	unsigned int personality; +	struct mm_struct *in_exec_mm;  	unsigned did_exec:1;  	unsigned in_execve:1;	/* Tell the LSMs that the process is doing an  				 * execve */ diff --git a/mm/oom_kill.c b/mm/oom_kill.c index --- a/mm/oom_kill.c +++ b/mm/oom_kill.c @@ @@ struct task_struct *find_lock_task_mm(struct task_struct *p)  	return NULL;  }   +/* + * The baseline for the badness score is the proportion of RAM that each + * task's rss and swap space use. + */ +static unsigned long oom_rss_swap_usage(struct task_struct *p) +{ +	struct task_struct *t = p; +	int mm_accounted = 0; +	unsigned long points = 0; + +	do { +		task_lock(t); +		if (!mm_accounted && t->mm) { +			points += get_mm_rss(t->mm); +			points += get_mm_counter(t->mm, MM_SWAPENTS); +			mm_accounted = 1; +		} +		if (t->in_exec_mm) { +			points += get_mm_rss(t->in_exec_mm); +			points += get_mm_counter(t->in_exec_mm, MM_SWAPENTS); +		} +		task_unlock(t); +	} while_each_thread(p, t); + +	return points; +} +  /* return true if the task is not adequate as candidate victim task. */  static bool oom_unkillable_task(struct task_struct *p, struct mem_cgroup *mem,  			   const nodemask_t *nodemask) @@ @@ unsigned long oom_badness(struct task_struct *p, struct mem_cgroup *mem,  	if (p->flags & PF_OOM_ORIGIN)  		return ULONG_MAX;   -	p = find_lock_task_mm(p); -	if (!p) +	points = oom_rss_swap_usage(p); +	if (!points)  		return 0;   -	/* -	 * The baseline for the badness score is the proportion of RAM that each -	 * task's rss and swap space use. -	 */ -	points = (get_mm_rss(p->mm) + get_mm_counter(p->mm, MM_SWAPENTS)); -	task_unlock(p);    	/*  	 * Root processes get 3% bonus, just like the __vm_enough_memory() --      Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      