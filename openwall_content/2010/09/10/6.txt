  oss-security - [PATCH] move cred_guard_mutex from task_struct to signal_struct            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [thread-next>] [day] [month] [year] [list]  Date: Fri, 10 Sep (JST) From: KOSAKI Motohiro <kosaki.motohiro@...fujitsu.com> To: Oleg Nesterov <oleg@...hat.com> Cc: kosaki.motohiro@...fujitsu.com, Roland McGrath <roland@...hat.com>,         Linus Torvalds <torvalds@...ux-foundation.org>,         Andrew Morton <akpm@...ux-foundation.org>,         linux-kernel@...r.kernel.org, oss-security@...ts.openwall.com,         Solar Designer <solar@...nwall.com>,         Kees Cook <kees.cook@...onical.com>, Al Viro <viro@...iv.linux.org.uk>,         Neil Horman <nhorman@...driver.com>, linux-fsdevel@...r.kernel.org,         pageexec@...email.hu,         "Brad Spengler <spender@...ecurity.net>, Eugene Teo" <eugene@...hat.com>,         KAMEZAWA Hiroyuki <kamezawa.hiroyu@...fujitsu.com> Subject: [PATCH] move cred_guard_mutex from task_struct to signal_struct  > On KOSAKI Motohiro wrote: > > > > --- a/include/linux/sched.h > > +++ b/include/linux/sched.h > > @@ @@ struct task_struct { > >  	int pdeath_signal;  /*  The signal sent when the parent dies  */ > >  	/* ??? */ > >  	unsigned int personality; > > +	struct mm_struct *in_exec_mm; >  > Oh, yes, this has to be per-thread (unlike ->mm, btw). >  > I wonder if it makes sense to move ->cred_guard_mutex from task_struct > to signal_struct and thus make multiple-threads-inside-exec impossible. > Only one thread can win anyway.  Interesting idea, really. I've thought  1) moving cread_guard_mutex itself    - no increase execve overhead 	-> very good    - it also prevent parallel ptrace 	-> probably no problem. nobody want parallel debugging 2) move in_exec_mm to signal_struct too    -> very hard. oom-killer can use very few lock because it's called       from various place. now both ->mm and ->in_exec_mm are protected       task_lock() and it help to avoid messy.   So, I've done only (1). I think this restriction effectivly prevent  some theorical execve() resouce smashing attack.   ====================================================================== Subject: [PATCH] move cred_guard_mutex from task_struct to signal_struct  Oleg Nesterov pointed out we have to prevent multiple-threads-inside-exec itself and we can reuse ->cred_guard_mutex for it. Yes, concurrent execve() has no worth.  Let's move ->cred_guard_mutex from task_struct to signal_struct. It naturally prevent multiple-threads-inside-exec.  Cc: Oleg Nesterov <oleg@...hat.com> Cc: Roland McGrath <roland@...hat.com> Signed-off-by: KOSAKI Motohiro <kosaki.motohiro@...fujitsu.com> ---  fs/exec.c                 |    8 ++++----  fs/proc/base.c            |    8 ++++----  include/linux/init_task.h |    4 ++--  include/linux/sched.h     |    7 ++++---  kernel/cred.c             |    2 --  kernel/fork.c             |    2 ++  kernel/ptrace.c           |    4 ++--  7 files changed, 18 insertions(+), 17 deletions(-)  diff --git a/fs/exec.c b/fs/exec.c index --- a/fs/exec.c +++ b/fs/exec.c @@ @@ EXPORT_SYMBOL(setup_new_exec);   */  int prepare_bprm_creds(struct linux_binprm *bprm)  { -	if (mutex_lock_interruptible(&current->cred_guard_mutex)) +	if (mutex_lock_interruptible(&current->signal->cred_guard_mutex))  		return -ERESTARTNOINTR;    	bprm->cred = prepare_exec_creds();  	if (likely(bprm->cred))  		return 0;   -	mutex_unlock(&current->cred_guard_mutex); +	mutex_unlock(&current->signal->cred_guard_mutex);  	return -ENOMEM;  }   @@ @@ void free_bprm(struct linux_binprm *bprm)  {  	free_arg_pages(bprm);  	if (bprm->cred) { -		mutex_unlock(&current->cred_guard_mutex); +		mutex_unlock(&current->signal->cred_guard_mutex);  		abort_creds(bprm->cred);  	}  	kfree(bprm); @@ @@ void install_exec_creds(struct linux_binprm *bprm)  	 * credentials; any time after this it may be unlocked.  	 */  	security_bprm_committed_creds(bprm); -	mutex_unlock(&current->cred_guard_mutex); +	mutex_unlock(&current->signal->cred_guard_mutex);  }  EXPORT_SYMBOL(install_exec_creds);   diff --git a/fs/proc/base.c b/fs/proc/base.c index --- a/fs/proc/base.c +++ b/fs/proc/base.c @@ @@ struct mm_struct *mm_for_maps(struct task_struct *task)  {  	struct mm_struct *mm;   -	if (mutex_lock_killable(&task->cred_guard_mutex)) +	if (mutex_lock_killable(&task->signal->cred_guard_mutex))  		return NULL;    	mm = get_task_mm(task); @@ @@ struct mm_struct *mm_for_maps(struct task_struct *task)  		mmput(mm);  		mm = NULL;  	} -	mutex_unlock(&task->cred_guard_mutex); +	mutex_unlock(&task->signal->cred_guard_mutex);    	return mm;  } @@ @@ static ssize_t proc_pid_attr_write(struct file * file, const char __user * buf,  		goto out_free;    	/* Guard against adverse ptrace interaction */ -	length = mutex_lock_interruptible(&task->cred_guard_mutex); +	length = mutex_lock_interruptible(&task->signal->cred_guard_mutex);  	if (length < 0)  		goto out_free;    	length = security_setprocattr(task,  				      (char*)file->f_path.dentry->d_name.name,  				      (void*)page, count); -	mutex_unlock(&task->cred_guard_mutex); +	mutex_unlock(&task->signal->cred_guard_mutex);  out_free:  	free_page((unsigned long) page);  out: diff --git a/include/linux/init_task.h b/include/linux/init_task.h index --- a/include/linux/init_task.h +++ b/include/linux/init_task.h @@ @@ extern struct fs_struct init_fs;  		.running = 0,						\  		.lock = __SPIN_LOCK_UNLOCKED(sig.cputimer.lock),	\  	},								\ +	.cred_guard_mutex =						\ +		 __MUTEX_INITIALIZER(sig.cred_guard_mutex),		\  }    extern struct nsproxy init_nsproxy; @@ @@ extern struct cred init_cred;  	.group_leader	= &tsk,						\  	.real_cred	= &init_cred,					\  	.cred		= &init_cred,					\ -	.cred_guard_mutex =						\ -		 __MUTEX_INITIALIZER(tsk.cred_guard_mutex),		\  	.comm		= "swapper",					\  	.thread		= INIT_THREAD,					\  	.fs		= &init_fs,					\ diff --git a/include/linux/sched.h b/include/linux/sched.h index --- a/include/linux/sched.h +++ b/include/linux/sched.h @@ @@ struct signal_struct {    	int oom_adj;		/* OOM kill score adjustment (bit shift) */  	long oom_score_adj;	/* OOM kill score adjustment */ + +	struct mutex cred_guard_mutex;	/* guard against foreign influences on +					 * credential calculations +					 * (notably. ptrace) */  };    /* Context switch must be unlocked if interrupts are to be enabled */ @@ @@ struct task_struct {  					 * credentials (COW) */  	const struct cred *cred;	/* effective (overridable) subjective task  					 * credentials (COW) */ -	struct mutex cred_guard_mutex;	/* guard against foreign influences on -					 * credential calculations -					 * (notably. ptrace) */  	struct cred *replacement_session_keyring; /* for KEYCTL_SESSION_TO_PARENT */    	char comm[TASK_COMM_LEN]; /* executable name excluding path diff --git a/kernel/cred.c b/kernel/cred.c index --- a/kernel/cred.c +++ b/kernel/cred.c @@ @@ int copy_creds(struct task_struct *p, unsigned long clone_flags)  	struct cred *new;  	int ret;   -	mutex_init(&p->cred_guard_mutex); -  	if (  #ifdef CONFIG_KEYS  		!p->cred->thread_keyring && diff --git a/kernel/fork.c b/kernel/fork.c index --- a/kernel/fork.c +++ b/kernel/fork.c @@ @@ static int copy_signal(unsigned long clone_flags, struct task_struct *tsk)  	sig->oom_adj = current->signal->oom_adj;  	sig->oom_score_adj = current->signal->oom_score_adj;   +	mutex_init(&sig->cred_guard_mutex); +  	return 0;  }   diff --git a/kernel/ptrace.c b/kernel/ptrace.c index --- a/kernel/ptrace.c +++ b/kernel/ptrace.c @@ @@ int ptrace_attach(struct task_struct *task)  	 * under ptrace.  	 */  	retval = -ERESTARTNOINTR; -	if (mutex_lock_interruptible(&task->cred_guard_mutex)) +	if (mutex_lock_interruptible(&task->signal->cred_guard_mutex))  		goto out;    	task_lock(task); @@ @@ int ptrace_attach(struct task_struct *task)  unlock_tasklist:  	write_unlock_irq(&tasklist_lock);  unlock_creds: -	mutex_unlock(&task->cred_guard_mutex); +	mutex_unlock(&task->signal->cred_guard_mutex);  out:  	return retval;  } --      Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      