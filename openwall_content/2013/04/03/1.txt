  oss-security - : haproxy may crash on TCP content inspection rules            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [day] [month] [year] [list]  Date: Wed, 3 Apr From: Willy Tarreau <w@....eu> To: oss-security@...ts.openwall.com Subject: : haproxy may crash on TCP content inspection rules   Hi,  Yves Lafon from the W3C reported some random crashes of haproxy with an advanced configuration, that we finally considered was a security issue as it could remotely be triggered.   --- summary ---  Configurations at risk are those which combine use of HTTP keywords in TCP content inspection rules, client-side keep-alive, header rewriting rules and which receive pipelined requests. These configurations may be remotely crashed when run with haproxy 1.4 up to and including or development versions up to and including Versions and are safe.   --- quick workaround ---  Disable TCP content inspection, or disable HTTP keep-alive by inserting "option forceclose" in the affected frontends.   --- details ---  During normal HTTP request processing, request buffers are realigned if there are less than global.maxrewrite bytes available after them, in order to leave enough room for rewriting headers after the request. This is done in http_wait_for_request().      However, if some HTTP inspection happens during a "tcp-request content" rule, this realignment is not performed. In theory this is not a problem because empty buffers are always aligned and TCP inspection happens at the beginning of a connection. But with HTTP keep-alive, it also happens at the beginning of each subsequent request. So if a second request was pipelined by the client before the first one had a chance to be forwarded, the second request will not be realigned. Then, http_wait_for_request() will not perform such a realignment either because the request was already parsed and marked as such. The consequence of this, is that the rewrite of a sufficient number of such pipelined, unaligned requests may leave less room past the request been processed than the configured reserve, which can lead to a buffer overflow if request processing appends some data past the end of the buffer.      A number of conditions are required for the bug to be triggered :    - HTTP keep-alive must be enabled ;    - HTTP inspection in TCP rules must be used ;    - some request appending rules are needed (reqadd, x-forwarded-for)    - since empty buffers are always realigned, the client must pipeline      enough requests so that the buffer always contains something till      the point where there is no more room for rewriting.      While such a configuration is quite unlikely to be met (which is confirmed by the bug's lifetime), a few people do use these features together for very specific usages. And more importantly, writing such a configuration and the request to attack it is trivial.      A quick workaround consists in forcing keep-alive off by adding "option httpclose" or "option forceclose" in the frontend. Alternatively, disabling HTTP-based TCP inspection rules enough if the application supports it.      At first glance, this bug does not look like it could lead to remote code execution, as the overflowing part is controlled by the configuration and not by the user. But some deeper analysis should be performed to confirm this. And anyway, corrupting the process' memory and crashing it is quite trivial.      Special thanks go to Yves Lafon from the W3C who reported this bug and deployed significant efforts to collect the relevant data needed to understand it in less than one week, and to Ryan O'Hara from Red Hat for providing me with a CVE number.      was assigned to this issue.  --- links --- 1.4-stable patch for version <= : source code:   1.5-dev patch for versions <= : source code:  Please check with your distro vendor for packaged updates. --  Thanks, Willy Tarreau   Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      