  oss-security - CVE Id Request: fetchmail <= DoS when logging long headers  in -v -v mode            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [thread-next>] [day] [month] [year] [list]  Date: Fri, 13 Jun From: Matthias Andree <matthias.andree@....de> To: oss-security@...ts.openwall.com Subject: CVE Id Request: fetchmail <= DoS when logging long headers  in -v -v mode  Hi,  could I get a CVE Id for the issue given below?  Also, when someone sees a way to inject code through this vulnerability, please let me know.   Given the report is sort-of-public in Novell's Bugzilla, a similar fix is already public in the developer.BerliOS.de bugtracker, I don't see any point in keeping this confidential, so I'm including the draft security announcement below for my convenience.   Summary: fetchmail crashes (SIGSEGV while reading) in -v -v mode when trying to format log messages exceeding bytes.  Reference:  Draft announcement: --------------------------------------------------------------------- Crash on large log messages in verbose mode  Topics:         Crash in large log messages in verbose mode.  Author:         Matthias Andree Version:        1.0 Announced: Type:           Dereferencing garbage pointer trigged by outside circumstances Impact:         denial of service possible Danger:         low CVSS V2 vector: (AV:N/AC:M/Au:N/C:N/I:N/A:C/E:P/RL:O/RC:C)  Credits:        Petr Uzel (fix), Petr Cerny (analysis), Gunter Nau (bug report) CVE Name:       XXX URL:            Project URL:    http://www.fetchmail.info/  Affects:        fetchmail release < exclusively  Not affected:   fetchmail release and newer                 systems without varargs (stdargs.h) support.  Corrected:      fetchmail SVN (rev XXX)   0. Release history ==================  1.0  first draft for MITRE/CVE (visible in SVN)   1. Background =============  fetchmail is a software package to retrieve mail from remote POP2, POP3, IMAP, ETRN or ODMR servers and forward it to local SMTP, LMTP servers or message delivery agents.  fetchmail ships with a graphical, Python/Tkinter based configuration utility named "fetchmailconf" to help the user create configuration (run control) files for fetchmail.   2. Problem description and Impact =================================  Gunter Nau reported fetchmail crashing on some messages; further debugging by Petr Uzel and Petr Cerny at Novell/SUSE Czech Republic dug up that this happened when fetchmail was trying to print, in -v -v verbose level, headers exceeding bytes. In this situation, fetchmail would resize the buffer and fill in further parts of the message, but forget to reinitialize its va_list typed source pointer, thus reading data from a garbage address found on the stack at addresses above the function arguments the caller passed in; usually that would be the caller's stack frame.  It is unknown whether code can be injected remotely, but given that the segmentation fault is caused by read accesses, the relevant data is not under the remote attacker's control and no buffer overrun situation is present that would allow altering program /flow/, it is deemed rather unlikely that code can be injected.  Note that the required -vv configuration at hand is both non-default and also not common in automated (cron job) setups, but usually used in manual debugging, so not many systems would be affected by the problem. Nonetheless, in vulnerable configurations, it is remotely exploitable to effect a denial of service attack.    3. Solution ===========  There are two alternatives, either of them by itself is sufficient:  a. Apply the patch found in section B of this announcement to    fetchmail recompile and reinstall it.  b. Install fetchmail or newer when it becomes available.  The    fetchmail source code is available from      4. Workaround =============  Run fetchmail at low verbosity, avoid using two or three -v arguments; internal messages are short and do not contain external message sources so they do not cause buffer resizing. It is recommended to replace the vulnerable code by a fixed version (see previous section 3. Solution) as soon as reasonably possible.   A. Copyright, License and Warranty ==================================  (C) Copyright by Matthias Andree, <matthias.andree@....de>. Some rights reserved.  This work is licensed under the Creative Commons Attribution-NonCommercial-NoDerivs German License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-nd/2.0/de/ or send a letter to Creative Commons; Nathan Abbott Way; Stanford, California USA.  THIS WORK IS PROVIDED FREE OF CHARGE AND WITHOUT ANY WARRANTIES. Use the information herein at your own risk.    B. Patch to remedy the problem ==============================  diff --git a/report.c b/report.c index --- a/report.c +++ b/report.c @@ @@ report_build (FILE *errfp, message, va_alist)      rep_ensuresize();   #if defined(VA_START) -    VA_START (args, message);      for ( ; ; )      { +       /* +        * args has to be initialized before every call of vsnprintf(), +        * because vsnprintf() invokes va_arg macro and thus args is +        * undefined after the call. +        */ +       VA_START(args, message);         n = vsnprintf (partial_message + partial_message_size_used, partial_message_size - partial_message_size_used,                        message, args); +       va_end (args);          if (n >= 0             && (unsigned)n < partial_message_size - partial_message_size_used) @@ @@ report_build (FILE *errfp, message, va_alist)         partial_message_size +=         partial_message = REALLOC (partial_message, partial_message_size);      } -    va_end (args);  #else      for ( ; ; )      {  END OF ------------------------------------------------------------------------------------------  --  Matthias Andree   Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      