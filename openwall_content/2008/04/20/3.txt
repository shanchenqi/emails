  oss-security - Re: gcc 4.2 optimizations and integer overflow checks            Products  Openwall GNU/*/Linux   server OS Linux Kernel Runtime Guard John the Ripper   password cracker  Free & Open Source for any platform in the cloud Pro for Linux Pro for macOS  Wordlists   for password cracking passwdqc   policy enforcement  Free & Open Source for Unix Pro for Windows (Active Directory)  yescrypt   KDF & password hashing yespower   Proof-of-Work (PoW) crypt_blowfish   password hashing phpass   ditto in PHP tcb   better password shadowing Pluggable Authentication Modules scanlogd   port scan detector popa3d   tiny POP3 daemon blists   web interface to mailing lists msulogin   single user mode login php_mt_seed   mt_rand() cracker  Services Publications  Articles Presentations  Resources  Mailing lists Community wiki Source code repositories (GitHub) Source code repositories (CVSweb) File archive & mirrors How to verify digital signatures OVE IDs  What's new         Follow @Openwall on Twitter for new release announcements and other news   [<prev] [next>] [<thread-prev] [day] [month] [year] [list]  Date: Sun, 20 Apr (CEST) From: Richard Guenther <rguenther@...e.de> To: oss-security@...ts.openwall.com Subject: Re: gcc 4.2 optimizations and integer overflow checks  On Mon, 21 Apr Solar Designer wrote:  > I'm sorry for failing to find time to comment on this earlier. >  > On Fri, Apr 18, at Marcus Meissner wrote: > > On Thu, Apr 10, at Steven M. Christey wrote: > > > My immediate suspicion is that they're not the same, based solely on > > > affected versions - has a specific affected version range > > > because it changed behaviors in  Maybe that change came out of > > > followup analysis stemming from > > >  > > > But, I'm not completely sure.  Solar? > >  > > They are mostly unrelated, one is about signed integers, while the > > new one is "pointer + offset" related. >  > Yes, I am aware of these two gcc non-bugs - one is that the behavior on > signed integer overflow is undefined, the other is that pointer > arithmetic is only defined within the object (and one element beyond its > end).  So this would be two CVEs, if CVEs are to be assigned for things > like that at all (are they for common application bugs? or for the gcc > non-bugs?) >  > However, the current descriptions and references for and > are very confusing.  Neither appears to be for signed > integer overflows being undefined.  By the way, this issue was discussed > on mailing lists in so I presume that gcc started doing that kind > of optimizations at about that time.  In fact, I've been fixing some of > my own older code to use unsigned arithmetic or to pre-check (rather > than post-check) for potential integer overflows at about that time. >  > Both and refer to gcc bug which deals > with the pointer arithmetic issue.  It appears that gcc developers > decided to not have gcc take full advantage of pointer arithmetic > outside of the object being undefined, thus fixing the bug on > But I could be wrong here - maybe the fix is for an actual gcc bug only. > The most straightforward and reliable way to find this out is to ask one > of the gcc developers who worked on this bug (I'd ask Richard Guenther).  The referenced bug was about not correctly interpreting an offset to a pointer as a signed value, which basically means that GCC before that bug was fixed optimized p + -1 > p to true, independent of whether the offsetting wraps or does not wrap.  The bug was fixed not by interpreting the offset as signed but to restrict optimizing of a certain class of pointer comparisons to == and != comparisons which are not affected by the signedness problem.  The optimization was properly re-introduced with reasoning as in (unfortunately that IRC session mentioned is not available)  Later this folding code was superseeded with what we have now (not re-introducing this bug as you can see from the still working testcases that got added at that time), which correctly interprets offsets as signed.  The old code fixed code was finally removed with   Richard Guenther  <rguenther@...e.de>          * fold-const.c (extract_array_ref): Remove.         (fold_comparison): Handle POINTER_PLUS_EXPR with the         generic address expression comparison folding.  Remove         the folding that used extract_array_ref.  for GCC 4.3.  > Finally, refers to "gcc through which means > that it can't be for the non-bug (or actual bug?) that got fixed in > Yet I think that the reference to gcc bug is somewhat relevant, > because both CERT and comments on that bug mention the > wraparound case.  My limited understanding is that the fix that got > committed on would deal with the wraparound case as well. > However, perhaps - I am just guessing here - the same issue (a non-bug) > got re-introduced with another change to gcc later, and we do not > currently have a reference for that in the CVE entries.  As explained above it was a real bug and not related to pointer overflow (though the testcases look similar).  > I am really not into gcc internals, so it doesn't make sense for me to > continue to speculate on this.  Please ask the people who actually know, > such as Richard.  A wise suggestion.  We GCC folks hope there will be no repetition of such bad and wrong CERT reports like which - despite repeated request - got not updated to reflect reality and as such still badly damages both CERT and GCC reputation.  Richard.  --  Richard Guenther <rguenther@...e.de> Novell / SUSE Labs SUSE LINUX Products GmbH - Nuernberg - AG Nuernberg - HRB - GF: Markus Rex  Powered by blists - more mailing lists  Please check out the  Open Source Software Security Wiki, which is counterpart to this mailing list.  Confused about mailing lists and their use? Read about mailing lists on Wikipedia and check out these guidelines on proper formatting of your messages.      